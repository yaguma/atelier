# GameFlowManager TDD開発完了記録

## 確認すべきドキュメント

- `docs/tasks/atelier-guild-rank/phase-2/TASK-0017.md`
- `docs/implements/atelier-guild-rank/TASK-0017/game-flow-manager-requirements.md`
- `docs/implements/atelier-guild-rank/TASK-0017/game-flow-manager-testcases.md`

## 🎯 最終結果 (2026-01-17)
- **実装率**: 100% (14/14テストケース)
- **品質判定**: 合格
- **TODO更新**: ✅完了マーク追加

## 💡 重要な技術学習

### 実装パターン

#### 依存注入パターンの活用
- StateManager、DeckService、QuestService、EventBusを依存注入
- テスト時にモックを注入可能な設計により、単体テストの独立性を確保

#### イベント駆動設計の徹底
- 状態変更時に必ずEventBusを介してイベントを発行
- UI層との疎結合を実現し、ゲームフローの変更がUI層に自動的に伝播

#### 責務分離の明確化
- フェーズ遷移のバリデーションはStateManager側に委譲
- GameFlowManagerは進行制御のみに専念し、状態管理の詳細はStateManagerに任せる

### テスト設計

#### モック戦略の効果的な活用
- 各依存サービスをモック化し、GameFlowManagerの動作のみをテスト
- `vi.fn()`を使用したスパイにより、メソッド呼び出しの検証が容易

#### Given-When-Thenパターンの適用
- テスト構造を明確化し、可読性を大幅に向上
- 日本語コメントとの組み合わせで、テスト意図が一目瞭然

#### 境界値テストの重要性
- 残り日数0/-1/1の境界値テストにより、ゲーム終了判定の正確性を保証
- SランクとAランクの境界値テストにより、クリア条件の正確性を保証

### 品質保証

#### パフォーマンス最適化の重要性
- `getState()`の呼び出しを3回→1回に削減（67%削減）
- 計算結果を変数に保存して再利用することで、不要な再計算を回避

#### コメント品質の向上
- 暫定実装（INITIAL_DECK）の理由と将来計画を明示
- 拡張性の考慮（canAdvancePhase()）により、将来的な機能追加が容易

#### セキュリティとエラーハンドリング
- continueGame()での厳密な入力値検証（null/undefined、型、必須フィールド）
- ApplicationErrorを使用した明確なエラーメッセージ

## ⚠️ 仕様情報・将来的な拡張

### 暫定実装箇所

#### INITIAL_DECK（初期デッキ定義）
- **現状**: 空配列として実装
- **理由**: カードマスターデータの実装待ち
- **将来的な実装方法**:
  - マスターデータから取得する方式
  - ゲームバランス調整用の設定ファイルから読み込む方式
  - ランク別の初期デッキを定義する方式
- **依存タスク**: カードマスターデータの実装完了後に正式な定義を追加予定
- **テスト影響**: 現在のテストはモックを使用しているため、空配列でも問題なく動作

#### canAdvancePhase()（フェーズ進行可否判定）
- **現状**: 常にtrueを返す
- **理由**: プレイヤーの自由度を優先するゲームデザイン方針
- **将来的な実装例**:
  - 依頼受注フェーズ: 最低1つの依頼を受注している必要がある
  - 採取フェーズ: 最低1つの素材を採取している必要がある
  - 調合フェーズ: 最低1つのアイテムを調合している必要がある
  - 納品フェーズ: 特になし（常に進行可能）
- **拡張方法**: switch文でフェーズごとの判定ロジックを追加可能な設計

### ゲーム仕様の詳細

#### フェーズ進行ロジック
- **順序**: 依頼受注→採取→調合→納品→日終了
- **スキップ**: 可能（skipPhase()メソッド）
- **逆戻り**: 不可（StateManager側で制限）

#### 日進行の制約
- **AP回復**: 日開始時に最大値（3）に回復
- **依頼期限**: 日終了時に-1（QuestService経由）
- **残り日数**: 日終了時に-1

#### ゲーム終了条件
- **ゲームオーバー**: 残り日数≤0 かつ Sランク未到達
- **ゲームクリア**: Sランク到達

#### 休憩アクション
- **効果**: AP消費なしで日を進める
- **手札処理**: 手札を捨てて新しい手札をドロー（DeckService.refillHand()）
- **戦略性**: 不利な状況で次の日に進むための選択肢

### アーキテクチャ設計の重要な判断

#### フェーズ遷移のバリデーション
- **判断**: GameFlowManagerではバリデーションを行わず、StateManagerに委譲
- **理由**:
  - 責務分離（状態管理とバリデーションを一元管理）
  - 保守性向上（バリデーションロジックの変更がGameFlowManagerに影響しない）
  - テスト容易性（StateManagerのテストで集中的にバリデーションをテスト可能）

#### イベント発行の設計
- **DAY_STARTED**: 日開始時（day、remainingDaysを含む）
- **DAY_ENDED**: 日終了時（failedQuests、remainingDaysを含む）
- **GAME_OVER**: ゲームオーバー時（GameEndConditionを含む）
- **GAME_CLEARED**: ゲームクリア時（GameEndConditionを含む）
- **PHASE_CHANGED**: フェーズ変更時（StateManager経由で自動発行）

#### パフォーマンス最適化の設計判断
- **getState()の呼び出し削減**: 状態を変数に保存して再利用
- **計算結果の再利用**: endDay()で新しい日数を計算して変数に保存
- **改善効果**: テスト実行時間が5.05s → 4.07s（約19%短縮）

---

**最終更新**: 2026-01-17

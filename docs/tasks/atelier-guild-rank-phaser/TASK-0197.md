# TASK-0197: HandContainerカード選択実装

**タスクID**: TASK-0197
**タスクタイプ**: TDD
**推定工数**: 4時間
**フェーズ**: Phase 2 - 基本シーン・共通UI実装
**信頼性レベル**: 🟡 *妥当な推測に基づく*

## 関連文書

- **概要**: [overview.md](./overview.md)
- **UI設計**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## タスク概要

手札コンテナでのカード選択・選択解除機能を実装する。選択状態の視覚的フィードバックとコールバック連携を行う。

## 依存タスク

- **前提タスク**: TASK-0196
- **後続タスク**: TASK-0198

## 完了条件

- [x] カードクリックで選択状態になる
- [x] 選択中カードの再クリックで選択解除される
- [x] 選択状態が視覚的に表示される（拡大・ハイライト）
- [x] onCardSelect/onCardDeselectコールバックが発火する
- [x] setSelectableで選択可否を切り替えられる

---

## 実装詳細

### 1. 選択状態管理の強化 🟡

**信頼性**: 🟡 *TASK-0196の実装を拡張*

**実装ファイル**: `src/presentation/phaser/ui/hand/HandContainer.ts` (追加)

```typescript
// 選択時の視覚効果定数
const SelectionEffect = {
  SCALE_UP: 1.15,
  Y_OFFSET: -40,
  DURATION: 150,
  GLOW_COLOR: 0xffff00,
  GLOW_ALPHA: 0.5,
} as const;

// HandContainerクラスに追加
private selectionGlow?: Phaser.GameObjects.Graphics;

// selectCardメソッドの拡張
selectCard(cardOrIndex: Card | number): void {
  const index = typeof cardOrIndex === 'number'
    ? cardOrIndex
    : this.cards.indexOf(cardOrIndex);

  if (!this.selectable || index < 0 || index >= this.cards.length) return;

  // 既存の選択を解除
  if (this.selectedIndex >= 0 && this.selectedIndex !== index) {
    this.animateDeselect(this.selectedIndex);
  }

  this.selectedIndex = index;
  this.animateSelect(index);

  if (this.onCardSelect) {
    this.onCardSelect(this.cards[index], index);
  }
}

private animateSelect(index: number): void {
  const cardView = this.cardViews[index];
  if (!cardView) return;

  const positions = calculateCardPositions(
    this.cards.length,
    this.layoutType,
    this.centerX,
    this.centerY
  );
  const pos = positions[index];

  // 選択アニメーション
  this.scene.tweens.add({
    targets: cardView.container,
    y: pos.y + SelectionEffect.Y_OFFSET,
    scaleX: SelectionEffect.SCALE_UP,
    scaleY: SelectionEffect.SCALE_UP,
    duration: SelectionEffect.DURATION,
    ease: 'Back.easeOut',
  });

  // カード状態を選択に
  cardView.setState('selected');

  // 深度を最前面に
  cardView.container.setDepth(200);
}

private animateDeselect(index: number): void {
  const cardView = this.cardViews[index];
  if (!cardView) return;

  const positions = calculateCardPositions(
    this.cards.length,
    this.layoutType,
    this.centerX,
    this.centerY
  );
  const pos = positions[index];

  // 選択解除アニメーション
  this.scene.tweens.add({
    targets: cardView.container,
    y: pos.y,
    scaleX: 1,
    scaleY: 1,
    duration: SelectionEffect.DURATION,
    ease: 'Power2',
  });

  // カード状態を通常に
  cardView.setState('normal');

  // 深度を元に戻す
  cardView.container.setDepth(100 + pos.depth);
}

// deselectCardメソッドの拡張
deselectCard(): void {
  if (this.selectedIndex >= 0 && this.selectedIndex < this.cardViews.length) {
    const card = this.cards[this.selectedIndex];
    const index = this.selectedIndex;

    this.animateDeselect(index);
    this.selectedIndex = -1;

    if (this.onCardDeselect) {
      this.onCardDeselect(card, index);
    }
  }
}
```

### 2. 選択フィルター機能 🟡

**信頼性**: 🟡 *特定条件でのみ選択可能にする*

```typescript
// IHandContainerに追加
setSelectableFilter(filter: (card: Card, index: number) => boolean): void;
clearSelectableFilter(): void;

// HandContainerに実装
private selectableFilter?: (card: Card, index: number) => boolean;

setSelectableFilter(filter: (card: Card, index: number) => boolean): void {
  this.selectableFilter = filter;
  this.updateCardSelectability();
}

clearSelectableFilter(): void {
  this.selectableFilter = undefined;
  this.updateCardSelectability();
}

private updateCardSelectability(): void {
  this.cardViews.forEach((cardView, index) => {
    const card = this.cards[index];
    const canSelect = this.selectableFilter
      ? this.selectableFilter(card, index)
      : true;

    cardView.setInteractive(this.selectable && canSelect);
    cardView.setState(canSelect ? 'normal' : 'disabled');
  });
}

// handleCardClickの修正
private handleCardClick(index: number): void {
  if (!this.selectable) return;

  const card = this.cards[index];
  if (this.selectableFilter && !this.selectableFilter(card, index)) {
    return; // フィルターで除外
  }

  if (this.selectedIndex === index) {
    this.deselectCard();
  } else {
    this.selectCard(index);
  }
}
```

### 3. キーボード操作対応 🟡

**信頼性**: 🟡 *アクセシビリティ向上*

```typescript
// HandContainerに追加
private keyboardEnabled: boolean = false;

enableKeyboardNavigation(): void {
  if (this.keyboardEnabled) return;
  this.keyboardEnabled = true;

  this.scene.input.keyboard?.on('keydown-LEFT', this.handleKeyLeft, this);
  this.scene.input.keyboard?.on('keydown-RIGHT', this.handleKeyRight, this);
  this.scene.input.keyboard?.on('keydown-ENTER', this.handleKeyEnter, this);
  this.scene.input.keyboard?.on('keydown-ESC', this.handleKeyEscape, this);
}

disableKeyboardNavigation(): void {
  if (!this.keyboardEnabled) return;
  this.keyboardEnabled = false;

  this.scene.input.keyboard?.off('keydown-LEFT', this.handleKeyLeft, this);
  this.scene.input.keyboard?.off('keydown-RIGHT', this.handleKeyRight, this);
  this.scene.input.keyboard?.off('keydown-ENTER', this.handleKeyEnter, this);
  this.scene.input.keyboard?.off('keydown-ESC', this.handleKeyEscape, this);
}

private handleKeyLeft = (): void => {
  if (!this.selectable || this.cards.length === 0) return;

  const newIndex = this.selectedIndex <= 0
    ? this.cards.length - 1
    : this.selectedIndex - 1;
  this.selectCard(newIndex);
};

private handleKeyRight = (): void => {
  if (!this.selectable || this.cards.length === 0) return;

  const newIndex = this.selectedIndex >= this.cards.length - 1
    ? 0
    : this.selectedIndex + 1;
  this.selectCard(newIndex);
};

private handleKeyEnter = (): void => {
  // 選択確定（外部でハンドリング）
  if (this.selectedIndex >= 0 && this.onCardSelect) {
    this.onCardSelect(this.cards[this.selectedIndex], this.selectedIndex);
  }
};

private handleKeyEscape = (): void => {
  this.deselectCard();
};
```

---

## 単体テスト要件

### テストケース1: カード選択 🟡

**Given**: カードが5枚ある
**When**: 3番目のカードをクリックする
**Then**: 3番目のカードが選択状態になる

### テストケース2: 選択解除 🟡

**Given**: 3番目のカードが選択されている
**When**: 同じカードをクリックする
**Then**: 選択が解除される

### テストケース3: 選択切り替え 🟡

**Given**: 3番目のカードが選択されている
**When**: 1番目のカードをクリックする
**Then**: 1番目が選択され、3番目は解除される

### テストケース4: フィルター適用 🟡

**Given**: APコスト2以下のカードのみ選択可能フィルターを設定
**When**: APコスト3のカードをクリックする
**Then**: 選択されない

---

## 実装手順

1. `/tsumiki:tdd-requirements TASK-0197` - 詳細要件定義
2. `/tsumiki:tdd-testcases` - テストケース作成
3. `/tsumiki:tdd-red` - テスト実装（失敗）
4. `/tsumiki:tdd-green` - 最小実装
5. `/tsumiki:tdd-refactor` - リファクタリング
6. `/tsumiki:tdd-verify-complete` - 品質確認

---

## 注意事項

- 選択時のアニメーションと状態の同期
- フィルター変更時の既存選択の扱い
- キーボード操作時のフォーカス管理

---

## 信頼性レベルサマリー

- **総項目数**: 3項目
- 🔵 **青信号**: 0項目 (0%)
- 🟡 **黄信号**: 3項目 (100%)
- 🔴 **赤信号**: 0項目 (0%)

**品質評価**: 中品質

# TASK-0220: MaterialOptionViewè¨­è¨ˆãƒ»å®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0220
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 3 - ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠãƒ»ãƒ¡ã‚¤ãƒ³ç”»é¢å®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã§ç´ æé¸æŠè‚¢ã‚’è¡¨ç¤ºã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’è¨­è¨ˆãƒ»å®Ÿè£…ã™ã‚‹ã€‚é¸æŠå¯èƒ½ãªç´ æã‚’ã‚°ãƒªãƒƒãƒ‰ã§è¡¨ç¤ºã—ã€é¸æŠæ“ä½œã‚’æä¾›ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0178, TASK-0199
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0222

## å®Œäº†æ¡ä»¶

- [ ] IMaterialOptionViewã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹
- [ ] ç´ æé¸æŠè‚¢ãŒã‚°ãƒªãƒƒãƒ‰ã§è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ç´ æã‚’ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠã§ãã‚‹
- [ ] é¸æŠçŠ¶æ…‹ãŒè¦–è¦šçš„ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã•ã‚Œã‚‹
- [ ] å“è³ªã«å¿œã˜ãŸè‰²åˆ†ã‘ãŒã•ã‚Œã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. MaterialOptionViewå®šæ•° ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ç´ æé¸æŠè‚¢è¡¨ç¤º*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/material/MaterialOptionViewConstants.ts`

```typescript
export const MaterialOptionLayout = {
  // ã‚°ãƒªãƒƒãƒ‰è¨­å®š
  COLUMNS: 3,
  ITEM_WIDTH: 180,
  ITEM_HEIGHT: 80,
  ITEM_SPACING: 10,

  // ã‚¢ã‚¤ãƒ†ãƒ å†…éƒ¨
  ICON_SIZE: 48,
  PADDING: 10,
} as const;
```

### 2. IMaterialOptionViewã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/material/IMaterialOptionView.ts`

```typescript
import Phaser from 'phaser';
import { Material } from '../../../../domain/material/Material';

export interface MaterialOption {
  material: Material;
  quantity: number;
  probability?: number;
}

export interface MaterialOptionViewOptions {
  x?: number;
  y?: number;
  options: MaterialOption[];
  maxSelections?: number;
  onSelect?: (material: Material) => void;
  onDeselect?: (material: Material) => void;
}

export interface IMaterialOptionView {
  readonly container: Phaser.GameObjects.Container;

  // é¸æŠè‚¢è¨­å®š
  setOptions(options: MaterialOption[]): void;
  getOptions(): MaterialOption[];

  // é¸æŠç®¡ç†
  getSelectedMaterials(): Material[];
  selectMaterial(material: Material): void;
  deselectMaterial(material: Material): void;
  clearSelection(): void;

  // åˆ¶é™
  setMaxSelections(max: number): void;
  canSelectMore(): boolean;

  // è¡¨ç¤ºåˆ¶å¾¡
  setVisible(visible: boolean): void;
  setEnabled(enabled: boolean): void;

  // ç ´æ£„
  destroy(): void;
}
```

### 3. MaterialOptionViewå®Ÿè£… ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ç´ æé¸æŠã‚°ãƒªãƒƒãƒ‰*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/material/MaterialOptionView.ts`

```typescript
import Phaser from 'phaser';
import { Material } from '../../../../domain/material/Material';
import { IMaterialOptionView, MaterialOption, MaterialOptionViewOptions } from './IMaterialOptionView';
import { MaterialOptionLayout } from './MaterialOptionViewConstants';
import { MaterialQualityColors } from './MaterialConstants';
import { Colors } from '../../config/ColorPalette';
import { TextStyles } from '../../config/TextStyles';

interface OptionItemData {
  container: Phaser.GameObjects.Container;
  option: MaterialOption;
  selected: boolean;
}

export class MaterialOptionView implements IMaterialOptionView {
  public readonly container: Phaser.GameObjects.Container;

  private scene: Phaser.Scene;
  private options: MaterialOption[] = [];
  private optionItems: OptionItemData[] = [];
  private selectedMaterials: Material[] = [];
  private maxSelections: number;
  private enabled: boolean = true;

  private onSelect?: (material: Material) => void;
  private onDeselect?: (material: Material) => void;

  constructor(scene: Phaser.Scene, options: MaterialOptionViewOptions) {
    this.scene = scene;
    this.maxSelections = options.maxSelections ?? 1;
    this.onSelect = options.onSelect;
    this.onDeselect = options.onDeselect;

    const x = options.x ?? 0;
    const y = options.y ?? 0;

    this.container = scene.add.container(x, y);

    if (options.options.length > 0) {
      this.setOptions(options.options);
    }
  }

  setOptions(options: MaterialOption[]): void {
    this.clearItems();
    this.options = options;
    this.selectedMaterials = [];

    const { COLUMNS, ITEM_WIDTH, ITEM_HEIGHT, ITEM_SPACING } = MaterialOptionLayout;

    options.forEach((option, index) => {
      const col = index % COLUMNS;
      const row = Math.floor(index / COLUMNS);
      const x = col * (ITEM_WIDTH + ITEM_SPACING);
      const y = row * (ITEM_HEIGHT + ITEM_SPACING);

      const item = this.createOptionItem(option, x, y);
      this.optionItems.push(item);
      this.container.add(item.container);
    });
  }

  getOptions(): MaterialOption[] {
    return [...this.options];
  }

  private createOptionItem(option: MaterialOption, x: number, y: number): OptionItemData {
    const { ITEM_WIDTH, ITEM_HEIGHT, ICON_SIZE, PADDING } = MaterialOptionLayout;
    const itemContainer = this.scene.add.container(x, y);

    // èƒŒæ™¯
    const bg = this.scene.add.graphics();
    this.drawItemBackground(bg, false);
    itemContainer.add(bg);

    // å“è³ªã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
    if (option.material.quality) {
      const qualityColor = MaterialQualityColors[option.material.quality] ?? Colors.textPrimary;
      const qualityIndicator = this.scene.add.graphics();
      qualityIndicator.fillStyle(qualityColor, 1);
      qualityIndicator.fillRoundedRect(0, 0, 4, ITEM_HEIGHT, { tl: 8, bl: 8, tr: 0, br: 0 });
      itemContainer.add(qualityIndicator);
    }

    // ã‚¢ã‚¤ã‚³ãƒ³
    const icon = this.scene.add.text(
      PADDING + ICON_SIZE / 2,
      ITEM_HEIGHT / 2,
      this.getMaterialEmoji(option.material.category),
      { fontSize: '32px' }
    ).setOrigin(0.5);
    itemContainer.add(icon);

    // ç´ æå
    const nameText = this.scene.add.text(
      PADDING + ICON_SIZE + 10,
      15,
      option.material.name,
      { ...TextStyles.body, fontSize: '13px' }
    );
    itemContainer.add(nameText);

    // æ•°é‡
    const quantityText = this.scene.add.text(
      PADDING + ICON_SIZE + 10,
      35,
      `x${option.quantity}`,
      { ...TextStyles.bodySmall, fontSize: '11px', color: '#aaaaaa' }
    );
    itemContainer.add(quantityText);

    // ç¢ºç‡ï¼ˆã‚ã‚Œã°ï¼‰
    if (option.probability !== undefined) {
      const probText = this.scene.add.text(
        ITEM_WIDTH - PADDING,
        ITEM_HEIGHT / 2,
        `${Math.round(option.probability * 100)}%`,
        { ...TextStyles.bodySmall, fontSize: '12px', color: '#ffd700' }
      ).setOrigin(1, 0.5);
      itemContainer.add(probText);
    }

    // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
    itemContainer.setInteractive(
      new Phaser.Geom.Rectangle(0, 0, ITEM_WIDTH, ITEM_HEIGHT),
      Phaser.Geom.Rectangle.Contains
    );

    const itemData: OptionItemData = {
      container: itemContainer,
      option,
      selected: false,
    };

    itemContainer.on('pointerover', () => {
      if (this.enabled && !itemData.selected) {
        this.drawItemBackground(bg, false, true);
      }
    });

    itemContainer.on('pointerout', () => {
      if (this.enabled) {
        this.drawItemBackground(bg, itemData.selected);
      }
    });

    itemContainer.on('pointerdown', () => {
      if (this.enabled) {
        this.toggleSelection(itemData);
      }
    });

    itemContainer.setData('bg', bg);

    return itemData;
  }

  private drawItemBackground(
    bg: Phaser.GameObjects.Graphics,
    selected: boolean,
    hover: boolean = false
  ): void {
    const { ITEM_WIDTH, ITEM_HEIGHT } = MaterialOptionLayout;

    bg.clear();

    if (selected) {
      bg.fillStyle(Colors.accent, 0.3);
      bg.fillRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
      bg.lineStyle(2, Colors.accent);
      bg.strokeRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
    } else if (hover) {
      bg.fillStyle(0x3a3a5a, 0.9);
      bg.fillRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
      bg.lineStyle(1, 0x5a5a7a);
      bg.strokeRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
    } else {
      bg.fillStyle(0x2a2a4a, 0.9);
      bg.fillRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
      bg.lineStyle(1, 0x4a4a6a);
      bg.strokeRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
    }
  }

  private toggleSelection(itemData: OptionItemData): void {
    if (itemData.selected) {
      this.deselectMaterial(itemData.option.material);
    } else {
      this.selectMaterial(itemData.option.material);
    }
  }

  getSelectedMaterials(): Material[] {
    return [...this.selectedMaterials];
  }

  selectMaterial(material: Material): void {
    if (!this.canSelectMore()) return;

    const itemData = this.optionItems.find(item => item.option.material === material);
    if (!itemData || itemData.selected) return;

    itemData.selected = true;
    this.selectedMaterials.push(material);

    const bg = itemData.container.getData('bg') as Phaser.GameObjects.Graphics;
    this.drawItemBackground(bg, true);

    // é¸æŠã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    this.scene.tweens.add({
      targets: itemData.container,
      scaleX: 1.05,
      scaleY: 1.05,
      duration: 100,
      yoyo: true,
      ease: 'Power2',
    });

    if (this.onSelect) {
      this.onSelect(material);
    }
  }

  deselectMaterial(material: Material): void {
    const itemData = this.optionItems.find(item => item.option.material === material);
    if (!itemData || !itemData.selected) return;

    itemData.selected = false;
    this.selectedMaterials = this.selectedMaterials.filter(m => m !== material);

    const bg = itemData.container.getData('bg') as Phaser.GameObjects.Graphics;
    this.drawItemBackground(bg, false);

    if (this.onDeselect) {
      this.onDeselect(material);
    }
  }

  clearSelection(): void {
    this.optionItems.forEach(item => {
      if (item.selected) {
        item.selected = false;
        const bg = item.container.getData('bg') as Phaser.GameObjects.Graphics;
        this.drawItemBackground(bg, false);
      }
    });
    this.selectedMaterials = [];
  }

  setMaxSelections(max: number): void {
    this.maxSelections = max;
  }

  canSelectMore(): boolean {
    return this.selectedMaterials.length < this.maxSelections;
  }

  setVisible(visible: boolean): void {
    this.container.setVisible(visible);
  }

  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
    this.container.setAlpha(enabled ? 1 : 0.5);
  }

  destroy(): void {
    this.clearItems();
    this.container.destroy();
  }

  private clearItems(): void {
    this.optionItems.forEach(item => item.container.destroy());
    this.optionItems = [];
  }

  private getMaterialEmoji(category: string): string {
    switch (category) {
      case 'plant': return 'ğŸŒ¿';
      case 'mineral': return 'ğŸ’';
      case 'liquid': return 'ğŸ’§';
      case 'powder': return 'âœ¨';
      case 'monster': return 'ğŸ¦´';
      default: return 'ğŸ“¦';
    }
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: é¸æŠè‚¢è¡¨ç¤º ğŸ”µ

**Given**: MaterialOptionViewãŒã‚ã‚‹
**When**: setOptions([...])ã‚’å‘¼ã¶
**Then**: ã‚°ãƒªãƒƒãƒ‰ã§é¸æŠè‚¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ç´ æé¸æŠ ğŸ”µ

**Given**: é¸æŠè‚¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: ç´ æã‚’ã‚¯ãƒªãƒƒã‚¯
**Then**: é¸æŠçŠ¶æ…‹ã«ãªã‚Šã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå‘¼ã°ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: é¸æŠä¸Šé™ ğŸ”µ

**Given**: maxSelections=1ã§1ã¤é¸æŠæ¸ˆã¿
**When**: åˆ¥ã®ç´ æã‚’ã‚¯ãƒªãƒƒã‚¯
**Then**: é¸æŠã•ã‚Œãªã„

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0220` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨ˆç®—
- é¸æŠä¸Šé™ã®ç®¡ç†
- ç¢ºç‡è¡¨ç¤ºã®æ‰±ã„

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 3é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 3é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

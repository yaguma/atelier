# TASK-0251: EventBus-UseCaseé€£æºå®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0251
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4 - ã‚µãƒ–ã‚·ãƒ¼ãƒ³ãƒ»Applicationå±¤ä¿®æ­£
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ **: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

EventBusã¨Applicationå±¤UseCaseé–“ã®å®Ÿéš›ã®é€£æºã‚’å®Ÿè£…ã™ã‚‹ã€‚TASK-0250ã§è¨­è¨ˆã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«åŸºã¥ãå®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0250
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0254

## å®Œäº†æ¡ä»¶

- [ ] GameUseCaseHandlerãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] å„UseCaseãŒEventBusã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼çµŒç”±ã§å‘¼ã³å‡ºã•ã‚Œã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] çµæœãŒUIã«æ­£ã—ãé€šçŸ¥ã•ã‚Œã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. GameUseCaseHandlerå®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *UseCaseé€£æº*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/application/GameUseCaseHandler.ts`

```typescript
import { IUIEventHandler } from '../events/EventHandlers';
import { EventBusAdapter } from '../events/EventBusAdapter';
import { QuestUseCase } from '@/application/usecase/QuestUseCase';
import { GatheringUseCase } from '@/application/usecase/GatheringUseCase';
import { AlchemyUseCase } from '@/application/usecase/AlchemyUseCase';
import { ShopUseCase } from '@/application/usecase/ShopUseCase';
import { DeckUseCase } from '@/application/usecase/DeckUseCase';
import { GameFlowUseCase } from '@/application/usecase/GameFlowUseCase';
import { SaveLoadUseCase } from '@/application/usecase/SaveLoadUseCase';
import { RankUseCase } from '@/application/usecase/RankUseCase';

export class GameUseCaseHandler implements IUIEventHandler {
  private eventBusAdapter: EventBusAdapter;
  private questUseCase: QuestUseCase;
  private gatheringUseCase: GatheringUseCase;
  private alchemyUseCase: AlchemyUseCase;
  private shopUseCase: ShopUseCase;
  private deckUseCase: DeckUseCase;
  private gameFlowUseCase: GameFlowUseCase;
  private saveLoadUseCase: SaveLoadUseCase;
  private rankUseCase: RankUseCase;

  constructor(
    eventBusAdapter: EventBusAdapter,
    useCases: {
      questUseCase: QuestUseCase;
      gatheringUseCase: GatheringUseCase;
      alchemyUseCase: AlchemyUseCase;
      shopUseCase: ShopUseCase;
      deckUseCase: DeckUseCase;
      gameFlowUseCase: GameFlowUseCase;
      saveLoadUseCase: SaveLoadUseCase;
      rankUseCase: RankUseCase;
    }
  ) {
    this.eventBusAdapter = eventBusAdapter;
    this.questUseCase = useCases.questUseCase;
    this.gatheringUseCase = useCases.gatheringUseCase;
    this.alchemyUseCase = useCases.alchemyUseCase;
    this.shopUseCase = useCases.shopUseCase;
    this.deckUseCase = useCases.deckUseCase;
    this.gameFlowUseCase = useCases.gameFlowUseCase;
    this.saveLoadUseCase = useCases.saveLoadUseCase;
    this.rankUseCase = useCases.rankUseCase;

    // è‡ªèº«ã‚’ãƒãƒ³ãƒ‰ãƒ©ã¨ã—ã¦ç™»éŒ²
    this.eventBusAdapter.setUIEventHandler(this);
  }

  async handleQuestAcceptRequest(payload: { questId: string }): Promise<void> {
    try {
      const result = await this.questUseCase.acceptQuest(payload.questId);

      this.eventBusAdapter.emitToUI({
        type: 'quest:accepted',
        payload: {
          quest: result.quest,
          acceptedQuests: result.acceptedQuests,
        },
      });

      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚‚æ›´æ–°
      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('quest:accept', error);
    }
  }

  async handleQuestDeliveryRequest(payload: { questId: string; itemIds: string[] }): Promise<void> {
    try {
      const result = await this.questUseCase.deliverQuest(payload.questId, payload.itemIds);

      this.eventBusAdapter.emitToUI({
        type: 'quest:delivered',
        payload: {
          quest: result.quest,
          rewards: result.rewards,
          rewardCards: result.rewardCards ?? [],
        },
      });

      // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ›´æ–°
      this.emitInventoryUpdate();
      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('quest:delivery', error);
    }
  }

  async handleGatheringExecuteRequest(payload: { cardId: string; selectedMaterialIds: string[] }): Promise<void> {
    try {
      const result = await this.gatheringUseCase.executeGathering(
        payload.cardId,
        payload.selectedMaterialIds
      );

      this.eventBusAdapter.emitToUI({
        type: 'gathering:complete',
        payload: {
          materials: result.materials,
          apUsed: result.apUsed,
          remainingAp: result.remainingAp,
        },
      });

      // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãƒ»æ‰‹æœ­æ›´æ–°
      this.emitInventoryUpdate();
      this.emitHandUpdate();
      this.emitDeckUpdate();
      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('gathering', error);
    }
  }

  async handleAlchemyCraftRequest(payload: { recipeCardId: string; materialIds: string[] }): Promise<void> {
    try {
      const result = await this.alchemyUseCase.craft(
        payload.recipeCardId,
        payload.materialIds
      );

      this.eventBusAdapter.emitToUI({
        type: 'alchemy:crafted',
        payload: {
          item: result.item,
          quality: result.quality,
          traits: result.traits,
          success: result.success,
        },
      });

      // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãƒ»æ‰‹æœ­æ›´æ–°
      this.emitInventoryUpdate();
      this.emitHandUpdate();
      this.emitDeckUpdate();
      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('alchemy', error);
    }
  }

  async handleShopPurchaseRequest(payload: { category: string; itemId: string; quantity?: number }): Promise<void> {
    try {
      const result = await this.shopUseCase.purchase(
        payload.category as any,
        payload.itemId,
        payload.quantity ?? 1
      );

      this.eventBusAdapter.emitToUI({
        type: 'shop:purchased',
        payload: {
          item: result.item,
          quantity: result.quantity,
          newGold: result.newGold,
        },
      });

      // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ›´æ–°ï¼ˆç´ æ/ã‚«ãƒ¼ãƒ‰ã®å ´åˆï¼‰
      if (payload.category === 'material') {
        this.emitInventoryUpdate();
      } else if (payload.category === 'card') {
        this.emitHandUpdate();
        this.emitDeckUpdate();
      }

      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('shop', error);
    }
  }

  async handleCardDrawRequest(payload: { count: number }): Promise<void> {
    try {
      const result = await this.deckUseCase.draw(payload.count);

      this.eventBusAdapter.emitToUI({
        type: 'hand:updated',
        payload: {
          cards: result.hand,
        },
      });

      this.eventBusAdapter.emitToUI({
        type: 'deck:updated',
        payload: {
          deckCount: result.deckCount,
          discardCount: result.discardCount,
        },
      });

      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('card:draw', error);
    }
  }

  async handleDeckShuffleRequest(): Promise<void> {
    try {
      const result = await this.deckUseCase.shuffleDiscardIntoDeck();

      this.eventBusAdapter.emitToUI({
        type: 'deck:updated',
        payload: {
          deckCount: result.deckCount,
          discardCount: result.discardCount,
        },
      });
    } catch (error) {
      this.handleError('deck:shuffle', error);
    }
  }

  async handlePhaseSkipRequest(payload: { phase: string }): Promise<void> {
    try {
      const result = await this.gameFlowUseCase.skipPhase(payload.phase);

      this.eventBusAdapter.emitToUI({
        type: 'phase:changed',
        payload: {
          previousPhase: payload.phase,
          currentPhase: result.nextPhase,
          phaseData: result.phaseData,
        },
      });

      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('phase:skip', error);
    }
  }

  async handleDayEndRequest(): Promise<void> {
    try {
      const result = await this.gameFlowUseCase.endDay();

      this.eventBusAdapter.emitToUI({
        type: 'day:ended',
        payload: {
          newDay: result.newDay,
          summary: result.summary,
        },
      });

      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
      if (result.isGameOver) {
        this.eventBusAdapter.emitToUI({
          type: 'game:over',
          payload: {
            reason: result.gameOverReason!,
            stats: result.stats,
          },
        });
      }

      // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢åˆ¤å®š
      if (result.isGameClear) {
        this.eventBusAdapter.emitToUI({
          type: 'game:clear',
          payload: {
            stats: result.stats,
          },
        });
      }

      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('day:end', error);
    }
  }

  async handleGameSaveRequest(payload: { slotId: number }): Promise<void> {
    try {
      await this.saveLoadUseCase.save(payload.slotId);

      // æˆåŠŸé€šçŸ¥ï¼ˆãƒˆãƒ¼ã‚¹ãƒˆï¼‰
      this.eventBusAdapter.emitToUI({
        type: 'game:state:updated',
        payload: await this.getCurrentGameState(),
      });
    } catch (error) {
      this.handleError('game:save', error);
    }
  }

  async handleGameLoadRequest(payload: { slotId: number }): Promise<void> {
    try {
      await this.saveLoadUseCase.load(payload.slotId);

      // å…¨çŠ¶æ…‹æ›´æ–°
      this.emitFullStateUpdate();
    } catch (error) {
      this.handleError('game:load', error);
    }
  }

  async handleRankUpChallengeRequest(payload: { targetRank: string }): Promise<void> {
    try {
      const result = await this.rankUseCase.challenge(payload.targetRank);

      if (result.success) {
        this.eventBusAdapter.emitToUI({
          type: 'rankup:success',
          payload: {
            newRank: result.newRank!,
            rewards: result.rewards!,
          },
        });
      } else {
        this.eventBusAdapter.emitToUI({
          type: 'rankup:failed',
          payload: {
            reason: result.reason!,
          },
        });
      }

      this.emitGameStateUpdate();
    } catch (error) {
      this.handleError('rankup', error);
    }
  }

  // ===== ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ =====

  private async getCurrentGameState(): Promise<any> {
    return this.gameFlowUseCase.getCurrentState();
  }

  private async emitGameStateUpdate(): Promise<void> {
    const state = await this.getCurrentGameState();
    this.eventBusAdapter.emitToUI({
      type: 'game:state:updated',
      payload: state,
    });
  }

  private async emitInventoryUpdate(): Promise<void> {
    const inventory = await this.gameFlowUseCase.getInventory();
    this.eventBusAdapter.emitToUI({
      type: 'inventory:updated',
      payload: { items: inventory },
    });
  }

  private async emitHandUpdate(): Promise<void> {
    const hand = await this.deckUseCase.getHand();
    this.eventBusAdapter.emitToUI({
      type: 'hand:updated',
      payload: { cards: hand },
    });
  }

  private async emitDeckUpdate(): Promise<void> {
    const deckInfo = await this.deckUseCase.getDeckInfo();
    this.eventBusAdapter.emitToUI({
      type: 'deck:updated',
      payload: {
        deckCount: deckInfo.deckCount,
        discardCount: deckInfo.discardCount,
      },
    });
  }

  private async emitFullStateUpdate(): Promise<void> {
    await this.emitGameStateUpdate();
    await this.emitInventoryUpdate();
    await this.emitHandUpdate();
    await this.emitDeckUpdate();
  }

  private handleError(operation: string, error: unknown): void {
    console.error(`Error in ${operation}:`, error);

    const message = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';

    this.eventBusAdapter.emitToUI({
      type: 'error:occurred',
      payload: {
        code: operation,
        message,
        recoverable: true,
      },
    });
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ä¾é ¼å—æ³¨ ğŸŸ¡

**Given**: GameUseCaseHandlerãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹
**When**: handleQuestAcceptRequestã‚’å‘¼ã¶
**Then**: QuestUseCaseãŒå‘¼ã°ã‚Œã€quest:acceptedã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ğŸŸ¡

**Given**: UseCaseãŒã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹
**When**: ãƒãƒ³ãƒ‰ãƒ©ã‚’å‘¼ã¶
**Then**: error:occurredã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: çŠ¶æ…‹æ›´æ–° ğŸŸ¡

**Given**: æ“ä½œãŒæˆåŠŸ
**When**: æ“ä½œå®Œäº†å¾Œ
**Then**: game:state:updatedã‚¤ãƒ™ãƒ³ãƒˆã‚‚ç™ºç«ã™ã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0251` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- UseCaseä¾å­˜æ€§ã®æ³¨å…¥
- éåŒæœŸå‡¦ç†ã®å®Œäº†å¾…ã¡
- è¤‡æ•°ã‚¤ãƒ™ãƒ³ãƒˆã®é †åºä¿è¨¼

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 1é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ªï¼ˆå®Ÿè£…æ™‚ã«èª¿æ•´è¦ï¼‰

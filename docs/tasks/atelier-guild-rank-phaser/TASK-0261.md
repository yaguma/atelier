# TASK-0261: 1ã‚¿ãƒ¼ãƒ³ã‚µã‚¤ã‚¯ãƒ«çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆå‰åŠï¼‰ âœ… **å®Œäº†** (TDDé–‹ç™ºå®Œäº† - 20ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å…¨é€šé)

**ã‚¿ã‚¹ã‚¯ID**: TASK-0261
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**å®Ÿç¸¾å·¥æ•°**: 4æ™‚é–“
**å®Œäº†æ—¥**: 2026-01-13
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–ãƒ»ä»•ä¸Šã’
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

1ã‚¿ãƒ¼ãƒ³ï¼ˆ1æ—¥ï¼‰ã®ã‚²ãƒ¼ãƒ ã‚µã‚¤ã‚¯ãƒ«ã®å‰åŠéƒ¨åˆ†ï¼ˆä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºã€æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºï¼‰ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0219 (QuestAcceptContainerãƒ†ã‚¹ãƒˆ), TASK-0225 (GatheringContainerãƒ†ã‚¹ãƒˆ)
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0262

## å®Œäº†æ¡ä»¶

- [x] ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹ï¼ˆTC-01ã€œTC-04, TC-14, TC-16ã€œTC-17ï¼‰
- [x] æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹ï¼ˆTC-05ã€œTC-09, TC-15, TC-18ã€œTC-20ï¼‰
- [x] ãƒ•ã‚§ãƒ¼ã‚ºé–“é·ç§»ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹ï¼ˆTC-10ã€œTC-11ï¼‰
- [x] çŠ¶æ…‹æ›´æ–°ã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹ï¼ˆTC-12ã€œTC-13ï¼‰
- [x] APæ¶ˆè²»ã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹ï¼ˆTC-06, TC-15, TC-18ã€œTC-19ï¼‰

**ãƒ†ã‚¹ãƒˆçµæœ**: å…¨20ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æˆåŠŸï¼ˆ100%ï¼‰
**è¦ä»¶ç¶²ç¾…ç‡**: 100%ï¼ˆ29/29é …ç›®ï¼‰

---

## ãƒ†ã‚¹ãƒˆå®Ÿè£…è©³ç´°

### 1. 1ã‚¿ãƒ¼ãƒ³å‰åŠçµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase5/TurnCycleFirstHalf.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createTestGame, waitForPhase, simulateClick } from '../../../utils/phaserTestUtils';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';

describe('Turn Cycle First Half Integration', () => {
  let game: Phaser.Game;
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;

  beforeEach(async () => {
    const testSetup = await createTestGame();
    game = testSetup.game;
    eventBus = testSetup.eventBus;
    stateManager = game.registry.get('stateManager');

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    eventBus.emit('ui:game:start:requested', { isNewGame: true });
    await waitForPhase(game, 'quest-accept');
  });

  afterEach(() => {
    game.destroy(true);
  });

  describe('Quest Accept Phase', () => {
    it('ä¾é ¼ä¸€è¦§ãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Assert
      const quests = stateManager.getQuests();
      expect(quests.available.length).toBeGreaterThan(0);
    });

    it('ä¾é ¼ã‚’å—æ³¨ã§ãã‚‹', async () => {
      // Arrange
      const quests = stateManager.getQuests();
      const questToAccept = quests.available[0];

      // Act
      eventBus.emit('ui:quest:accept:requested', { questId: questToAccept.id });

      // Assert
      await vi.waitFor(() => {
        const updatedQuests = stateManager.getQuests();
        expect(updatedQuests.accepted).toContainEqual(
          expect.objectContaining({ id: questToAccept.id })
        );
        expect(updatedQuests.available).not.toContainEqual(
          expect.objectContaining({ id: questToAccept.id })
        );
      });
    });

    it('æœ€å¤§3ã¤ã¾ã§ä¾é ¼ã‚’å—æ³¨ã§ãã‚‹', async () => {
      // Arrange
      const quests = stateManager.getQuests();

      // Act - 3ã¤å—æ³¨
      for (let i = 0; i < 3 && i < quests.available.length; i++) {
        eventBus.emit('ui:quest:accept:requested', { questId: quests.available[i].id });
        await vi.waitFor(() => {
          const updated = stateManager.getQuests();
          return updated.accepted.length === i + 1;
        });
      }

      // 4ã¤ç›®ã‚’è©¦ã¿ã‚‹
      const errorCallback = vi.fn();
      eventBus.on('app:error:occurred', errorCallback);

      if (stateManager.getQuests().available.length > 0) {
        eventBus.emit('ui:quest:accept:requested', {
          questId: stateManager.getQuests().available[0].id,
        });

        // Assert
        await vi.waitFor(() => {
          expect(errorCallback).toHaveBeenCalledWith(
            expect.objectContaining({
              message: expect.stringContaining('æœ€å¤§'),
            })
          );
        });
      }
    });

    it('ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºã‚’ã‚¹ã‚­ãƒƒãƒ—ã§ãã‚‹', async () => {
      // Act
      eventBus.emit('ui:phase:skip:requested', { phase: 'quest-accept' });

      // Assert
      await waitForPhase(game, 'gathering');
      expect(stateManager.getProgress().currentPhase).toBe('gathering');
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã§æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»ã™ã‚‹', async () => {
      // Act
      eventBus.emit('ui:phase:complete', { phase: 'quest-accept' });

      // Assert
      await waitForPhase(game, 'gathering');
      expect(stateManager.getProgress().currentPhase).toBe('gathering');
    });
  });

  describe('Gathering Phase', () => {
    beforeEach(async () => {
      // æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»
      eventBus.emit('ui:phase:complete', { phase: 'quest-accept' });
      await waitForPhase(game, 'gathering');
    });

    it('æ¡å–åœ°ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Assert
      const deck = stateManager.getDeck();
      const gatheringCards = deck.hand.filter((c: any) => c.type === 'gathering');
      expect(gatheringCards.length).toBeGreaterThanOrEqual(0); // åˆæœŸãƒ‡ãƒƒã‚­ä¾å­˜
    });

    it('æ¡å–ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ã§ç´ æã‚’ç²å¾—ã§ãã‚‹', async () => {
      // Arrange
      const deck = stateManager.getDeck();
      const gatheringCard = deck.hand.find((c: any) => c.type === 'gathering');

      if (!gatheringCard) {
        console.log('No gathering card in hand, skipping test');
        return;
      }

      const initialMaterials = stateManager.getInventory().materials.length;
      const initialAP = stateManager.getPlayerData().ap.current;

      // Act
      eventBus.emit('ui:gathering:execute:requested', {
        cardId: gatheringCard.id,
        selectedMaterialIds: ['material_option_1'],
      });

      // Assert
      await vi.waitFor(() => {
        const inventory = stateManager.getInventory();
        const player = stateManager.getPlayerData();

        expect(inventory.materials.length).toBeGreaterThan(initialMaterials);
        expect(player.ap.current).toBeLessThan(initialAP);
      });
    });

    it('APä¸è¶³æ™‚ã¯æ¡å–ã§ããªã„', async () => {
      // Arrange - APã‚’0ã«
      stateManager.updatePlayer({ ap: { current: 0, max: 3 } });

      const deck = stateManager.getDeck();
      const gatheringCard = deck.hand.find((c: any) => c.type === 'gathering');

      if (!gatheringCard) {
        return;
      }

      const errorCallback = vi.fn();
      eventBus.on('app:error:occurred', errorCallback);

      // Act
      eventBus.emit('ui:gathering:execute:requested', {
        cardId: gatheringCard.id,
        selectedMaterialIds: ['material_option_1'],
      });

      // Assert
      await vi.waitFor(() => {
        expect(errorCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            message: expect.stringContaining('AP'),
          })
        );
      });
    });

    it('ä½¿ç”¨ã—ãŸã‚«ãƒ¼ãƒ‰ãŒæ¨ã¦æœ­ã«ç§»å‹•ã™ã‚‹', async () => {
      // Arrange
      const deck = stateManager.getDeck();
      const gatheringCard = deck.hand.find((c: any) => c.type === 'gathering');

      if (!gatheringCard) {
        return;
      }

      // Act
      eventBus.emit('ui:gathering:execute:requested', {
        cardId: gatheringCard.id,
        selectedMaterialIds: ['material_option_1'],
      });

      // Assert
      await vi.waitFor(() => {
        const updatedDeck = stateManager.getDeck();
        expect(updatedDeck.hand).not.toContainEqual(
          expect.objectContaining({ id: gatheringCard.id })
        );
        expect(updatedDeck.discard).toContainEqual(
          expect.objectContaining({ id: gatheringCard.id })
        );
      });
    });

    it('æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã‚’ã‚¹ã‚­ãƒƒãƒ—ã§ãã‚‹', async () => {
      // Act
      eventBus.emit('ui:phase:skip:requested', { phase: 'gathering' });

      // Assert
      await waitForPhase(game, 'alchemy');
      expect(stateManager.getProgress().currentPhase).toBe('alchemy');
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã§èª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»ã™ã‚‹', async () => {
      // Act
      eventBus.emit('ui:phase:complete', { phase: 'gathering' });

      // Assert
      await waitForPhase(game, 'alchemy');
      expect(stateManager.getProgress().currentPhase).toBe('alchemy');
    });
  });

  describe('Phase Transition State Preservation', () => {
    it('ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»å¾Œã‚‚ç²å¾—ã—ãŸç´ æãŒä¿æŒã•ã‚Œã‚‹', async () => {
      // Arrange - æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã§ç´ æç²å¾—
      eventBus.emit('ui:phase:complete', { phase: 'quest-accept' });
      await waitForPhase(game, 'gathering');

      const deck = stateManager.getDeck();
      const gatheringCard = deck.hand.find((c: any) => c.type === 'gathering');

      if (gatheringCard) {
        eventBus.emit('ui:gathering:execute:requested', {
          cardId: gatheringCard.id,
          selectedMaterialIds: ['material_option_1'],
        });

        await vi.waitFor(() => {
          return stateManager.getInventory().materials.length > 0;
        });
      }

      const materialsBeforeTransition = stateManager.getInventory().materials;

      // Act - èª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»
      eventBus.emit('ui:phase:complete', { phase: 'gathering' });
      await waitForPhase(game, 'alchemy');

      // Assert
      const materialsAfterTransition = stateManager.getInventory().materials;
      expect(materialsAfterTransition).toEqual(materialsBeforeTransition);
    });

    it('å—æ³¨ã—ãŸä¾é ¼ãŒãƒ•ã‚§ãƒ¼ã‚ºã‚’è·¨ã„ã§ä¿æŒã•ã‚Œã‚‹', async () => {
      // Arrange - ä¾é ¼å—æ³¨
      const quests = stateManager.getQuests();
      if (quests.available.length > 0) {
        eventBus.emit('ui:quest:accept:requested', { questId: quests.available[0].id });
        await vi.waitFor(() => stateManager.getQuests().accepted.length > 0);
      }

      const acceptedBefore = stateManager.getQuests().accepted;

      // Act - ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»
      eventBus.emit('ui:phase:complete', { phase: 'quest-accept' });
      await waitForPhase(game, 'gathering');
      eventBus.emit('ui:phase:complete', { phase: 'gathering' });
      await waitForPhase(game, 'alchemy');

      // Assert
      const acceptedAfter = stateManager.getQuests().accepted;
      expect(acceptedAfter).toEqual(acceptedBefore);
    });
  });

  describe('EventBus Communication', () => {
    it('ä¾é ¼å—æ³¨æ™‚ã«æ­£ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      // Arrange
      const questAcceptedCallback = vi.fn();
      eventBus.on('app:quests:accepted:updated', questAcceptedCallback);

      const quests = stateManager.getQuests();
      if (quests.available.length === 0) return;

      // Act
      eventBus.emit('ui:quest:accept:requested', { questId: quests.available[0].id });

      // Assert
      await vi.waitFor(() => {
        expect(questAcceptedCallback).toHaveBeenCalled();
      });
    });

    it('æ¡å–å®Ÿè¡Œæ™‚ã«æ­£ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      // Arrange
      eventBus.emit('ui:phase:complete', { phase: 'quest-accept' });
      await waitForPhase(game, 'gathering');

      const gatheringCompleteCallback = vi.fn();
      eventBus.on('app:gathering:complete', gatheringCompleteCallback);

      const deck = stateManager.getDeck();
      const gatheringCard = deck.hand.find((c: any) => c.type === 'gathering');
      if (!gatheringCard) return;

      // Act
      eventBus.emit('ui:gathering:execute:requested', {
        cardId: gatheringCard.id,
        selectedMaterialIds: ['material_option_1'],
      });

      // Assert
      await vi.waitFor(() => {
        expect(gatheringCompleteCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            materials: expect.any(Array),
            apUsed: expect.any(Number),
          })
        );
      });
    });
  });
});
```

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0261` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| ãƒ†ã‚¹ãƒˆå¯¾è±¡ | ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸ |
|-----------|---------------|
| ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚º | 90% |
| æ¡å–ãƒ•ã‚§ãƒ¼ã‚º | 90% |
| ãƒ•ã‚§ãƒ¼ã‚ºé·ç§» | 100% |

---

## æ³¨æ„äº‹é …

- åˆæœŸãƒ‡ãƒƒã‚­ã®å†…å®¹ã«ä¾å­˜ã™ã‚‹ãƒ†ã‚¹ãƒˆ
- éåŒæœŸå‡¦ç†ã®å®Œäº†å¾…ã¡
- çŠ¶æ…‹ã®ä¸€è²«æ€§æ¤œè¨¼

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 1é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

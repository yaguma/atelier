# TASK-0263: è¤‡æ•°æ—¥é€²è¡Œçµ±åˆãƒ†ã‚¹ãƒˆ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0263
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–ãƒ»ä»•ä¸Šã’
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼**: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

è¤‡æ•°æ—¥ï¼ˆè¤‡æ•°ã‚¿ãƒ¼ãƒ³ï¼‰ã«ã‚ãŸã‚‹ã‚²ãƒ¼ãƒ é€²è¡ŒãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚æ—¥æ•°çµŒéã€ãƒ©ãƒ³ã‚¯é€²è¡Œã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢æ¡ä»¶ã‚’æ¤œè¨¼ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0261, TASK-0262
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0266, TASK-0267

## å®Œäº†æ¡ä»¶

- [ ] è¤‡æ•°æ—¥é€²è¡Œã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] ãƒ©ãƒ³ã‚¯é€²è¡Œã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] æ—¥æ•°åˆ¶é™ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] çµŒé¨“å€¤ãƒ»ã‚´ãƒ¼ãƒ«ãƒ‰ç´¯ç©ã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] æ–°è¦ä¾é ¼ç”Ÿæˆã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹

---

## ãƒ†ã‚¹ãƒˆå®Ÿè£…è©³ç´°

### 1. è¤‡æ•°æ—¥é€²è¡Œçµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase5/MultiDayProgression.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createTestGame, advanceDay, simulateFullDay } from '../../../utils/phaserTestUtils';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';

describe('Multi-Day Progression Integration', () => {
  let game: Phaser.Game;
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;

  beforeEach(async () => {
    const testSetup = await createTestGame();
    game = testSetup.game;
    eventBus = testSetup.eventBus;
    stateManager = game.registry.get('stateManager');

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    eventBus.emit('ui:game:start:requested', { isNewGame: true });
  });

  afterEach(() => {
    game.destroy(true);
  });

  describe('Day Progression', () => {
    it('1æ—¥ãŒæ­£å¸¸ã«é€²è¡Œã™ã‚‹', async () => {
      // Arrange
      const initialDay = stateManager.getProgress().currentDay;

      // Act
      await advanceDay(game, eventBus);

      // Assert
      expect(stateManager.getProgress().currentDay).toBe(initialDay + 1);
    });

    it('è¤‡æ•°æ—¥ã‚’é€£ç¶šã—ã¦é€²è¡Œã§ãã‚‹', async () => {
      // Arrange
      const initialDay = stateManager.getProgress().currentDay;
      const daysToAdvance = 5;

      // Act
      for (let i = 0; i < daysToAdvance; i++) {
        await advanceDay(game, eventBus);
      }

      // Assert
      expect(stateManager.getProgress().currentDay).toBe(initialDay + daysToAdvance);
    });

    it('å„æ—¥ã®é–‹å§‹æ™‚ã«APãŒæœ€å¤§å€¤ã«å›å¾©ã™ã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ ap: { current: 0, max: 3 } });

      // Act
      await advanceDay(game, eventBus);

      // Assert
      const player = stateManager.getPlayerData();
      expect(player.ap.current).toBe(player.ap.max);
    });

    it('å„æ—¥ã®é–‹å§‹æ™‚ã«æ–°ã—ã„ä¾é ¼ãŒç”Ÿæˆã•ã‚Œã‚‹', async () => {
      // Arrange
      const initialAvailable = stateManager.getQuests().available.length;

      // Act
      await advanceDay(game, eventBus);

      // Assert
      const quests = stateManager.getQuests();
      expect(quests.available.length).toBeGreaterThanOrEqual(1);
    });
  });

  describe('Experience and Rank Progression', () => {
    it('ä¾é ¼å®Œäº†ã§çµŒé¨“å€¤ãŒè“„ç©ã•ã‚Œã‚‹', async () => {
      // Arrange
      const initialExp = stateManager.getPlayerData().exp;

      // ä¾é ¼ã‚’å®Œäº†ã•ã›ã‚‹
      const quest = {
        id: 'test_quest',
        requirements: [{ itemId: 'item_001', quantity: 1 }],
        rewards: { gold: 100, exp: 50 },
      };
      stateManager.updateQuests({
        accepted: [quest],
        available: [],
        completed: [],
      });
      stateManager.updateInventory({
        craftedItems: [{ id: 'item_001', quantity: 1 }],
        materials: [],
        artifacts: [],
      });

      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'test_quest',
        itemIds: ['item_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const player = stateManager.getPlayerData();
        expect(player.exp).toBe(initialExp + 50);
      });
    });

    it('çµŒé¨“å€¤ãŒä¸Šé™ã«é”ã™ã‚‹ã¨ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—å¯èƒ½ã«ãªã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({
        rank: 'E',
        exp: 99,
        maxExp: 100,
      });

      // ä¾é ¼å®Œäº†ã§çµŒé¨“å€¤+50
      const quest = {
        id: 'test_quest',
        requirements: [{ itemId: 'item_001', quantity: 1 }],
        rewards: { gold: 100, exp: 50 },
      };
      stateManager.updateQuests({ accepted: [quest], available: [], completed: [] });
      stateManager.updateInventory({
        craftedItems: [{ id: 'item_001', quantity: 1 }],
        materials: [],
        artifacts: [],
      });

      const rankUpAvailableCallback = vi.fn();
      eventBus.on('app:rankup:available', rankUpAvailableCallback);

      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'test_quest',
        itemIds: ['item_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const player = stateManager.getPlayerData();
        expect(player.exp).toBeGreaterThanOrEqual(100);
      });
    });

    it('è¤‡æ•°æ—¥ã«ã‚ãŸã£ã¦ã‚´ãƒ¼ãƒ«ãƒ‰ãŒç´¯ç©ã™ã‚‹', async () => {
      // Arrange
      let totalGoldEarned = 0;
      const initialGold = stateManager.getPlayerData().gold;

      // Act - è¤‡æ•°æ—¥ã€å„æ—¥ã§ä¾é ¼ã‚’å®Œäº†
      for (let day = 0; day < 3; day++) {
        const quest = {
          id: `quest_day_${day}`,
          requirements: [{ itemId: 'item_001', quantity: 1 }],
          rewards: { gold: 100 + day * 50, exp: 20 },
        };
        stateManager.updateQuests({ accepted: [quest], available: [], completed: [] });
        stateManager.updateInventory({
          craftedItems: [{ id: 'item_001', quantity: 1 }],
          materials: [],
          artifacts: [],
        });

        eventBus.emit('ui:quest:delivery:requested', {
          questId: quest.id,
          itemIds: ['item_001'],
        });

        totalGoldEarned += quest.rewards.gold;

        await vi.waitFor(() => {
          return stateManager.getQuests().completed.length > day;
        });

        if (day < 2) {
          await advanceDay(game, eventBus);
        }
      }

      // Assert
      const finalGold = stateManager.getPlayerData().gold;
      expect(finalGold).toBe(initialGold + totalGoldEarned);
    });
  });

  describe('Day Limit', () => {
    it('æœ€å¤§æ—¥æ•°ã«è¿‘ã¥ãã¨è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 25, maxDay: 30 });

      const warningCallback = vi.fn();
      eventBus.on('app:day:warning', warningCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      // æ®‹ã‚Š5æ—¥ä»¥ä¸‹ã§è­¦å‘Š
      await vi.waitFor(() => {
        expect(warningCallback).toHaveBeenCalled();
      });
    });

    it('æœ€å¤§æ—¥æ•°ã‚’è¶…ãˆã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'C' }); // Sãƒ©ãƒ³ã‚¯æœªé”

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            reason: expect.stringContaining('æœŸé™'),
          })
        );
      });
    });

    it('æœ€å¤§æ—¥æ•°å‰ã«Sãƒ©ãƒ³ã‚¯ã«åˆ°é”ã™ã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 20, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'A', exp: 999, maxExp: 1000 });

      // ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ã—ã¦Sãƒ©ãƒ³ã‚¯ã«
      eventBus.emit('ui:rankup:challenge:requested', { targetRank: 'S' });

      const gameClearCallback = vi.fn();
      eventBus.on('app:game:clear', gameClearCallback);

      // Assert
      await vi.waitFor(() => {
        expect(gameClearCallback).toHaveBeenCalled();
      });
    });
  });

  describe('Gold Management', () => {
    it('ã‚´ãƒ¼ãƒ«ãƒ‰ãŒãƒã‚¤ãƒŠã‚¹ã«ãªã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: 10 });

      // é«˜é¡ã‚¢ã‚¤ãƒ†ãƒ ã‚’è³¼å…¥
      eventBus.emit('ui:shop:purchase:requested', {
        category: 'card',
        itemId: 'expensive_card', // ä¾¡æ ¼ > 10
        quantity: 1,
      });

      // ã“ã‚ŒãŒå¤±æ•—ã™ã‚‹ã‹ã€æˆåŠŸã—ã¦ã‚´ãƒ¼ãƒ«ãƒ‰ãŒãƒã‚¤ãƒŠã‚¹ã«ãªã‚‹ã‹
      // å®Ÿè£…ã«ã‚ˆã£ã¦ã¯ã‚¨ãƒ©ãƒ¼ã§å¼¾ã
      const errorCallback = vi.fn();
      eventBus.on('app:error:occurred', errorCallback);

      await vi.waitFor(() => {
        // ã‚¨ãƒ©ãƒ¼ã§å¼¾ã‹ã‚Œã‚‹ã‹ç¢ºèª
        expect(errorCallback).toHaveBeenCalled();
      });
    });

    it('ã‚·ãƒ§ãƒƒãƒ—ã§ã®è³¼å…¥ã§ã‚´ãƒ¼ãƒ«ãƒ‰ãŒæ¸›å°‘ã™ã‚‹', async () => {
      // Arrange
      const initialGold = stateManager.getPlayerData().gold;

      // Act
      eventBus.emit('ui:shop:purchase:requested', {
        category: 'material',
        itemId: 'basic_herb',
        quantity: 1,
      });

      // Assert
      await vi.waitFor(() => {
        const player = stateManager.getPlayerData();
        expect(player.gold).toBeLessThan(initialGold);
      });
    });
  });

  describe('Quest Generation', () => {
    it('æ—¥ãŒé€²ã‚€ã¨æ–°ã—ã„ä¾é ¼ãŒè¿½åŠ ã•ã‚Œã‚‹', async () => {
      // Act
      await advanceDay(game, eventBus);

      // Assert
      const quests = stateManager.getQuests();
      expect(quests.available.length).toBeGreaterThan(0);
    });

    it('ãƒ©ãƒ³ã‚¯ã«å¿œã˜ãŸä¾é ¼ãŒç”Ÿæˆã•ã‚Œã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ rank: 'B' });

      // Act
      await advanceDay(game, eventBus);

      // Assert
      const quests = stateManager.getQuests();
      // Bãƒ©ãƒ³ã‚¯ä»¥ä¸‹ã®ä¾é ¼ãŒå«ã¾ã‚Œã‚‹
      expect(quests.available.some(q =>
        ['E', 'D', 'C', 'B'].includes(q.requiredRank ?? 'E')
      )).toBe(true);
    });

    it('æœªå®Œäº†ã®å—æ³¨ä¾é ¼ã¯ç¿Œæ—¥ã‚‚ç¶™ç¶šã™ã‚‹', async () => {
      // Arrange
      const acceptedQuest = {
        id: 'continuing_quest',
        name: 'ç¶™ç¶šä¾é ¼',
        requirements: [{ itemId: 'rare_item', quantity: 1 }],
        deadline: 3,
      };
      stateManager.updateQuests({
        accepted: [acceptedQuest],
        available: [],
        completed: [],
      });

      // Act
      await advanceDay(game, eventBus);

      // Assert
      const quests = stateManager.getQuests();
      expect(quests.accepted).toContainEqual(
        expect.objectContaining({ id: 'continuing_quest' })
      );
    });

    it('æœŸé™åˆ‡ã‚Œã®ä¾é ¼ã¯å¤±æ•—æ‰±ã„ã«ãªã‚‹', async () => {
      // Arrange
      const expiringQuest = {
        id: 'expiring_quest',
        name: 'æœŸé™åˆ‡ã‚Œä¾é ¼',
        requirements: [{ itemId: 'item', quantity: 1 }],
        deadline: 1, // 1æ—¥ã§æœŸé™åˆ‡ã‚Œ
      };
      stateManager.updateQuests({
        accepted: [expiringQuest],
        available: [],
        completed: [],
      });

      const questFailedCallback = vi.fn();
      eventBus.on('app:quest:failed', questFailedCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(questFailedCallback).toHaveBeenCalledWith(
          expect.objectContaining({ questId: 'expiring_quest' })
        );
      });
    });
  });

  describe('Deck Management', () => {
    it('æ—¥ãŒé€²ã‚€ã¨æ‰‹æœ­ãŒè£œå……ã•ã‚Œã‚‹', async () => {
      // Arrange - æ‰‹æœ­ã‚’ç©ºã«
      stateManager.updateDeck({
        hand: [],
        cards: [
          { id: 'card_1', type: 'gathering' },
          { id: 'card_2', type: 'gathering' },
          { id: 'card_3', type: 'recipe' },
        ],
        discard: [],
      });

      // Act
      await advanceDay(game, eventBus);

      // Assert
      const deck = stateManager.getDeck();
      expect(deck.hand.length).toBeGreaterThan(0);
    });

    it('æ¨ã¦æœ­ã¯ãƒ‡ãƒƒã‚­ã«æˆ»ã‚‹', async () => {
      // Arrange
      stateManager.updateDeck({
        hand: [],
        cards: [],
        discard: [
          { id: 'card_1', type: 'gathering' },
          { id: 'card_2', type: 'recipe' },
        ],
      });

      // Act
      await advanceDay(game, eventBus);

      // Assert
      const deck = stateManager.getDeck();
      // æ¨ã¦æœ­ãŒãƒ‡ãƒƒã‚­ã«æˆ»ã‚Šã€ãã“ã‹ã‚‰ãƒ‰ãƒ­ãƒ¼ã•ã‚Œã‚‹
      expect(deck.hand.length + deck.cards.length + deck.discard.length).toBe(2);
    });
  });
});
```

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0263` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| ãƒ†ã‚¹ãƒˆå¯¾è±¡ | ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸ |
|-----------|---------------|
| æ—¥æ•°é€²è¡Œ | 100% |
| ãƒ©ãƒ³ã‚¯é€²è¡Œ | 90% |
| ã‚´ãƒ¼ãƒ«ãƒ‰ç®¡ç† | 90% |
| ä¾é ¼ç”Ÿæˆ | 85% |

---

## æ³¨æ„äº‹é …

- é•·æœŸãƒ—ãƒ¬ã‚¤ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
- å¢ƒç•Œæ¡ä»¶ï¼ˆæ—¥æ•°ä¸Šé™ã€ã‚´ãƒ¼ãƒ«ãƒ‰ä¸‹é™ï¼‰
- çŠ¶æ…‹ã®ä¸€è²«æ€§ç¶­æŒ

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 1é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

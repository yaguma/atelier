# TASK-0229: AlchemyContainerç´ æé¸æŠå®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0229
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 3 - ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠãƒ»ãƒ¡ã‚¤ãƒ³ç”»é¢å®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

AlchemyContainerã®ç´ æé¸æŠãƒ»èª¿åˆå®Ÿè¡Œæ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚ç´ æé¸æŠã€å“è³ªäºˆæ¸¬ã€èª¿åˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Œæˆã•ã›ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0228
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0230

## å®Œäº†æ¡ä»¶

- [ ] ç´ æã‚’è¤‡æ•°é¸æŠã§ãã‚‹
- [ ] é¸æŠã«å¿œã˜ã¦å“è³ªäºˆæ¸¬ãŒæ›´æ–°ã•ã‚Œã‚‹
- [ ] èª¿åˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå†ç”Ÿã•ã‚Œã‚‹
- [ ] èª¿åˆçµæœãŒè¡¨ç¤ºã•ã‚Œã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. ç´ æé¸æŠUIå¼·åŒ– ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ç´ æé¸æŠ*

```typescript
// AlchemyContainerã«è¿½åŠ 

private materialRequirementIndicator?: Phaser.GameObjects.Container;

private createMaterialRequirementIndicator(): void {
  const { MATERIAL_AREA } = AlchemyContainerLayout;

  this.materialRequirementIndicator = this.scene.add.container(
    MATERIAL_AREA.X,
    MATERIAL_AREA.Y + MATERIAL_AREA.HEIGHT + 10
  );
  this.container.add(this.materialRequirementIndicator);

  this.updateMaterialRequirementIndicator();
}

private updateMaterialRequirementIndicator(): void {
  if (!this.materialRequirementIndicator) return;

  // æ—¢å­˜ã‚’ã‚¯ãƒªã‚¢
  this.materialRequirementIndicator.removeAll(true);

  if (!this.selectedRecipe) {
    const text = this.scene.add.text(0, 0, 'ãƒ¬ã‚·ãƒ”ã‚’é¸æŠã—ã¦ãã ã•ã„', {
      ...TextStyles.body,
      fontSize: '12px',
      color: '#666666',
    });
    this.materialRequirementIndicator.add(text);
    return;
  }

  const required = this.selectedRecipe.requiredMaterialCount ?? 1;
  const selected = this.selectedMaterials.length;

  // é€²æ—è¡¨ç¤º
  const progressText = this.scene.add.text(0, 0, `ç´ æ: ${selected}/${required}`, {
    ...TextStyles.body,
    fontSize: '12px',
    color: selected >= required ? '#00ff00' : '#ffffff',
  });
  this.materialRequirementIndicator.add(progressText);

  // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼
  const barBg = this.scene.add.graphics();
  barBg.fillStyle(0x333333, 1);
  barBg.fillRoundedRect(100, -2, 150, 16, 4);
  this.materialRequirementIndicator.add(barBg);

  if (selected > 0) {
    const barFill = this.scene.add.graphics();
    const fillWidth = Math.min(1, selected / required) * 150;
    const fillColor = selected >= required ? 0x00ff00 : 0x00aaff;
    barFill.fillStyle(fillColor, 1);
    barFill.fillRoundedRect(100, -2, fillWidth, 16, 4);
    this.materialRequirementIndicator.add(barFill);
  }

  // ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤º
  for (let i = 0; i < required; i++) {
    const icon = this.scene.add.text(260 + i * 20, 0, i < selected ? 'âœ…' : 'â¬œ', {
      fontSize: '12px',
    });
    this.materialRequirementIndicator.add(icon);
  }
}

private handleMaterialSelect(material: Material): void {
  // ä¸Šé™ãƒã‚§ãƒƒã‚¯
  const required = this.selectedRecipe?.requiredMaterialCount ?? 1;
  if (this.selectedMaterials.length >= required) {
    this.showMaterialLimitFeedback();
    return;
  }

  this.selectedMaterials.push(material);
  this.updateMaterialRequirementIndicator();
  this.updatePreview();
  this.eventBus.emit('alchemy:material:selected', { material });

  // é¸æŠå®Œäº†ãƒã‚§ãƒƒã‚¯
  if (this.selectedMaterials.length >= required) {
    this.onMaterialSelectionComplete();
  }
}

private showMaterialLimitFeedback(): void {
  // ä¸Šé™ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
  const message = this.scene.add.text(
    AlchemyContainerLayout.WIDTH / 2,
    AlchemyContainerLayout.MATERIAL_AREA.Y + 100,
    'ç´ æã®é¸æŠä¸Šé™ã«é”ã—ã¾ã—ãŸ',
    { ...TextStyles.body, fontSize: '12px', color: '#ffaa00' }
  ).setOrigin(0.5);
  this.container.add(message);

  this.scene.tweens.add({
    targets: message,
    y: message.y - 20,
    alpha: 0,
    duration: 1000,
    ease: 'Power2',
    onComplete: () => message.destroy(),
  });
}

private onMaterialSelectionComplete(): void {
  // èª¿åˆãƒœã‚¿ãƒ³ã‚’å¼·èª¿
  if (this.craftButton) {
    this.scene.tweens.add({
      targets: this.craftButton,
      scaleX: 1.1,
      scaleY: 1.1,
      duration: 200,
      yoyo: true,
      ease: 'Power2',
    });
  }

  // å®Œäº†ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆã‚µã‚¦ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…æ™‚ï¼‰
  this.eventBus.emit('alchemy:materials:complete', {
    materials: this.selectedMaterials,
  });
}
```

### 2. èª¿åˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *è¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯*

```typescript
// AlchemyContainerã«è¿½åŠ 

private async playCraftAnimation(): Promise<void> {
  return new Promise((resolve) => {
    const centerX = AlchemyContainerLayout.WIDTH / 2;
    const centerY = AlchemyContainerLayout.HEIGHT / 2 - 50;

    // ç´ æãŒä¸­å¤®ã«é›†ã¾ã‚‹
    const particlePromises = this.selectedMaterials.map((material, index) =>
      this.animateMaterialToCauldron(material, index, centerX, centerY)
    );

    Promise.all(particlePromises).then(() => {
      // é‡œã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      this.playCauldronEffect(centerX, centerY).then(() => {
        // çµæœã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾
        this.playItemAppearEffect(centerX, centerY).then(resolve);
      });
    });
  });
}

private animateMaterialToCauldron(
  material: Material,
  index: number,
  targetX: number,
  targetY: number
): Promise<void> {
  return new Promise((resolve) => {
    const startX = 100 + (index % 4) * 120;
    const startY = AlchemyContainerLayout.MATERIAL_AREA.Y + 80;

    const emoji = this.getMaterialEmoji(material.category);
    const particle = this.scene.add.text(startX, startY, emoji, {
      fontSize: '24px',
    }).setOrigin(0.5);
    this.container.add(particle);

    // å¼§ã‚’æã„ã¦é£›ã¶
    this.scene.tweens.add({
      targets: particle,
      x: targetX,
      y: targetY,
      scale: 0.5,
      duration: 500 + index * 100,
      ease: 'Power2.easeIn',
      onComplete: () => {
        // æ¶ˆãˆã‚‹æ™‚ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        this.createMaterialAbsorbEffect(targetX, targetY, material.category);
        particle.destroy();
        resolve();
      },
    });
  });
}

private createMaterialAbsorbEffect(x: number, y: number, category: string): void {
  const colors: Record<string, number> = {
    'plant': 0x00ff00,
    'mineral': 0x6666ff,
    'liquid': 0x00aaff,
    'powder': 0xffff00,
    'monster': 0xff6666,
  };
  const color = colors[category] ?? 0xffffff;

  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  for (let i = 0; i < 8; i++) {
    const spark = this.scene.add.graphics();
    spark.fillStyle(color, 1);
    spark.fillCircle(0, 0, 4);
    spark.x = x;
    spark.y = y;
    this.container.add(spark);

    const angle = (i / 8) * Math.PI * 2;
    const distance = 30;

    this.scene.tweens.add({
      targets: spark,
      x: x + Math.cos(angle) * distance,
      y: y + Math.sin(angle) * distance,
      alpha: 0,
      scale: 0.3,
      duration: 300,
      ease: 'Power2',
      onComplete: () => spark.destroy(),
    });
  }
}

private async playCauldronEffect(x: number, y: number): Promise<void> {
  return new Promise((resolve) => {
    // é‡œã®ã‚°ãƒ­ãƒ¼
    const cauldron = this.scene.add.graphics();
    cauldron.fillStyle(0x4a2a6a, 0.8);
    cauldron.fillCircle(x, y, 60);
    this.container.add(cauldron);

    // æ³¡ç«‹ã¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    const bubbleCount = 20;
    for (let i = 0; i < bubbleCount; i++) {
      this.scene.time.delayedCall(i * 50, () => {
        const bubble = this.scene.add.graphics();
        const bx = x + (Math.random() - 0.5) * 80;
        const by = y + (Math.random() - 0.5) * 80;
        bubble.fillStyle(0xaa88ff, 0.7);
        bubble.fillCircle(0, 0, 5 + Math.random() * 10);
        bubble.x = bx;
        bubble.y = by;
        this.container.add(bubble);

        this.scene.tweens.add({
          targets: bubble,
          y: by - 50,
          alpha: 0,
          scale: 1.5,
          duration: 500,
          ease: 'Power2',
          onComplete: () => bubble.destroy(),
        });
      });
    }

    // å…‰ã®ãƒ‘ãƒ«ã‚¹
    this.scene.tweens.add({
      targets: cauldron,
      alpha: 1,
      scale: 1.3,
      duration: 500,
      yoyo: true,
      onComplete: () => {
        // çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        cauldron.clear();
        cauldron.fillStyle(0xffffff, 1);
        cauldron.fillCircle(x, y, 10);

        this.scene.tweens.add({
          targets: cauldron,
          scale: 5,
          alpha: 0,
          duration: 300,
          ease: 'Power2',
          onComplete: () => {
            cauldron.destroy();
            resolve();
          },
        });
      },
    });
  });
}

private async playItemAppearEffect(x: number, y: number): Promise<void> {
  return new Promise((resolve) => {
    // çµæœã‚¢ã‚¤ãƒ†ãƒ 
    const item = this.scene.add.text(x, y, 'âœ¨', {
      fontSize: '48px',
    }).setOrigin(0.5);
    item.setAlpha(0);
    item.setScale(0);
    this.container.add(item);

    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    this.scene.tweens.add({
      targets: item,
      alpha: 1,
      scale: 1,
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        // æµ®éŠã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        this.scene.tweens.add({
          targets: item,
          y: y - 10,
          duration: 500,
          yoyo: true,
          repeat: 2,
          ease: 'Sine.easeInOut',
          onComplete: () => {
            item.destroy();
            resolve();
          },
        });
      },
    });
  });
}

private getMaterialEmoji(category: string): string {
  switch (category) {
    case 'plant': return 'ğŸŒ¿';
    case 'mineral': return 'ğŸ’';
    case 'liquid': return 'ğŸ’§';
    case 'powder': return 'âœ¨';
    case 'monster': return 'ğŸ¦´';
    default: return 'ğŸ“¦';
  }
}
```

### 3. èª¿åˆçµæœè¡¨ç¤º ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµæœãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯*

```typescript
// AlchemyContainerã«è¿½åŠ 

private async showCraftSuccess(result: AlchemyResult): Promise<void> {
  return new Promise((resolve) => {
    const centerX = AlchemyContainerLayout.WIDTH / 2;
    const centerY = AlchemyContainerLayout.HEIGHT / 2;

    // çµæœãƒ‘ãƒãƒ«
    const panel = this.scene.add.container(centerX, centerY);

    // èƒŒæ™¯
    const bg = this.scene.add.graphics();
    bg.fillStyle(0x1a1a3a, 0.95);
    bg.fillRoundedRect(-150, -100, 300, 200, 12);
    bg.lineStyle(2, Colors.accent);
    bg.strokeRoundedRect(-150, -100, 300, 200, 12);
    panel.add(bg);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const title = this.scene.add.text(0, -80, 'âœ¨ èª¿åˆæˆåŠŸï¼ âœ¨', {
      ...TextStyles.heading,
      fontSize: '20px',
      color: '#ffd700',
    }).setOrigin(0.5);
    panel.add(title);

    // ã‚¢ã‚¤ãƒ†ãƒ å
    const itemName = this.scene.add.text(0, -40, result.craftedItem.name, {
      ...TextStyles.body,
      fontSize: '18px',
      fontStyle: 'bold',
    }).setOrigin(0.5);
    panel.add(itemName);

    // å“è³ª
    const qualityColors: Record<string, string> = {
      'legendary': '#ffd700',
      'epic': '#a335ee',
      'rare': '#0070dd',
      'good': '#1eff00',
      'normal': '#ffffff',
    };
    const qualityText = this.scene.add.text(0, -10, result.quality.toUpperCase(), {
      ...TextStyles.body,
      fontSize: '16px',
      color: qualityColors[result.quality] ?? '#ffffff',
    }).setOrigin(0.5);
    panel.add(qualityText);

    // ç‰¹æ€§
    if (result.traits.length > 0) {
      const traitsText = this.scene.add.text(0, 25, `ç‰¹æ€§: ${result.traits.join(', ')}`, {
        ...TextStyles.body,
        fontSize: '12px',
        color: '#aaaaff',
      }).setOrigin(0.5);
      panel.add(traitsText);
    }

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
    const closeBtn = this.scene.add.text(0, 70, '[ é–‰ã˜ã‚‹ ]', {
      ...TextStyles.body,
      fontSize: '14px',
      color: '#aaaaaa',
    }).setOrigin(0.5).setInteractive();

    closeBtn.on('pointerover', () => closeBtn.setColor('#ffffff'));
    closeBtn.on('pointerout', () => closeBtn.setColor('#aaaaaa'));
    closeBtn.on('pointerdown', () => {
      this.scene.tweens.add({
        targets: panel,
        alpha: 0,
        scale: 0.8,
        duration: 200,
        onComplete: () => {
          panel.destroy();
          resolve();
        },
      });
    });
    panel.add(closeBtn);

    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    panel.setAlpha(0);
    panel.setScale(0.8);
    this.container.add(panel);

    this.scene.tweens.add({
      targets: panel,
      alpha: 1,
      scale: 1,
      duration: 300,
      ease: 'Back.easeOut',
    });
  });
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ç´ æé¸æŠä¸Šé™ ğŸ”µ

**Given**: å¿…è¦ç´ ææ•°ãŒ3ã®ãƒ¬ã‚·ãƒ”ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹
**When**: 4ã¤ç›®ã®ç´ æã‚’é¸æŠ
**Then**: é¸æŠã•ã‚Œãšä¸Šé™ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: å“è³ªäºˆæ¸¬æ›´æ–° ğŸ”µ

**Given**: ãƒ¬ã‚·ãƒ”ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹
**When**: é«˜å“è³ªã®ç´ æã‚’é¸æŠ
**Then**: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®äºˆæ¸¬å“è³ªãŒæ›´æ–°ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: èª¿åˆå®Œäº† ğŸ”µ

**Given**: å¿…è¦ãªç´ æãŒã™ã¹ã¦é¸æŠã•ã‚Œã¦ã„ã‚‹
**When**: èª¿åˆãƒœã‚¿ãƒ³ã‚’æŠ¼ã™
**Then**: èª¿åˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå†ç”Ÿã•ã‚ŒçµæœãŒè¡¨ç¤ºã•ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0229` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®æ“ä½œãƒ–ãƒ­ãƒƒã‚¯
- Promiseãƒã‚§ãƒ¼ãƒ³ã®æ­£ç¢ºãªç®¡ç†
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã®åˆ¶é™ï¼‰

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 3é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 3é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

# TASK-0270: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬

**ã‚¿ã‚¹ã‚¯ID**: TASK-0270
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: DIRECT
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–ãƒ»ä»•ä¸Šã’
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”´ *Phaserå›ºæœ‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: [architecture.md](../../design/atelier-guild-rank-phaser/architecture.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

ã‚²ãƒ¼ãƒ å…¨ä½“ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è¨ˆæ¸¬ã—ã€ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã‚’ç‰¹å®šã™ã‚‹ã€‚FPSã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã€ã‚·ãƒ¼ãƒ³é·ç§»æ™‚é–“ã€ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†æ™‚é–“ã‚’æ¸¬å®šã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0260ã€œ0269 (å…¨çµ±åˆãƒ†ã‚¹ãƒˆ)
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0271, TASK-0272, TASK-0273

## å®Œäº†æ¡ä»¶

- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ãƒ„ãƒ¼ãƒ«ãŒå°å…¥ã•ã‚Œã¦ã„ã‚‹
- [ ] FPSè¨ˆæ¸¬çµæœãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç®‡æ‰€ãŒç‰¹å®šã•ã‚Œã¦ã„ã‚‹
- [ ] æœ€é©åŒ–å„ªå…ˆåº¦ãƒªã‚¹ãƒˆãŒä½œæˆã•ã‚Œã¦ã„ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚° ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *è¨ˆæ¸¬ãƒ„ãƒ¼ãƒ«*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/debug/PerformanceMonitor.ts`

```typescript
import Phaser from 'phaser';

export interface PerformanceMetrics {
  fps: number;
  memory: {
    usedJSHeapSize: number;
    totalJSHeapSize: number;
    jsHeapSizeLimit: number;
  } | null;
  sceneTransitionTime: number;
  eventProcessingTime: number;
  renderTime: number;
  updateTime: number;
}

export interface PerformanceReport {
  timestamp: number;
  metrics: PerformanceMetrics;
  averages: {
    fps: number;
    memory: number;
    sceneTransition: number;
  };
  recommendations: string[];
}

/**
 * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ã‚¯ãƒ©ã‚¹
 */
export class PerformanceMonitor {
  private scene: Phaser.Scene;
  private enabled: boolean = false;
  private fpsHistory: number[] = [];
  private memoryHistory: number[] = [];
  private sceneTransitionTimes: Map<string, number> = new Map();
  private eventTimes: Map<string, number[]> = new Map();
  private lastUpdateTime: number = 0;
  private lastRenderTime: number = 0;
  private historySize: number = 60; // 60ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†

  // UIè¦ç´ 
  private debugText?: Phaser.GameObjects.Text;
  private fpsGraph?: Phaser.GameObjects.Graphics;

  constructor(scene: Phaser.Scene) {
    this.scene = scene;
  }

  enable(): void {
    this.enabled = true;
    this.createDebugUI();
    console.log('Performance monitoring enabled');
  }

  disable(): void {
    this.enabled = false;
    this.destroyDebugUI();
    console.log('Performance monitoring disabled');
  }

  private createDebugUI(): void {
    // FPS/ãƒ¡ãƒ¢ãƒªè¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ
    this.debugText = this.scene.add.text(10, 10, '', {
      fontSize: '12px',
      color: '#00ff00',
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      padding: { x: 5, y: 5 },
    }).setScrollFactor(0).setDepth(9999);

    // FPSã‚°ãƒ©ãƒ•
    this.fpsGraph = this.scene.add.graphics()
      .setScrollFactor(0).setDepth(9999);
  }

  private destroyDebugUI(): void {
    this.debugText?.destroy();
    this.fpsGraph?.destroy();
  }

  update(): void {
    if (!this.enabled) return;

    const now = performance.now();
    this.lastUpdateTime = now;

    // FPSè¨˜éŒ²
    const fps = this.scene.game.loop.actualFps;
    this.fpsHistory.push(fps);
    if (this.fpsHistory.length > this.historySize) {
      this.fpsHistory.shift();
    }

    // ãƒ¡ãƒ¢ãƒªè¨˜éŒ²ï¼ˆChrome onlyï¼‰
    const memory = this.getMemoryUsage();
    if (memory) {
      this.memoryHistory.push(memory.usedJSHeapSize);
      if (this.memoryHistory.length > this.historySize) {
        this.memoryHistory.shift();
      }
    }

    // UIæ›´æ–°
    this.updateDebugUI(fps, memory);
  }

  private getMemoryUsage(): PerformanceMetrics['memory'] {
    // Chrome DevTools ã®ãƒ¡ãƒ¢ãƒªAPI
    const performance = window.performance as any;
    if (performance.memory) {
      return {
        usedJSHeapSize: performance.memory.usedJSHeapSize,
        totalJSHeapSize: performance.memory.totalJSHeapSize,
        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
      };
    }
    return null;
  }

  private updateDebugUI(fps: number, memory: PerformanceMetrics['memory']): void {
    if (!this.debugText) return;

    const avgFps = this.getAverageFps();
    const memoryMB = memory ? (memory.usedJSHeapSize / 1024 / 1024).toFixed(1) : 'N/A';

    this.debugText.setText([
      `FPS: ${fps.toFixed(0)} (avg: ${avgFps.toFixed(0)})`,
      `Memory: ${memoryMB} MB`,
      `Scene: ${this.scene.scene.key}`,
      `Objects: ${this.scene.children.length}`,
    ].join('\n'));

    // FPSã‚°ãƒ©ãƒ•æç”»
    this.drawFpsGraph();
  }

  private drawFpsGraph(): void {
    if (!this.fpsGraph) return;

    this.fpsGraph.clear();
    this.fpsGraph.fillStyle(0x000000, 0.5);
    this.fpsGraph.fillRect(10, 100, 120, 50);

    // 60FPSãƒ©ã‚¤ãƒ³
    this.fpsGraph.lineStyle(1, 0x00ff00, 0.5);
    this.fpsGraph.lineBetween(10, 125, 130, 125);

    // FPSå±¥æ­´æç”»
    this.fpsGraph.lineStyle(1, 0x00ff00, 1);
    this.fpsGraph.beginPath();

    this.fpsHistory.forEach((fps, i) => {
      const x = 10 + (i * 2);
      const y = 150 - (fps / 60 * 50);

      if (i === 0) {
        this.fpsGraph!.moveTo(x, y);
      } else {
        this.fpsGraph!.lineTo(x, y);
      }
    });

    this.fpsGraph.strokePath();
  }

  getAverageFps(): number {
    if (this.fpsHistory.length === 0) return 0;
    return this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
  }

  getAverageMemory(): number {
    if (this.memoryHistory.length === 0) return 0;
    return this.memoryHistory.reduce((a, b) => a + b, 0) / this.memoryHistory.length;
  }

  // ã‚·ãƒ¼ãƒ³é·ç§»æ™‚é–“è¨ˆæ¸¬
  startSceneTransition(fromScene: string, toScene: string): void {
    const key = `${fromScene}->${toScene}`;
    this.sceneTransitionTimes.set(key, performance.now());
  }

  endSceneTransition(fromScene: string, toScene: string): number {
    const key = `${fromScene}->${toScene}`;
    const startTime = this.sceneTransitionTimes.get(key);

    if (startTime) {
      const duration = performance.now() - startTime;
      this.sceneTransitionTimes.delete(key);
      console.log(`Scene transition ${key}: ${duration.toFixed(2)}ms`);
      return duration;
    }

    return 0;
  }

  // ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†æ™‚é–“è¨ˆæ¸¬
  startEventMeasure(eventName: string): void {
    if (!this.eventTimes.has(eventName)) {
      this.eventTimes.set(eventName, []);
    }
    (this.eventTimes.get(eventName) as any)._startTime = performance.now();
  }

  endEventMeasure(eventName: string): void {
    const times = this.eventTimes.get(eventName);
    if (times && (times as any)._startTime) {
      const duration = performance.now() - (times as any)._startTime;
      times.push(duration);

      // å±¥æ­´ã‚’åˆ¶é™
      if (times.length > 100) {
        times.shift();
      }

      delete (times as any)._startTime;
    }
  }

  getEventAverageTime(eventName: string): number {
    const times = this.eventTimes.get(eventName);
    if (!times || times.length === 0) return 0;
    return times.reduce((a, b) => a + b, 0) / times.length;
  }

  // ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
  generateReport(): PerformanceReport {
    const metrics: PerformanceMetrics = {
      fps: this.scene.game.loop.actualFps,
      memory: this.getMemoryUsage(),
      sceneTransitionTime: 0,
      eventProcessingTime: 0,
      renderTime: 0,
      updateTime: 0,
    };

    const recommendations: string[] = [];

    // FPSåˆ†æ
    const avgFps = this.getAverageFps();
    if (avgFps < 30) {
      recommendations.push('FPSãŒ30æœªæº€ã§ã™ã€‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ã‚’æ¤œè¨ã—ã¦ãã ã•ã„');
    } else if (avgFps < 50) {
      recommendations.push('FPSãŒ50æœªæº€ã§ã™ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ã®ä½¿ç”¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„');
    }

    // ãƒ¡ãƒ¢ãƒªåˆ†æ
    const avgMemory = this.getAverageMemory();
    const memoryMB = avgMemory / 1024 / 1024;
    if (memoryMB > 200) {
      recommendations.push('ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒ200MBã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯å¯¾ç­–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„');
    }

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°åˆ†æ
    if (this.scene.children.length > 500) {
      recommendations.push('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ãŒ500ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ä¸è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰Šé™¤ã‚’æ¤œè¨ã—ã¦ãã ã•ã„');
    }

    return {
      timestamp: Date.now(),
      metrics,
      averages: {
        fps: avgFps,
        memory: avgMemory,
        sceneTransition: 0,
      },
      recommendations,
    };
  }

  // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
  logReport(): void {
    const report = this.generateReport();

    console.group('Performance Report');
    console.log('Timestamp:', new Date(report.timestamp).toLocaleString());
    console.log('Average FPS:', report.averages.fps.toFixed(1));
    console.log('Average Memory:', (report.averages.memory / 1024 / 1024).toFixed(1), 'MB');
    console.log('Object Count:', this.scene.children.length);

    if (report.recommendations.length > 0) {
      console.group('Recommendations');
      report.recommendations.forEach(r => console.warn(r));
      console.groupEnd();
    }

    console.groupEnd();
  }
}
```

### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ã‚¹ã‚¯ãƒªãƒ—ãƒˆ ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *è¨ˆæ¸¬æ‰‹é †*

**è¨ˆæ¸¬æ‰‹é †æ›¸**: `docs/tasks/atelier-guild-rank-phaser/performance-measurement.md`

```markdown
# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬æ‰‹é †

## è¨ˆæ¸¬ç’°å¢ƒ

- ãƒ–ãƒ©ã‚¦ã‚¶: Chrome (DevToolsã®Memory APIã‚’ä½¿ç”¨)
- ãƒ‡ãƒã‚¤ã‚¹: é–‹ç™ºãƒã‚·ãƒ³ + ä½ã‚¹ãƒšãƒƒã‚¯ãƒ†ã‚¹ãƒˆç’°å¢ƒ
- è¨ˆæ¸¬æ™‚é–“: å„ã‚·ãƒŠãƒªã‚ª5åˆ†

## è¨ˆæ¸¬ã‚·ãƒŠãƒªã‚ª

### ã‚·ãƒŠãƒªã‚ª1: èµ·å‹•ã€œã‚¿ã‚¤ãƒˆãƒ«

1. ã‚²ãƒ¼ãƒ ã‚’èµ·å‹•
2. BootSceneå®Œäº†ã¾ã§ã®æ™‚é–“ã‚’è¨ˆæ¸¬
3. TitleSceneã§ã®FPSã‚’è¨ˆæ¸¬

### ã‚·ãƒŠãƒªã‚ª2: 1ã‚¿ãƒ¼ãƒ³ã‚µã‚¤ã‚¯ãƒ«

1. æ–°è¦ã‚²ãƒ¼ãƒ é–‹å§‹
2. ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºã§ã®æ“ä½œ
3. æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã§ã‚«ãƒ¼ãƒ‰ä½¿ç”¨
4. èª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã§ã‚¢ã‚¤ãƒ†ãƒ ä½œæˆ
5. ç´å“ãƒ•ã‚§ãƒ¼ã‚ºã§ä¾é ¼å®Œäº†
6. å„ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»æ™‚é–“ã‚’è¨˜éŒ²

### ã‚·ãƒŠãƒªã‚ª3: é•·æ™‚é–“ãƒ—ãƒ¬ã‚¤

1. 10æ—¥åˆ†ã®ãƒ—ãƒ¬ã‚¤ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
2. ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¨ç§»ã‚’è¨˜éŒ²
3. FPSã®æ¨ç§»ã‚’è¨˜éŒ²

### ã‚·ãƒŠãƒªã‚ª4: UIè² è·ãƒ†ã‚¹ãƒˆ

1. ã‚·ãƒ§ãƒƒãƒ—ã§å¤§é‡è³¼å…¥
2. ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«100å€‹ä»¥ä¸Šã®ã‚¢ã‚¤ãƒ†ãƒ 
3. ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã®å‹•ä½œç¢ºèª

## è¨ˆæ¸¬çµæœãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

| é …ç›® | ç›®æ¨™å€¤ | è¨ˆæ¸¬å€¤ | åˆå¦ |
|------|--------|--------|------|
| å¹³å‡FPS | â‰¥55 | | |
| æœ€ä½FPS | â‰¥30 | | |
| ãƒ¡ãƒ¢ãƒªï¼ˆåˆæœŸï¼‰ | â‰¤100MB | | |
| ãƒ¡ãƒ¢ãƒªï¼ˆ10æ—¥å¾Œï¼‰ | â‰¤150MB | | |
| Bootæ™‚é–“ | â‰¤3000ms | | |
| ã‚·ãƒ¼ãƒ³é·ç§» | â‰¤500ms | | |

## ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š

è¨ˆæ¸¬çµæœã‹ã‚‰ä»¥ä¸‹ã‚’ç‰¹å®š:

1. CPUè² è·ã®é«˜ã„å‡¦ç†
2. ãƒ¡ãƒ¢ãƒªã‚’å¤šãæ¶ˆè²»ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
3. é…å»¶ã®åŸå› ã¨ãªã‚‹I/Oæ“ä½œ
```

---

## å®Ÿè£…æ‰‹é †

1. `/direct-setup` - è¨ˆæ¸¬ãƒ„ãƒ¼ãƒ«å®Ÿè£…
2. `/direct-verify` - è¨ˆæ¸¬å®Ÿè¡Œãƒ»ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ

---

## è¨ˆæ¸¬é …ç›®

| é …ç›® | ç›®æ¨™å€¤ |
|------|--------|
| å¹³å‡FPS | 55ä»¥ä¸Š |
| æœ€ä½FPS | 30ä»¥ä¸Š |
| ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ï¼ˆåˆæœŸï¼‰ | 100MBä»¥ä¸‹ |
| ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ï¼ˆé•·æ™‚é–“ï¼‰ | 150MBä»¥ä¸‹ |
| Bootæ™‚é–“ | 3ç§’ä»¥ä¸‹ |
| ã‚·ãƒ¼ãƒ³é·ç§»æ™‚é–“ | 500msä»¥ä¸‹ |

---

## æ³¨æ„äº‹é …

- Chrome DevToolsã®Performanceã‚¿ãƒ–ã‚’æ´»ç”¨
- è¤‡æ•°å›è¨ˆæ¸¬ã—ã¦å¹³å‡ã‚’å–ã‚‹
- ä½ã‚¹ãƒšãƒƒã‚¯ç’°å¢ƒã§ã‚‚ãƒ†ã‚¹ãƒˆ

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 2é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 2é …ç›® (100%)

**å“è³ªè©•ä¾¡**: ä½å“è³ªï¼ˆå®Ÿè£…æ™‚ã«èª¿æ•´è¦ãƒ»Phaserå›ºæœ‰ï¼‰

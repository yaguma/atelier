# TASK-0253: GameFlowManager Phaseré€£æºå®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0253
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4 - ã‚µãƒ–ã‚·ãƒ¼ãƒ³ãƒ»Applicationå±¤ä¿®æ­£
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ **: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

GameFlowManagerã‚’Phaserç’°å¢ƒã«é©å¿œã•ã›ã‚‹ã€‚ã‚·ãƒ¼ãƒ³é·ç§»ã¨ã®é€£æºã¨ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0170, TASK-0252
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0254

## å®Œäº†æ¡ä»¶

- [ ] GameFlowManagerãŒã‚·ãƒ¼ãƒ³é·ç§»ã¨é€£æºã™ã‚‹
- [ ] ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡ŒãŒUIå±¤ã¨åŒæœŸã™ã‚‹
- [ ] ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†ãŒæ­£ã—ãå‹•ä½œã™ã‚‹
- [ ] ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢åˆ¤å®šãŒæ©Ÿèƒ½ã™ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. PhaserGameFlowManagerå®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ãƒ•ãƒ­ãƒ¼ç®¡ç†*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/flow/PhaserGameFlowManager.ts`

```typescript
import { EventBus } from '../core/EventBus';
import { SceneManager } from '../core/SceneManager';
import { PhaserStateManager } from '../state/PhaserStateManager';
import { StateSelectors } from '../state/StateSelectors';
import { SceneKeys } from '../config/SceneKeys';

export type PhaseType = 'quest-accept' | 'gathering' | 'alchemy' | 'delivery';

export interface PhaseConfig {
  type: PhaseType;
  name: string;
  canSkip: boolean;
}

export interface DayEndResult {
  newDay: number;
  summary: {
    questsCompleted: number;
    itemsCrafted: number;
    goldEarned: number;
  };
  isGameOver: boolean;
  gameOverReason?: string;
  isGameClear: boolean;
}

/**
 * Phaserç’°å¢ƒå‘ã‘ã®ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹
 */
export class PhaserGameFlowManager {
  private eventBus: EventBus;
  private sceneManager: SceneManager;
  private stateManager: PhaserStateManager;
  private selectors: StateSelectors;

  private phases: PhaseConfig[] = [
    { type: 'quest-accept', name: 'ä¾é ¼å—æ³¨', canSkip: true },
    { type: 'gathering', name: 'æ¡å–', canSkip: true },
    { type: 'alchemy', name: 'èª¿åˆ', canSkip: true },
    { type: 'delivery', name: 'ç´å“', canSkip: true },
  ];

  private dayStats = {
    questsCompleted: 0,
    itemsCrafted: 0,
    goldEarned: 0,
  };

  constructor(
    eventBus: EventBus,
    sceneManager: SceneManager,
    stateManager: PhaserStateManager
  ) {
    this.eventBus = eventBus;
    this.sceneManager = sceneManager;
    this.stateManager = stateManager;
    this.selectors = new StateSelectors(stateManager);

    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    // UIã‹ã‚‰ã®ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†é€šçŸ¥
    this.eventBus.on('ui:phase:complete', (data: { phase: PhaseType }) => {
      this.advancePhase();
    });

    // UIã‹ã‚‰ã®ã‚¹ã‚­ãƒƒãƒ—è¦æ±‚
    this.eventBus.on('ui:phase:skip:requested', (data: { phase: PhaseType }) => {
      this.skipPhase(data.phase);
    });
  }

  // ===== ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç† =====

  getCurrentPhase(): PhaseType {
    return this.stateManager.getProgress().currentPhase as PhaseType;
  }

  getNextPhase(): PhaseType | null {
    const currentPhase = this.getCurrentPhase();
    const currentIndex = this.phases.findIndex(p => p.type === currentPhase);

    if (currentIndex < this.phases.length - 1) {
      return this.phases[currentIndex + 1].type;
    }

    return null;
  }

  async advancePhase(): Promise<void> {
    const nextPhase = this.getNextPhase();

    if (nextPhase) {
      await this.transitionToPhase(nextPhase);
    } else {
      // å…¨ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº† â†’ ã‚¿ãƒ¼ãƒ³çµ‚äº†
      await this.endTurn();
    }
  }

  async skipPhase(phase: PhaseType): Promise<void> {
    const phaseConfig = this.phases.find(p => p.type === phase);

    if (!phaseConfig?.canSkip) {
      this.eventBus.emit('app:error:occurred', {
        message: 'ã“ã®ãƒ•ã‚§ãƒ¼ã‚ºã¯ã‚¹ã‚­ãƒƒãƒ—ã§ãã¾ã›ã‚“',
      });
      return;
    }

    await this.advancePhase();
  }

  async transitionToPhase(phase: PhaseType): Promise<void> {
    const previousPhase = this.getCurrentPhase();

    // çŠ¶æ…‹æ›´æ–°
    this.stateManager.updateProgress({
      currentPhase: phase,
    });

    // ãƒ•ã‚§ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿æº–å‚™
    const phaseData = await this.preparePhaseData(phase);

    // UIã«é€šçŸ¥
    this.eventBus.emit('app:phase:changed', {
      phase,
      previousPhase,
    });

    this.eventBus.emit('app:phase:data:loaded', phaseData);
  }

  private async preparePhaseData(phase: PhaseType): Promise<any> {
    const state = this.stateManager.getState();

    switch (phase) {
      case 'quest-accept':
        return {
          availableQuests: state.quests.available,
          acceptedQuests: state.quests.accepted,
        };

      case 'gathering':
        return {
          ap: state.player.ap,
          gatheringCards: state.deck.hand.filter((c: any) => c.type === 'gathering'),
        };

      case 'alchemy':
        return {
          recipeCards: state.deck.hand.filter((c: any) => c.type === 'recipe'),
          materials: state.inventory.materials,
        };

      case 'delivery':
        return {
          acceptedQuests: state.quests.accepted,
          inventory: [
            ...state.inventory.materials,
            ...state.inventory.craftedItems,
          ],
        };

      default:
        return {};
    }
  }

  // ===== ã‚¿ãƒ¼ãƒ³ç®¡ç† =====

  async endTurn(): Promise<void> {
    // ã‚¿ãƒ¼ãƒ³çµ‚äº†ã‚µãƒãƒªãƒ¼
    const summary = { ...this.dayStats };

    // æ—¥æ•°ã‚’é€²ã‚ã‚‹
    const progress = this.stateManager.getProgress();
    const newDay = progress.currentDay + 1;

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢åˆ¤å®š
    const gameResult = this.checkGameResult(newDay);

    if (gameResult.isGameOver) {
      await this.handleGameOver(gameResult.reason!);
      return;
    }

    if (gameResult.isGameClear) {
      await this.handleGameClear();
      return;
    }

    // çŠ¶æ…‹æ›´æ–°
    this.stateManager.updateProgress({
      currentDay: newDay,
      currentPhase: 'quest-accept',
    });

    // APå›å¾©
    const player = this.stateManager.getPlayerData();
    this.stateManager.updatePlayer({
      ap: { current: player.ap.max, max: player.ap.max },
    });

    // æ–°ã—ã„ä¾é ¼ã‚’ç”Ÿæˆï¼ˆå°†æ¥çš„ã«ã¯UseCaseã‹ã‚‰ï¼‰
    await this.generateNewQuests();

    // æ‰‹æœ­è£œå……
    await this.refillHand();

    // çµ±è¨ˆãƒªã‚»ãƒƒãƒˆ
    this.dayStats = {
      questsCompleted: 0,
      itemsCrafted: 0,
      goldEarned: 0,
    };

    // UIã«é€šçŸ¥
    this.eventBus.emit('app:day:ended', {
      newDay,
      summary,
    });

    // æ–°æ—¥ã®ãƒ•ã‚§ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿
    await this.transitionToPhase('quest-accept');
  }

  private checkGameResult(day: number): { isGameOver: boolean; reason?: string; isGameClear: boolean } {
    const progress = this.stateManager.getProgress();
    const player = this.stateManager.getPlayerData();

    // æ—¥æ•°ã‚ªãƒ¼ãƒãƒ¼
    if (day > progress.maxDay) {
      return {
        isGameOver: true,
        reason: `æœŸé™åˆ‡ã‚Œ - ${progress.maxDay}æ—¥ä»¥å†…ã«Sç´šã«åˆ°é”ã§ãã¾ã›ã‚“ã§ã—ãŸ`,
        isGameClear: false,
      };
    }

    // ã‚´ãƒ¼ãƒ«ãƒ‰æ¯æ¸‡
    if (player.gold < 0) {
      return {
        isGameOver: true,
        reason: 'æ‰€æŒé‡‘ãŒ0ã«ãªã‚Šã¾ã—ãŸ',
        isGameClear: false,
      };
    }

    // Sç´šåˆ°é”
    if (player.rank === 'S') {
      return {
        isGameOver: false,
        isGameClear: true,
      };
    }

    return {
      isGameOver: false,
      isGameClear: false,
    };
  }

  private async handleGameOver(reason: string): Promise<void> {
    const state = this.stateManager.getState();

    const stats = {
      finalDay: state.progress.currentDay,
      finalRank: state.player.rank,
      totalQuests: state.quests.completed.length,
      totalAlchemy: this.dayStats.itemsCrafted, // TODO: ç´¯è¨ˆã‚’è¿½è·¡
    };

    this.eventBus.emit('app:game:over', {
      reason,
      stats,
    });

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³ã¸
    this.sceneManager.switchTo(SceneKeys.GAME_OVER, {
      reason,
      ...stats,
    });
  }

  private async handleGameClear(): Promise<void> {
    const state = this.stateManager.getState();

    const stats = {
      clearDay: state.progress.currentDay,
      finalRank: 'S',
      totalQuests: state.quests.completed.length,
      totalAlchemy: this.dayStats.itemsCrafted,
      totalGold: state.player.gold,
      rareItems: [], // TODO: ãƒ¬ã‚¢ã‚¢ã‚¤ãƒ†ãƒ è¿½è·¡
      playTime: 0, // TODO: ãƒ—ãƒ¬ã‚¤æ™‚é–“è¿½è·¡
    };

    this.eventBus.emit('app:game:clear', {
      stats,
    });

    // ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³ã¸
    this.sceneManager.switchTo(SceneKeys.GAME_CLEAR, stats);
  }

  private async generateNewQuests(): Promise<void> {
    // ç°¡æ˜“çš„ãªä¾é ¼ç”Ÿæˆï¼ˆå°†æ¥çš„ã«ã¯UseCaseã‹ã‚‰ï¼‰
    const quests = this.stateManager.getQuests();
    // TODO: QuestGeneratorã¨é€£æº
  }

  private async refillHand(): Promise<void> {
    const deck = this.stateManager.getDeck();
    const handSize = deck.hand.length;
    const maxHandSize = 5;

    if (handSize < maxHandSize) {
      const drawCount = maxHandSize - handSize;
      // TODO: DeckUseCaseã¨é€£æºã—ã¦ãƒ‰ãƒ­ãƒ¼
    }
  }

  // ===== çµ±è¨ˆæ›´æ–° =====

  recordQuestComplete(): void {
    this.dayStats.questsCompleted++;
  }

  recordItemCrafted(): void {
    this.dayStats.itemsCrafted++;
  }

  recordGoldEarned(amount: number): void {
    this.dayStats.goldEarned += amount;
  }

  // ===== ã‚²ãƒ¼ãƒ é–‹å§‹ =====

  async startNewGame(): Promise<void> {
    // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
    this.stateManager.reset();

    // åˆæœŸãƒ‡ãƒƒã‚­è¨­å®š
    // TODO: DeckUseCaseã¨é€£æº

    // åˆæœŸä¾é ¼è¨­å®š
    // TODO: QuestGeneratorã¨é€£æº

    // ãƒ¡ã‚¤ãƒ³ã‚·ãƒ¼ãƒ³ã¸
    this.sceneManager.switchTo(SceneKeys.MAIN);

    // æœ€åˆã®ãƒ•ã‚§ãƒ¼ã‚ºã¸
    await this.transitionToPhase('quest-accept');
  }

  async loadGame(saveData: string): Promise<void> {
    this.stateManager.deserialize(saveData);

    // ãƒ¡ã‚¤ãƒ³ã‚·ãƒ¼ãƒ³ã¸
    this.sceneManager.switchTo(SceneKeys.MAIN);

    // ä¿å­˜æ™‚ã®ãƒ•ã‚§ãƒ¼ã‚ºã¸
    const currentPhase = this.getCurrentPhase();
    await this.transitionToPhase(currentPhase);
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ ğŸŸ¡

**Given**: quest-acceptãƒ•ã‚§ãƒ¼ã‚ºã«ã„ã‚‹
**When**: advancePhaseã‚’å‘¼ã¶
**Then**: gatheringãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»ã™ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ã‚¿ãƒ¼ãƒ³çµ‚äº† ğŸŸ¡

**Given**: deliveryãƒ•ã‚§ãƒ¼ã‚ºã«ã„ã‚‹
**When**: advancePhaseã‚’å‘¼ã¶
**Then**: æ—¥æ•°ãŒé€²ã¿ã€quest-acceptã«æˆ»ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š ğŸŸ¡

**Given**: 30æ—¥ç›®
**When**: ã‚¿ãƒ¼ãƒ³çµ‚äº†ã™ã‚‹
**Then**: ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šã•ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0253` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚·ãƒ¼ãƒ³é·ç§»ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°
- çŠ¶æ…‹æ›´æ–°ã®é †åº
- éåŒæœŸå‡¦ç†ã®å®Œäº†å¾…ã¡

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 1é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ªï¼ˆå®Ÿè£…æ™‚ã«èª¿æ•´è¦ï¼‰

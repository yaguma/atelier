# TASK-0237: MainSceneæ‰‹æœ­ãƒ»ãƒ‡ãƒƒã‚­çµ±åˆ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0237
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 3 - ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠãƒ»ãƒ¡ã‚¤ãƒ³ç”»é¢å®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

MainSceneã«æ‰‹æœ­è¡¨ç¤ºï¼ˆHandContainerï¼‰ã¨ãƒ‡ãƒƒã‚­è¡¨ç¤ºï¼ˆDeckViewï¼‰ã‚’çµ±åˆã™ã‚‹ã€‚ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã¨é€£æºã—ãŸã‚«ãƒ¼ãƒ‰æ“ä½œã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0236, TASK-0195, TASK-0210
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0238

## å®Œäº†æ¡ä»¶

- [ ] æ‰‹æœ­ãŒãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ã«è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒ‡ãƒƒã‚­ãŒã‚µã‚¤ãƒ‰ã‚¨ãƒªã‚¢ã«è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ã‚«ãƒ¼ãƒ‰é¸æŠãŒãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã«é€£æºã™ã‚‹
- [ ] ã‚«ãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒ¼ãƒ»ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹•ä½œã™ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. æ‰‹æœ­ãƒ»ãƒ‡ãƒƒã‚­ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¿½åŠ  ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­è¨ˆ*

```typescript
// MainSceneConstantsã«è¿½åŠ 

export const MainSceneLayout = {
  // ... æ—¢å­˜ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

  // æ‰‹æœ­ã‚¨ãƒªã‚¢ï¼ˆãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ä¸‹éƒ¨ï¼‰
  HAND_AREA: {
    X: 50,
    Y: 580,
    WIDTH: 700,
    HEIGHT: 180,
  },

  // ãƒ‡ãƒƒã‚­è¡¨ç¤ºï¼ˆã‚µã‚¤ãƒ‰ãƒãƒ¼å†…ï¼‰
  DECK_AREA: {
    X: 850,
    Y: 550,
    WIDTH: 150,
    HEIGHT: 100,
  },
} as const;
```

### 2. MainSceneæ‰‹æœ­çµ±åˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *æ‰‹æœ­çµ±åˆ*

```typescript
// MainSceneã«è¿½åŠ 

import { HandContainer } from '../ui/hand/HandContainer';
import { DeckView } from '../ui/common/DeckView';
import { Card } from '../../../domain/card/Card';

// ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¿½åŠ 
private handContainer!: HandContainer;
private deckView!: DeckView;
private currentHand: Card[] = [];
private deckCards: Card[] = [];

private createHandAndDeck(): void {
  const { HAND_AREA, DECK_AREA } = MainSceneLayout;

  // æ‰‹æœ­ã‚³ãƒ³ãƒ†ãƒŠ
  this.handContainer = new HandContainer(this, {
    x: HAND_AREA.X,
    y: HAND_AREA.Y,
    maxCards: 5,
    cardWidth: 100,
    cardHeight: 150,
    layout: 'horizontal',
    onCardSelect: (card) => this.handleHandCardSelect(card),
    onCardDeselect: (card) => this.handleHandCardDeselect(card),
  });

  // ãƒ‡ãƒƒã‚­ãƒ“ãƒ¥ãƒ¼
  this.deckView = new DeckView(this, {
    x: DECK_AREA.X,
    y: DECK_AREA.Y,
    width: DECK_AREA.WIDTH,
    height: DECK_AREA.HEIGHT,
  });
}

// æ‰‹æœ­è¨­å®š
setHand(cards: Card[]): void {
  this.currentHand = cards;
  this.handContainer.setCards(cards);
}

// ãƒ‡ãƒƒã‚­è¨­å®š
setDeck(cards: Card[], discardCount: number = 0): void {
  this.deckCards = cards;
  this.deckView.setDeckCount(cards.length);
  this.deckView.setDiscardCount(discardCount);
}

// ã‚«ãƒ¼ãƒ‰é¸æŠãƒãƒ³ãƒ‰ãƒ©
private handleHandCardSelect(card: Card): void {
  // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã«ã‚«ãƒ¼ãƒ‰é¸æŠã‚’é€šçŸ¥
  this.notifyPhaseContainerCardSelect(card);

  this.eventBus.emit('hand:card:selected', { card });
}

private handleHandCardDeselect(card: Card): void {
  this.eventBus.emit('hand:card:deselected', { card });
}

private notifyPhaseContainerCardSelect(card: Card): void {
  if (!this.activePhase) return;

  const info = this.phaseContainers.get(this.activePhase);
  if (!info || !info.container) return;

  // ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã«ã‚«ãƒ¼ãƒ‰ã‚’æ¸¡ã™
  switch (this.activePhase) {
    case 'gathering':
      const gatheringContainer = info.container as GatheringContainer;
      if (card.type === 'gathering') {
        gatheringContainer.setGatheringCard(card as GatheringCard);
      }
      break;

    case 'alchemy':
      const alchemyContainer = info.container as AlchemyContainer;
      if (card.type === 'recipe') {
        alchemyContainer.selectRecipe(card as RecipeCard);
      }
      break;
  }
}
```

### 3. ã‚«ãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *è¦–è¦šåŠ¹æœ*

```typescript
// MainSceneã«è¿½åŠ 

async drawCards(count: number): Promise<void> {
  if (this.deckCards.length < count) {
    // ãƒ‡ãƒƒã‚­ä¸è¶³æ™‚ã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    await this.shuffleDiscardIntoDeck();
  }

  // ãƒ‰ãƒ­ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  const drawnCards: Card[] = [];
  for (let i = 0; i < count && this.deckCards.length > 0; i++) {
    const card = this.deckCards.shift()!;
    drawnCards.push(card);

    // ãƒ‡ãƒƒã‚­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ãŒé£›ã¶ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    await this.playDrawAnimation(card, i);
  }

  // æ‰‹æœ­ã«è¿½åŠ 
  this.currentHand.push(...drawnCards);
  this.handContainer.setCards(this.currentHand);

  // ãƒ‡ãƒƒã‚­è¡¨ç¤ºæ›´æ–°
  this.deckView.setDeckCount(this.deckCards.length);

  this.eventBus.emit('cards:drawn', { cards: drawnCards });
}

private async playDrawAnimation(card: Card, index: number): Promise<void> {
  return new Promise((resolve) => {
    const { DECK_AREA, HAND_AREA } = MainSceneLayout;

    // ä»®ã®ã‚«ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    const tempCard = this.add.graphics();
    tempCard.fillStyle(0x4a4a8a, 1);
    tempCard.fillRoundedRect(0, 0, 80, 120, 8);
    tempCard.x = DECK_AREA.X + 30;
    tempCard.y = DECK_AREA.Y + 20;

    // æ‰‹æœ­ä½ç½®ã¸ç§»å‹•
    const targetX = HAND_AREA.X + 100 + (this.currentHand.length + index) * 110;
    const targetY = HAND_AREA.Y + 75;

    this.tweens.add({
      targets: tempCard,
      x: targetX,
      y: targetY,
      duration: 300,
      delay: index * 100,
      ease: 'Power2.easeOut',
      onComplete: () => {
        tempCard.destroy();
        resolve();
      },
    });
  });
}

async shuffleDiscardIntoDeck(): Promise<void> {
  // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  await this.deckView.playShuffleAnimation();

  // æ¨ã¦æœ­ã‚’ãƒ‡ãƒƒã‚­ã«æˆ»ã™ï¼ˆãƒ­ã‚¸ãƒƒã‚¯ã¯Applicationå±¤ã§ç®¡ç†ï¼‰
  this.eventBus.emit('deck:shuffle:requested', {});
}

// ãƒ‡ãƒƒã‚­ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒ‰ãƒ­ãƒ¼
setupDeckInteraction(): void {
  this.deckView.onDeckClick(() => {
    // APæ¶ˆè²»ç¢ºèªãªã©ã‚’çµŒã¦ãƒ‰ãƒ­ãƒ¼
    this.eventBus.emit('deck:draw:requested', { count: 1 });
  });
}
```

### 4. ãƒ•ã‚§ãƒ¼ã‚ºé€£æº ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *é€£æºå‡¦ç†*

```typescript
// MainSceneã«è¿½åŠ 

// ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»æ™‚ã®æ‰‹æœ­å‡¦ç†
private async onPhaseEnter(phase: PhaseType): Promise<void> {
  // ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®æ‰‹æœ­è¡¨ç¤ºåˆ¶å¾¡
  switch (phase) {
    case 'quest-accept':
      // ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºã§ã¯æ‰‹æœ­éè¡¨ç¤º
      this.handContainer.setVisible(false);
      break;

    case 'gathering':
      // æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã§ã¯æ¡å–åœ°ã‚«ãƒ¼ãƒ‰ã®ã¿è¡¨ç¤º
      this.handContainer.setVisible(true);
      this.handContainer.setFilter((card) => card.type === 'gathering');
      break;

    case 'alchemy':
      // èª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã§ã¯ãƒ¬ã‚·ãƒ”ã‚«ãƒ¼ãƒ‰ã®ã¿è¡¨ç¤º
      this.handContainer.setVisible(true);
      this.handContainer.setFilter((card) => card.type === 'recipe');
      break;

    case 'delivery':
      // ç´å“ãƒ•ã‚§ãƒ¼ã‚ºã§ã¯æ‰‹æœ­éè¡¨ç¤º
      this.handContainer.setVisible(false);
      break;
  }
}

// ã‚«ãƒ¼ãƒ‰ä½¿ç”¨æ™‚ã®å‡¦ç†
async useCard(card: Card): Promise<void> {
  // æ‰‹æœ­ã‹ã‚‰å‰Šé™¤
  this.currentHand = this.currentHand.filter(c => c !== card);
  this.handContainer.setCards(this.currentHand);

  // ä½¿ç”¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  await this.playCardUseAnimation(card);

  // æ¨ã¦æœ­ã«è¿½åŠ 
  this.deckView.incrementDiscardCount();

  this.eventBus.emit('card:used', { card });
}

private async playCardUseAnimation(card: Card): Promise<void> {
  return new Promise((resolve) => {
    // ã‚«ãƒ¼ãƒ‰ãŒæ¶ˆãˆã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    const targetIndex = this.currentHand.indexOf(card);
    this.handContainer.animateCardRemove(targetIndex, () => {
      resolve();
    });
  });
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: æ‰‹æœ­è¡¨ç¤º ğŸ”µ

**Given**: MainSceneãŒèµ·å‹•ã—ã¦ã„ã‚‹
**When**: setHand(cards)ã‚’å‘¼ã¶
**Then**: æ‰‹æœ­ã‚¨ãƒªã‚¢ã«ã‚«ãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ã‚«ãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒ¼ ğŸ”µ

**Given**: ãƒ‡ãƒƒã‚­ã«ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹
**When**: drawCards(2)ã‚’å‘¼ã¶
**Then**: 2æšã®ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è¿½åŠ ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: ãƒ•ã‚§ãƒ¼ã‚ºé€£æº ğŸ”µ

**Given**: æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»
**When**: æ¡å–åœ°ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠ
**Then**: GatheringContainerã«ã‚«ãƒ¼ãƒ‰ãŒæ¸¡ã•ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0237` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- HandContainerã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½
- ãƒ‰ãƒ­ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°
- ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã¨ã®åŒæ–¹å‘é€£æº

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 4é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 4é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

# TASK-0196: HandContainerè¡¨ç¤ºå®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0196
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 2 - åŸºæœ¬ã‚·ãƒ¼ãƒ³ãƒ»å…±é€šUIå®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬ã«åŸºã¥ã*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

æ‰‹æœ­ã‚³ãƒ³ãƒ†ãƒŠã®è¡¨ç¤ºæ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚ã‚«ãƒ¼ãƒ‰ã®è¿½åŠ ãƒ»å‰Šé™¤ãƒ»ä¸¦ã¹æ›¿ãˆã‚’è¦–è¦šçš„ã«è¡¨ç¾ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0195
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0197

## å®Œäº†æ¡ä»¶

- [ ] HandContainerã‚¯ãƒ©ã‚¹ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚«ãƒ¼ãƒ‰ã®è¿½åŠ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚«ãƒ¼ãƒ‰ã®å‰Šé™¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹•ä½œã™ã‚‹
- [ ] ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåˆ‡ã‚Šæ›¿ãˆï¼ˆæ°´å¹³/æ‰‡å½¢ï¼‰ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚«ãƒ¼ãƒ‰æšæ•°ã«å¿œã˜ãŸè‡ªå‹•èª¿æ•´ãŒè¡Œã‚ã‚Œã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. HandContainerå®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *TASK-0195ã®è¨­è¨ˆã«åŸºã¥ã*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/hand/HandContainer.ts`

```typescript
import Phaser from 'phaser';
import { Card } from '../../../../domain/card/Card';
import { IHandContainer, HandContainerOptions } from './IHandContainer';
import { ICardView } from '../card/ICardView';
import { HandLayout, HandLayoutType } from './HandConstants';
import { calculateCardPositions, CardPosition } from './HandLayoutUtils';
import { createCardView } from '../card/CardViewFactory';

export class HandContainer implements IHandContainer {
  public readonly container: Phaser.GameObjects.Container;

  private scene: Phaser.Scene;
  private cards: Card[] = [];
  private cardViews: ICardView[] = [];
  private selectedIndex: number = -1;
  private layoutType: HandLayoutType;
  private selectable: boolean = true;
  private centerX: number;
  private centerY: number;
  private onCardSelect?: (card: Card, index: number) => void;
  private onCardDeselect?: (card: Card, index: number) => void;

  constructor(scene: Phaser.Scene, options: HandContainerOptions = {}) {
    this.scene = scene;
    this.centerX = options.x ?? HandLayout.X;
    this.centerY = options.y ?? HandLayout.Y;
    this.layoutType = options.layoutType ?? 'horizontal';
    this.onCardSelect = options.onCardSelect;
    this.onCardDeselect = options.onCardDeselect;

    this.container = scene.add.container(0, 0);
    this.container.setDepth(100);
  }

  setCards(cards: Card[]): void {
    // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ãƒ“ãƒ¥ãƒ¼ã‚’ç ´æ£„
    this.clearCardViews();

    this.cards = [...cards];
    this.selectedIndex = -1;

    // ã‚«ãƒ¼ãƒ‰ãƒ“ãƒ¥ãƒ¼ã‚’ç”Ÿæˆ
    this.cards.forEach((card, index) => {
      const cardView = this.createCardViewForHand(card, index);
      this.cardViews.push(cardView);
      this.container.add(cardView.container);
    });

    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆé©ç”¨
    this.applyLayout(false);
  }

  addCard(card: Card, animate: boolean = true): void {
    this.cards.push(card);
    const index = this.cards.length - 1;
    const cardView = this.createCardViewForHand(card, index);
    this.cardViews.push(cardView);
    this.container.add(cardView.container);

    if (animate) {
      // ç”»é¢å¤–ã‹ã‚‰ç™»å ´
      cardView.setPosition(this.centerX + 400, this.centerY);
      cardView.setAlpha(0);
      this.applyLayout(true);
    } else {
      this.applyLayout(false);
    }
  }

  removeCard(cardOrIndex: Card | number, animate: boolean = true): void {
    const index = typeof cardOrIndex === 'number'
      ? cardOrIndex
      : this.cards.indexOf(cardOrIndex);

    if (index < 0 || index >= this.cards.length) return;

    const cardView = this.cardViews[index];

    if (animate) {
      this.scene.tweens.add({
        targets: cardView.container,
        y: cardView.container.y - 100,
        alpha: 0,
        duration: HandLayout.CARD_MOVE_DURATION,
        ease: 'Power2',
        onComplete: () => {
          this.removeCardAtIndex(index);
          this.applyLayout(true);
        },
      });
    } else {
      this.removeCardAtIndex(index);
      this.applyLayout(false);
    }
  }

  getCards(): Card[] {
    return [...this.cards];
  }

  getCardCount(): number {
    return this.cards.length;
  }

  getSelectedCard(): Card | null {
    if (this.selectedIndex >= 0 && this.selectedIndex < this.cards.length) {
      return this.cards[this.selectedIndex];
    }
    return null;
  }

  getSelectedIndex(): number {
    return this.selectedIndex;
  }

  selectCard(cardOrIndex: Card | number): void {
    const index = typeof cardOrIndex === 'number'
      ? cardOrIndex
      : this.cards.indexOf(cardOrIndex);

    if (!this.selectable || index < 0 || index >= this.cards.length) return;

    // æ—¢å­˜ã®é¸æŠã‚’è§£é™¤
    if (this.selectedIndex >= 0 && this.selectedIndex !== index) {
      this.cardViews[this.selectedIndex]?.setSelected(false);
    }

    this.selectedIndex = index;
    this.cardViews[index]?.setSelected(true);

    if (this.onCardSelect) {
      this.onCardSelect(this.cards[index], index);
    }
  }

  deselectCard(): void {
    if (this.selectedIndex >= 0 && this.selectedIndex < this.cardViews.length) {
      const card = this.cards[this.selectedIndex];
      const index = this.selectedIndex;

      this.cardViews[this.selectedIndex].setSelected(false);
      this.selectedIndex = -1;

      if (this.onCardDeselect) {
        this.onCardDeselect(card, index);
      }
    }
  }

  setSelectable(selectable: boolean): void {
    this.selectable = selectable;
    this.cardViews.forEach(cv => cv.setInteractive(selectable));
  }

  setLayoutType(type: HandLayoutType): void {
    this.layoutType = type;
    this.applyLayout(true);
  }

  getLayoutType(): HandLayoutType {
    return this.layoutType;
  }

  refresh(): void {
    this.applyLayout(false);
  }

  setVisible(visible: boolean): void {
    this.container.setVisible(visible);
  }

  setPosition(x: number, y: number): void {
    this.centerX = x;
    this.centerY = y;
    this.applyLayout(false);
  }

  destroy(): void {
    this.clearCardViews();
    this.container.destroy();
  }

  private createCardViewForHand(card: Card, index: number): ICardView {
    const cardView = createCardView(this.scene, {
      card,
      x: this.centerX,
      y: this.centerY,
      size: 'STANDARD',
      state: 'normal',
      interactive: this.selectable,
      onClick: () => this.handleCardClick(index),
      onHover: (_, isHovering) => this.handleCardHover(index, isHovering),
    });
    return cardView;
  }

  private handleCardClick(index: number): void {
    if (!this.selectable) return;

    if (this.selectedIndex === index) {
      // æ—¢ã«é¸æŠä¸­ã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ é¸æŠè§£é™¤
      this.deselectCard();
    } else {
      this.selectCard(index);
    }
  }

  private handleCardHover(index: number, isHovering: boolean): void {
    if (!this.selectable || this.selectedIndex === index) return;

    const cardView = this.cardViews[index];
    if (!cardView) return;

    const positions = calculateCardPositions(
      this.cards.length,
      this.layoutType,
      this.centerX,
      this.centerY
    );
    const pos = positions[index];

    if (isHovering) {
      // ãƒ›ãƒãƒ¼æ™‚ã«å°‘ã—ä¸Šã«ç§»å‹•
      this.scene.tweens.add({
        targets: cardView.container,
        y: pos.y + HandLayout.CARD_HOVER_OFFSET,
        duration: 100,
        ease: 'Power2',
      });
    } else {
      this.scene.tweens.add({
        targets: cardView.container,
        y: pos.y,
        duration: 100,
        ease: 'Power2',
      });
    }
  }

  private applyLayout(animate: boolean): void {
    const positions = calculateCardPositions(
      this.cards.length,
      this.layoutType,
      this.centerX,
      this.centerY
    );

    this.cardViews.forEach((cardView, index) => {
      const pos = positions[index];
      if (!pos) return;

      if (animate) {
        this.scene.tweens.add({
          targets: cardView.container,
          x: pos.x,
          y: pos.y,
          rotation: pos.rotation,
          alpha: 1,
          duration: HandLayout.CARD_MOVE_DURATION,
          ease: 'Power2',
        });
      } else {
        cardView.setPosition(pos.x, pos.y);
        cardView.container.setRotation(pos.rotation);
        cardView.setAlpha(1);
      }

      cardView.container.setDepth(100 + pos.depth);
    });
  }

  private removeCardAtIndex(index: number): void {
    const cardView = this.cardViews[index];
    cardView.destroy();

    this.cards.splice(index, 1);
    this.cardViews.splice(index, 1);

    // é¸æŠã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®èª¿æ•´
    if (this.selectedIndex === index) {
      this.selectedIndex = -1;
    } else if (this.selectedIndex > index) {
      this.selectedIndex--;
    }
  }

  private clearCardViews(): void {
    this.cardViews.forEach(cv => cv.destroy());
    this.cardViews = [];
    this.cards = [];
    this.selectedIndex = -1;
  }
}
```

### 2. CardViewFactoryå®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ã‚«ãƒ¼ãƒ‰ç¨®åˆ¥åˆ¤å®š*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/card/CardViewFactory.ts`

```typescript
import Phaser from 'phaser';
import { Card } from '../../../../domain/card/Card';
import { GatheringCard } from '../../../../domain/card/GatheringCard';
import { RecipeCard } from '../../../../domain/card/RecipeCard';
import { EnhancementCard } from '../../../../domain/card/EnhancementCard';
import { ICardView, CardViewOptions } from './ICardView';
import { GatheringCardView } from './GatheringCardView';
import { RecipeCardView } from './RecipeCardView';
import { EnhancementCardView } from './EnhancementCardView';

export const createCardView = (
  scene: Phaser.Scene,
  options: CardViewOptions
): ICardView => {
  const { card } = options;

  if (card instanceof GatheringCard) {
    return new GatheringCardView(scene, options);
  } else if (card instanceof RecipeCard) {
    return new RecipeCardView(scene, options);
  } else if (card instanceof EnhancementCard) {
    return new EnhancementCardView(scene, options);
  }

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ¡å–åœ°ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦æ‰±ã†
  return new GatheringCardView(scene, options);
};
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ã‚«ãƒ¼ãƒ‰è¿½åŠ  ğŸŸ¡

**Given**: ç©ºã®HandContainerãŒã‚ã‚‹
**When**: addCardã‚’å‘¼ã¶
**Then**: ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è¿½åŠ ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ã‚«ãƒ¼ãƒ‰å‰Šé™¤ ğŸŸ¡

**Given**: ã‚«ãƒ¼ãƒ‰ãŒ3æšã‚ã‚‹
**When**: ä¸­å¤®ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã™ã‚‹
**Then**: ã‚«ãƒ¼ãƒ‰ãŒ2æšã«ãªã‚Šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒå†èª¿æ•´ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåˆ‡æ›¿ ğŸŸ¡

**Given**: æ°´å¹³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§è¡¨ç¤ºä¸­
**When**: setLayoutType('fan')ã‚’å‘¼ã¶
**Then**: æ‰‡å½¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«å¤‰æ›´ã•ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0196` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚«ãƒ¼ãƒ‰è¿½åŠ æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ–¹å‘
- å¤§é‡ã‚«ãƒ¼ãƒ‰æ™‚ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- CardViewFactoryã®æ‹¡å¼µæ€§

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 2é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 2é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ª

# TASK-0171: SceneManagerã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ©Ÿèƒ½å®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0171
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 1 - PhaseråŸºç›¤ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©æ§‹ç¯‰
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬ã«åŸºã¥ã*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ **: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

SceneManagerã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ©Ÿèƒ½ï¼ˆopenOverlayã€closeOverlayã€closeAllOverlaysï¼‰ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0170
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0181

## å®Œäº†æ¡ä»¶

- [x] openOverlay()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [x] closeOverlay()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [x] closeAllOverlays()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [x] isOverlayOpen()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [x] è¤‡æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®é‡ã­é †ãŒç®¡ç†ã•ã‚Œã‚‹ï¼ˆSetã§è¿½åŠ é †ç®¡ç†ï¼‰

---

## å®Ÿè£…è©³ç´°

### 1. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ©Ÿèƒ½å®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *Phaserã®launch/stopã‚’ä½¿ç”¨*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/managers/SceneManager.ts`ã«è¿½åŠ 

```typescript
// SceneManagerã‚¯ãƒ©ã‚¹ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰

async openOverlay(
  sceneKey: SceneKey,
  data?: Record<string, unknown>,
  transition: TransitionConfig = DefaultTransitions.overlay
): Promise<void> {
  if (!this.game || this.openOverlays.has(sceneKey)) return;

  const scenePlugin = this.game.scene;
  const currentScene = this.currentScene ? scenePlugin.getScene(this.currentScene) : null;

  // ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã‚’ä¸€æ™‚åœæ­¢
  if (currentScene) {
    currentScene.scene.pause();
  }

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã‚’èµ·å‹•
  scenePlugin.launch(sceneKey, data);
  this.openOverlays.add(sceneKey);

  // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
  if (transition.type === 'fade' && transition.duration > 0) {
    const overlayScene = scenePlugin.getScene(sceneKey);
    if (overlayScene) {
      overlayScene.cameras.main.setAlpha(0);
      overlayScene.tweens.add({
        targets: overlayScene.cameras.main,
        alpha: 1,
        duration: transition.duration,
      });
    }
  }

  this.eventBus.emit('scene:overlay:opened' as any, { sceneKey });
}

async closeOverlay(
  sceneKey: SceneKey,
  transition: TransitionConfig = DefaultTransitions.overlay
): Promise<void> {
  if (!this.game || !this.openOverlays.has(sceneKey)) return;

  const scenePlugin = this.game.scene;
  const overlayScene = scenePlugin.getScene(sceneKey);

  // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
  if (transition.type === 'fade' && transition.duration > 0 && overlayScene) {
    await new Promise<void>(resolve => {
      overlayScene.tweens.add({
        targets: overlayScene.cameras.main,
        alpha: 0,
        duration: transition.duration,
        onComplete: () => resolve(),
      });
    });
  }

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã‚’åœæ­¢
  scenePlugin.stop(sceneKey);
  this.openOverlays.delete(sceneKey);

  // ä»–ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒãªã‘ã‚Œã°ã€ãƒ¡ã‚¤ãƒ³ã‚·ãƒ¼ãƒ³ã‚’å†é–‹
  if (this.openOverlays.size === 0 && this.currentScene) {
    const mainScene = scenePlugin.getScene(this.currentScene);
    if (mainScene) {
      mainScene.scene.resume();
    }
  }

  this.eventBus.emit('scene:overlay:closed' as any, { sceneKey });
}

async closeAllOverlays(): Promise<void> {
  const overlays = [...this.openOverlays];
  for (const overlay of overlays) {
    await this.closeOverlay(overlay, DefaultTransitions.quick);
  }
}

isOverlayOpen(sceneKey: SceneKey): boolean {
  return this.openOverlays.has(sceneKey);
}

getOpenOverlays(): SceneKey[] {
  return [...this.openOverlays];
}
```

### 2. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®é‡ã­é †ç®¡ç† ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *Phaserã®bringToTopä½¿ç”¨*

```typescript
// ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æœ€å‰é¢ã«æŒã£ã¦ãã‚‹
private bringOverlayToTop(sceneKey: SceneKey): void {
  if (!this.game) return;
  this.game.scene.bringToTop(sceneKey);
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‹ã ğŸŸ¡

**Given**: MainSceneãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–
**When**: openOverlay('ShopScene')ã‚’å‘¼ã¶
**Then**: ShopSceneãŒã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã‚‹ ğŸŸ¡

**Given**: ShopSceneãŒã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã§é–‹ã„ã¦ã„ã‚‹
**When**: closeOverlay('ShopScene')ã‚’å‘¼ã¶
**Then**: ShopSceneãŒé–‰ã˜ã‚‰ã‚ŒMainSceneãŒå†é–‹ã™ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: isOverlayOpen ğŸŸ¡

**Given**: ShopSceneãŒã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã§é–‹ã„ã¦ã„ã‚‹
**When**: isOverlayOpen('ShopScene')ã‚’å‘¼ã¶
**Then**: trueãŒè¿”ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹4: closeAllOverlays ğŸŸ¡

**Given**: è¤‡æ•°ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒé–‹ã„ã¦ã„ã‚‹
**When**: closeAllOverlays()ã‚’å‘¼ã¶
**Then**: ã™ã¹ã¦ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒé–‰ã˜ã‚‰ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0171` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤èƒŒæ™¯ã®åŠé€æ˜å‡¦ç†
- è¤‡æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®å…¥åŠ›ãƒ–ãƒ­ãƒƒã‚¯
- ESCã‚­ãƒ¼ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’æ¤œè¨

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 2é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 2é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ª

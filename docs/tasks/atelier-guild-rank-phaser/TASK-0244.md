# TASK-0244: RankUpSceneãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­è¨ˆ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0244
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4 - ã‚µãƒ–ã‚·ãƒ¼ãƒ³ãƒ»Applicationå±¤ä¿®æ­£
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)
- **ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ¼ãƒ**: [data-schema.md](../../design/atelier-guild-rank-phaser/data-schema.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

æ˜‡æ ¼è©¦é¨“ã‚·ãƒ¼ãƒ³ã®åŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’è¨­è¨ˆãƒ»å®Ÿè£…ã™ã‚‹ã€‚è©¦é¨“å†…å®¹è¡¨ç¤ºã¨é€²è¡ŒUIã‚’æ§‹ç¯‰ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0170, TASK-0175
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0245

## å®Œäº†æ¡ä»¶

- [ ] RankUpSceneãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šæ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹
- [ ] è©¦é¨“å†…å®¹è¡¨ç¤ºã‚¨ãƒªã‚¢ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] é€²è¡ŒçŠ¶æ³è¡¨ç¤ºãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ãŒç¢ºä¿ã•ã‚Œã¦ã„ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. RankUpSceneãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šæ•° ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *UIè¨­è¨ˆæ›¸*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/scenes/RankUpSceneConstants.ts`

```typescript
export const RankUpSceneLayout = {
  // ç”»é¢ã‚µã‚¤ã‚º
  SCREEN_WIDTH: 1024,
  SCREEN_HEIGHT: 768,

  // ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆãƒ©ãƒ³ã‚¯æƒ…å ±ï¼‰
  HEADER: {
    X: 0,
    Y: 0,
    WIDTH: 1024,
    HEIGHT: 80,
  },

  // è©¦é¨“ã‚¿ã‚¤ãƒˆãƒ«ãƒ»èª¬æ˜
  TITLE_AREA: {
    X: 50,
    Y: 100,
    WIDTH: 924,
    HEIGHT: 100,
  },

  // è©¦é¨“è¦ä»¶è¡¨ç¤º
  REQUIREMENTS_AREA: {
    X: 50,
    Y: 220,
    WIDTH: 450,
    HEIGHT: 300,
  },

  // ç¾åœ¨ã®é”æˆçŠ¶æ³
  PROGRESS_AREA: {
    X: 524,
    Y: 220,
    WIDTH: 450,
    HEIGHT: 300,
  },

  // å ±é…¬è¡¨ç¤º
  REWARDS_AREA: {
    X: 50,
    Y: 540,
    WIDTH: 924,
    HEIGHT: 120,
  },

  // ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢
  BUTTON_AREA: {
    X: 0,
    Y: 680,
    WIDTH: 1024,
    HEIGHT: 88,
  },
} as const;

export interface RankExamRequirement {
  type: 'quest' | 'alchemy' | 'gathering' | 'gold' | 'item';
  description: string;
  targetValue: number;
  currentValue: number;
}

export interface RankUpReward {
  type: 'card' | 'artifact' | 'unlock';
  name: string;
  description?: string;
}
```

### 2. RankUpSceneåŸºæœ¬æ§‹é€  ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ã‚·ãƒ¼ãƒ³è¨­è¨ˆ*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/scenes/RankUpScene.ts`

```typescript
import Phaser from 'phaser';
import { BaseGameScene, SceneInitData } from './BaseGameScene';
import { RankUpSceneLayout, RankExamRequirement, RankUpReward } from './RankUpSceneConstants';
import { SceneKeys } from '../config/SceneKeys';
import { UIFactory } from '../ui/UIFactory';
import { Colors } from '../config/ColorPalette';
import { TextStyles } from '../config/TextStyles';

export interface RankUpSceneData extends SceneInitData {
  currentRank: string;
  targetRank: string;
  examTitle: string;
  examDescription: string;
  requirements: RankExamRequirement[];
  rewards: RankUpReward[];
  returnScene?: string;
}

export class RankUpScene extends BaseGameScene {
  // UIè¦ç´ 
  private headerContainer!: Phaser.GameObjects.Container;
  private titleContainer!: Phaser.GameObjects.Container;
  private requirementsPanel!: Phaser.GameObjects.Container;
  private progressPanel!: Phaser.GameObjects.Container;
  private rewardsPanel!: Phaser.GameObjects.Container;
  private challengeButton!: Phaser.GameObjects.Container;
  private backButton!: Phaser.GameObjects.Container;

  // ãƒ‡ãƒ¼ã‚¿
  private sceneData!: RankUpSceneData;
  private allRequirementsMet: boolean = false;

  constructor() {
    super(SceneKeys.RANK_UP);
  }

  protected onInit(data?: RankUpSceneData): void {
    if (data) {
      this.sceneData = data;
    }
  }

  protected onPreload(): void {
    // RankUpSceneå›ºæœ‰ã‚¢ã‚»ãƒƒãƒˆ
  }

  protected onCreate(data?: RankUpSceneData): void {
    this.createBackground();
    this.createHeader();
    this.createTitleArea();
    this.createRequirementsPanel();
    this.createProgressPanel();
    this.createRewardsPanel();
    this.createButtons();

    // è¦ä»¶é”æˆåˆ¤å®š
    this.checkRequirements();
  }

  private createBackground(): void {
    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
    const bg = this.add.graphics();
    bg.fillStyle(Colors.backgroundDark, 1);
    bg.fillRect(0, 0, RankUpSceneLayout.SCREEN_WIDTH, RankUpSceneLayout.SCREEN_HEIGHT);

    // è£…é£¾çš„ãªå…‰å½©
    const glow = this.add.graphics();
    glow.fillStyle(Colors.primary, 0.1);
    glow.fillCircle(
      RankUpSceneLayout.SCREEN_WIDTH / 2,
      200,
      300
    );
  }

  private createHeader(): void {
    const { HEADER } = RankUpSceneLayout;

    this.headerContainer = this.add.container(HEADER.X, HEADER.Y);

    // ãƒ˜ãƒƒãƒ€ãƒ¼èƒŒæ™¯
    const bg = this.add.graphics();
    bg.fillStyle(Colors.panelBackground, 1);
    bg.fillRect(0, 0, HEADER.WIDTH, HEADER.HEIGHT);
    this.headerContainer.add(bg);

    // ç¾åœ¨ãƒ©ãƒ³ã‚¯
    const currentRankLabel = this.add.text(100, 25, 'ç¾åœ¨ã®ãƒ©ãƒ³ã‚¯', {
      ...TextStyles.body,
      fontSize: '14px',
      color: '#888888',
    });
    this.headerContainer.add(currentRankLabel);

    const currentRankValue = this.add.text(100, 45, this.sceneData.currentRank, {
      ...TextStyles.heading,
      fontSize: '20px',
    });
    this.headerContainer.add(currentRankValue);

    // çŸ¢å°
    const arrow = this.add.text(HEADER.WIDTH / 2, HEADER.HEIGHT / 2, 'â†’', {
      fontSize: '32px',
      color: '#ffcc00',
    }).setOrigin(0.5);
    this.headerContainer.add(arrow);

    // ç›®æ¨™ãƒ©ãƒ³ã‚¯
    const targetRankLabel = this.add.text(HEADER.WIDTH - 200, 25, 'ç›®æ¨™ãƒ©ãƒ³ã‚¯', {
      ...TextStyles.body,
      fontSize: '14px',
      color: '#888888',
    });
    this.headerContainer.add(targetRankLabel);

    const targetRankValue = this.add.text(HEADER.WIDTH - 200, 45, this.sceneData.targetRank, {
      ...TextStyles.heading,
      fontSize: '20px',
      color: '#ffcc00',
    });
    this.headerContainer.add(targetRankValue);
  }

  private createTitleArea(): void {
    const { TITLE_AREA } = RankUpSceneLayout;

    this.titleContainer = this.add.container(TITLE_AREA.X, TITLE_AREA.Y);

    // è©¦é¨“ã‚¿ã‚¤ãƒˆãƒ«
    const title = this.add.text(
      TITLE_AREA.WIDTH / 2,
      20,
      `ã€æ˜‡æ ¼è©¦é¨“ã€‘${this.sceneData.examTitle}`,
      {
        ...TextStyles.title,
        fontSize: '24px',
      }
    ).setOrigin(0.5, 0);
    this.titleContainer.add(title);

    // èª¬æ˜æ–‡
    const description = this.add.text(
      TITLE_AREA.WIDTH / 2,
      60,
      this.sceneData.examDescription,
      {
        ...TextStyles.body,
        fontSize: '14px',
        color: '#aaaaaa',
        wordWrap: { width: TITLE_AREA.WIDTH - 40 },
        align: 'center',
      }
    ).setOrigin(0.5, 0);
    this.titleContainer.add(description);
  }

  private createRequirementsPanel(): void {
    const { REQUIREMENTS_AREA } = RankUpSceneLayout;

    this.requirementsPanel = this.add.container(REQUIREMENTS_AREA.X, REQUIREMENTS_AREA.Y);

    // ãƒ‘ãƒãƒ«èƒŒæ™¯
    const bg = this.add.graphics();
    bg.fillStyle(Colors.panelBackground, 1);
    bg.fillRoundedRect(0, 0, REQUIREMENTS_AREA.WIDTH, REQUIREMENTS_AREA.HEIGHT, 8);
    bg.lineStyle(1, Colors.panelBorder);
    bg.strokeRoundedRect(0, 0, REQUIREMENTS_AREA.WIDTH, REQUIREMENTS_AREA.HEIGHT, 8);
    this.requirementsPanel.add(bg);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const panelTitle = this.add.text(REQUIREMENTS_AREA.WIDTH / 2, 20, 'è©¦é¨“è¦ä»¶', {
      ...TextStyles.heading,
      fontSize: '18px',
    }).setOrigin(0.5);
    this.requirementsPanel.add(panelTitle);

    // è¦ä»¶ãƒªã‚¹ãƒˆ
    let y = 60;
    this.sceneData.requirements.forEach((req, index) => {
      const reqItem = this.createRequirementItem(req, 20, y);
      this.requirementsPanel.add(reqItem);
      y += 50;
    });
  }

  private createRequirementItem(
    req: RankExamRequirement,
    x: number,
    y: number
  ): Phaser.GameObjects.Container {
    const container = this.add.container(x, y);

    // ã‚¢ã‚¤ã‚³ãƒ³
    const icon = this.getRequirementIcon(req.type);
    const iconText = this.add.text(0, 10, icon, { fontSize: '20px' });
    container.add(iconText);

    // èª¬æ˜
    const desc = this.add.text(40, 0, req.description, {
      ...TextStyles.body,
      fontSize: '14px',
    });
    container.add(desc);

    // é”æˆçŠ¶æ³
    const isMet = req.currentValue >= req.targetValue;
    const statusText = `${req.currentValue} / ${req.targetValue}`;
    const status = this.add.text(40, 22, statusText, {
      ...TextStyles.body,
      fontSize: '12px',
      color: isMet ? '#00ff00' : '#ffcc00',
    });
    container.add(status);

    // ãƒã‚§ãƒƒã‚¯ãƒãƒ¼ã‚¯
    if (isMet) {
      const check = this.add.text(380, 10, 'âœ“', {
        fontSize: '20px',
        color: '#00ff00',
      });
      container.add(check);
    }

    return container;
  }

  private getRequirementIcon(type: string): string {
    switch (type) {
      case 'quest': return 'ğŸ“‹';
      case 'alchemy': return 'âš—ï¸';
      case 'gathering': return 'ğŸŒ¿';
      case 'gold': return 'ğŸ’°';
      case 'item': return 'ğŸ“¦';
      default: return 'ğŸ“Œ';
    }
  }

  private createProgressPanel(): void {
    const { PROGRESS_AREA } = RankUpSceneLayout;

    this.progressPanel = this.add.container(PROGRESS_AREA.X, PROGRESS_AREA.Y);

    // ãƒ‘ãƒãƒ«èƒŒæ™¯
    const bg = this.add.graphics();
    bg.fillStyle(Colors.panelBackground, 1);
    bg.fillRoundedRect(0, 0, PROGRESS_AREA.WIDTH, PROGRESS_AREA.HEIGHT, 8);
    bg.lineStyle(1, Colors.panelBorder);
    bg.strokeRoundedRect(0, 0, PROGRESS_AREA.WIDTH, PROGRESS_AREA.HEIGHT, 8);
    this.progressPanel.add(bg);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const panelTitle = this.add.text(PROGRESS_AREA.WIDTH / 2, 20, 'é”æˆé€²æ—', {
      ...TextStyles.heading,
      fontSize: '18px',
    }).setOrigin(0.5);
    this.progressPanel.add(panelTitle);

    // ç·åˆé€²æ—ãƒãƒ¼
    this.createOverallProgressBar();

    // å€‹åˆ¥é€²æ—
    let y = 120;
    this.sceneData.requirements.forEach((req, index) => {
      const progressBar = this.createIndividualProgressBar(req, 30, y);
      this.progressPanel.add(progressBar);
      y += 45;
    });
  }

  private createOverallProgressBar(): void {
    const totalRequirements = this.sceneData.requirements.length;
    const metRequirements = this.sceneData.requirements.filter(
      req => req.currentValue >= req.targetValue
    ).length;

    const progress = metRequirements / totalRequirements;

    // èƒŒæ™¯
    const bgBar = this.add.graphics();
    bgBar.fillStyle(Colors.backgroundMedium, 1);
    bgBar.fillRoundedRect(30, 60, 390, 30, 15);
    this.progressPanel.add(bgBar);

    // é€²æ—ãƒãƒ¼
    const progressBar = this.add.graphics();
    const color = progress >= 1 ? 0x00ff00 : 0xffcc00;
    progressBar.fillStyle(color, 1);
    progressBar.fillRoundedRect(30, 60, 390 * progress, 30, 15);
    this.progressPanel.add(progressBar);

    // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆè¡¨ç¤º
    const percentText = this.add.text(225, 75, `${Math.round(progress * 100)}%`, {
      ...TextStyles.heading,
      fontSize: '16px',
    }).setOrigin(0.5);
    this.progressPanel.add(percentText);
  }

  private createIndividualProgressBar(
    req: RankExamRequirement,
    x: number,
    y: number
  ): Phaser.GameObjects.Container {
    const container = this.add.container(x, y);

    // ãƒ©ãƒ™ãƒ«
    const label = this.add.text(0, 0, req.description.slice(0, 15), {
      ...TextStyles.body,
      fontSize: '12px',
    });
    container.add(label);

    // ãƒãƒ¼èƒŒæ™¯
    const bgBar = this.add.graphics();
    bgBar.fillStyle(Colors.backgroundMedium, 1);
    bgBar.fillRoundedRect(150, -5, 200, 20, 10);
    container.add(bgBar);

    // é€²æ—ãƒãƒ¼
    const progress = Math.min(req.currentValue / req.targetValue, 1);
    const progressBar = this.add.graphics();
    const color = progress >= 1 ? 0x00ff00 : 0x0088ff;
    progressBar.fillStyle(color, 1);
    progressBar.fillRoundedRect(150, -5, 200 * progress, 20, 10);
    container.add(progressBar);

    // æ•°å€¤
    const valueText = this.add.text(360, 0, `${req.currentValue}/${req.targetValue}`, {
      ...TextStyles.body,
      fontSize: '11px',
    });
    container.add(valueText);

    return container;
  }

  private createRewardsPanel(): void {
    const { REWARDS_AREA } = RankUpSceneLayout;

    this.rewardsPanel = this.add.container(REWARDS_AREA.X, REWARDS_AREA.Y);

    // ãƒ‘ãƒãƒ«èƒŒæ™¯
    const bg = this.add.graphics();
    bg.fillStyle(Colors.panelBackground, 1);
    bg.fillRoundedRect(0, 0, REWARDS_AREA.WIDTH, REWARDS_AREA.HEIGHT, 8);
    bg.lineStyle(1, Colors.panelBorder);
    bg.strokeRoundedRect(0, 0, REWARDS_AREA.WIDTH, REWARDS_AREA.HEIGHT, 8);
    this.rewardsPanel.add(bg);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const panelTitle = this.add.text(20, 15, 'æ˜‡æ ¼å ±é…¬', {
      ...TextStyles.heading,
      fontSize: '16px',
    });
    this.rewardsPanel.add(panelTitle);

    // å ±é…¬ãƒªã‚¹ãƒˆ
    let x = 30;
    this.sceneData.rewards.forEach((reward, index) => {
      const rewardItem = this.createRewardItem(reward, x, 50);
      this.rewardsPanel.add(rewardItem);
      x += 220;
    });
  }

  private createRewardItem(reward: RankUpReward, x: number, y: number): Phaser.GameObjects.Container {
    const container = this.add.container(x, y);

    // ã‚¢ã‚¤ã‚³ãƒ³èƒŒæ™¯
    const iconBg = this.add.graphics();
    iconBg.fillStyle(0xffaa00, 0.2);
    iconBg.fillRoundedRect(0, 0, 50, 50, 8);
    container.add(iconBg);

    // ã‚¢ã‚¤ã‚³ãƒ³
    const icon = this.getRewardIcon(reward.type);
    const iconText = this.add.text(25, 25, icon, { fontSize: '24px' }).setOrigin(0.5);
    container.add(iconText);

    // åå‰
    const nameText = this.add.text(60, 10, reward.name, {
      ...TextStyles.body,
      fontSize: '14px',
    });
    container.add(nameText);

    // èª¬æ˜
    if (reward.description) {
      const descText = this.add.text(60, 30, reward.description, {
        ...TextStyles.body,
        fontSize: '11px',
        color: '#888888',
      });
      container.add(descText);
    }

    return container;
  }

  private getRewardIcon(type: string): string {
    switch (type) {
      case 'card': return 'ğŸƒ';
      case 'artifact': return 'ğŸ†';
      case 'unlock': return 'ğŸ”“';
      default: return 'ğŸ';
    }
  }

  private createButtons(): void {
    const { BUTTON_AREA } = RankUpSceneLayout;

    // æŒ‘æˆ¦ãƒœã‚¿ãƒ³
    this.challengeButton = UIFactory.createButton(this, {
      x: BUTTON_AREA.WIDTH / 2 + 100,
      y: BUTTON_AREA.Y + 44,
      width: 200,
      height: 50,
      text: 'è©¦é¨“ã«æŒ‘æˆ¦',
      onClick: () => this.handleChallenge(),
    });

    // æˆ»ã‚‹ãƒœã‚¿ãƒ³
    this.backButton = UIFactory.createButton(this, {
      x: BUTTON_AREA.WIDTH / 2 - 100,
      y: BUTTON_AREA.Y + 44,
      width: 150,
      height: 50,
      text: 'æˆ»ã‚‹',
      style: 'secondary',
      onClick: () => this.handleBack(),
    });
  }

  private checkRequirements(): void {
    this.allRequirementsMet = this.sceneData.requirements.every(
      req => req.currentValue >= req.targetValue
    );

    // æŒ‘æˆ¦ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹
    this.updateChallengeButton();
  }

  private updateChallengeButton(): void {
    if (this.allRequirementsMet) {
      // æœ‰åŠ¹åŒ–
      this.challengeButton.setAlpha(1);
      this.challengeButton.setInteractive();
    } else {
      // ç„¡åŠ¹åŒ–
      this.challengeButton.setAlpha(0.5);
      this.challengeButton.disableInteractive();
    }
  }

  private handleChallenge(): void {
    if (!this.allRequirementsMet) return;

    this.eventBus.emit('rankup:challenge:start', {
      currentRank: this.sceneData.currentRank,
      targetRank: this.sceneData.targetRank,
    });
  }

  private handleBack(): void {
    const returnScene = this.sceneData.returnScene ?? SceneKeys.MAIN;
    this.sceneManager.switchTo(returnScene);
  }

  // å¤–éƒ¨ã‹ã‚‰ã®æ›´æ–°
  updateRequirement(index: number, currentValue: number): void {
    if (index >= 0 && index < this.sceneData.requirements.length) {
      this.sceneData.requirements[index].currentValue = currentValue;
      this.refreshUI();
    }
  }

  private refreshUI(): void {
    // UIå†æ§‹ç¯‰
    this.requirementsPanel.destroy();
    this.progressPanel.destroy();
    this.createRequirementsPanel();
    this.createProgressPanel();
    this.checkRequirements();
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ã‚·ãƒ¼ãƒ³åˆæœŸåŒ– ğŸ”µ

**Given**: RankUpSceneã‚’èµ·å‹•
**When**: createãŒå®Œäº†
**Then**: ãƒ˜ãƒƒãƒ€ãƒ¼ã€è¦ä»¶ã€é€²æ—ã€å ±é…¬ãƒ‘ãƒãƒ«ãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: è¦ä»¶é”æˆåˆ¤å®š ğŸ”µ

**Given**: ã™ã¹ã¦ã®è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹
**When**: ç”»é¢ã‚’è¡¨ç¤º
**Then**: æŒ‘æˆ¦ãƒœã‚¿ãƒ³ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: è¦ä»¶æœªé”æˆæ™‚ ğŸ”µ

**Given**: ä¸€éƒ¨ã®è¦ä»¶ãŒæœªé”æˆ
**When**: ç”»é¢ã‚’è¡¨ç¤º
**Then**: æŒ‘æˆ¦ãƒœã‚¿ãƒ³ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0244` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- é”æˆçŠ¶æ³ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
- é€²æ—ãƒãƒ¼ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- å ±é…¬è¡¨ç¤ºã®è¦–è¦šçš„é­…åŠ›

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 2é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 2é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

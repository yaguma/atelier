# TASK-0259: Phase4çµ±åˆãƒ†ã‚¹ãƒˆ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0259
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4 - ã‚µãƒ–ã‚·ãƒ¼ãƒ³ãƒ»Applicationå±¤ä¿®æ­£
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

Phase 4ã§å®Ÿè£…ã—ãŸå…¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚ã‚µãƒ–ã‚·ãƒ¼ãƒ³ã€Applicationå±¤é€£æºã€ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’å«ã‚€åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚’è¡Œã†ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0243, TASK-0246, TASK-0249, TASK-0254, TASK-0255
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0260 (Phase5é–‹å§‹)

## å®Œäº†æ¡ä»¶

- [ ] ShopSceneå…¨æ©Ÿèƒ½ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] RankUpSceneå…¨æ©Ÿèƒ½ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] GameOver/GameClearSceneã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] Applicationå±¤é€£æºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] Phase 4å…¨ä½“ã®ã‚«ãƒãƒ¬ãƒƒã‚¸ãŒ80%ä»¥ä¸Š

---

## ãƒ†ã‚¹ãƒˆå®Ÿè£…è©³ç´°

### 1. ã‚µãƒ–ã‚·ãƒ¼ãƒ³çµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase4/SubSceneIntegration.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createTestScene, createMockEventBus, createMockStateManager } from '../../../utils/phaserTestUtils';

describe('Phase4 SubScene Integration', () => {
  let scene: Phaser.Scene;
  let eventBus: ReturnType<typeof createMockEventBus>;
  let stateManager: ReturnType<typeof createMockStateManager>;

  beforeEach(() => {
    eventBus = createMockEventBus();
    stateManager = createMockStateManager();
    scene = createTestScene();
  });

  afterEach(() => {
    scene.destroy();
  });

  describe('ShopScene Integration', () => {
    it('ã‚·ãƒ§ãƒƒãƒ—ã§ã‚«ãƒ¼ãƒ‰ã‚’è³¼å…¥ã§ãã‚‹', async () => {
      // Arrange
      stateManager.getPlayerData.mockReturnValue({
        gold: 1000,
        rank: 'D',
      });

      // Act
      eventBus.emit('ui:shop:purchase:requested', {
        category: 'card',
        itemId: 'gathering_card_001',
        quantity: 1,
      });

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:shop:purchased',
          expect.objectContaining({
            item: expect.any(Object),
            newGold: expect.any(Number),
          })
        );
      });
    });

    it('ã‚´ãƒ¼ãƒ«ãƒ‰ä¸è¶³æ™‚ã«è³¼å…¥ã§ããªã„', async () => {
      // Arrange
      stateManager.getPlayerData.mockReturnValue({
        gold: 10,
        rank: 'D',
      });

      // Act
      eventBus.emit('ui:shop:purchase:requested', {
        category: 'card',
        itemId: 'gathering_card_001',
        quantity: 1,
      });

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:error:occurred',
          expect.objectContaining({
            message: expect.stringContaining('ã‚´ãƒ¼ãƒ«ãƒ‰'),
          })
        );
      });
    });

    it('ãƒ©ãƒ³ã‚¯åˆ¶é™ã®ã‚ã‚‹å•†å“ã¯è³¼å…¥ã§ããªã„', async () => {
      // Arrange
      stateManager.getPlayerData.mockReturnValue({
        gold: 10000,
        rank: 'E',
      });

      // Act
      eventBus.emit('ui:shop:purchase:requested', {
        category: 'card',
        itemId: 'rare_recipe_card_001', // Aãƒ©ãƒ³ã‚¯å¿…è¦
        quantity: 1,
      });

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:error:occurred',
          expect.objectContaining({
            message: expect.stringContaining('ãƒ©ãƒ³ã‚¯'),
          })
        );
      });
    });
  });

  describe('RankUpScene Integration', () => {
    it('æ˜‡æ ¼è©¦é¨“ã«åˆæ ¼ã§ãã‚‹', async () => {
      // Arrange
      stateManager.getPlayerData.mockReturnValue({
        rank: 'E',
        exp: 100,
        maxExp: 100,
      });

      // Act
      eventBus.emit('ui:rankup:challenge:requested', {
        targetRank: 'D',
      });

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:rankup:success',
          expect.objectContaining({
            newRank: 'D',
            rewards: expect.any(Object),
          })
        );
      });
    });

    it('çµŒé¨“å€¤ä¸è¶³ã§æ˜‡æ ¼è©¦é¨“ã«å¤±æ•—ã™ã‚‹', async () => {
      // Arrange
      stateManager.getPlayerData.mockReturnValue({
        rank: 'E',
        exp: 50,
        maxExp: 100,
      });

      // Act
      eventBus.emit('ui:rankup:challenge:requested', {
        targetRank: 'D',
      });

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:rankup:failed',
          expect.objectContaining({
            reason: expect.stringContaining('çµŒé¨“å€¤'),
          })
        );
      });
    });
  });

  describe('GameOver/GameClear Integration', () => {
    it('æ—¥æ•°è¶…éã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚‹', async () => {
      // Arrange
      stateManager.getProgress.mockReturnValue({
        currentDay: 30,
        maxDay: 30,
        currentPhase: 'delivery',
      });
      stateManager.getPlayerData.mockReturnValue({
        rank: 'C',
        gold: 500,
      });

      // Act
      eventBus.emit('ui:day:end:requested');

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:game:over',
          expect.objectContaining({
            reason: expect.stringContaining('æœŸé™'),
          })
        );
      });
    });

    it('Sãƒ©ãƒ³ã‚¯åˆ°é”ã§ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ã«ãªã‚‹', async () => {
      // Arrange
      stateManager.getProgress.mockReturnValue({
        currentDay: 20,
        maxDay: 30,
        currentPhase: 'delivery',
      });
      stateManager.getPlayerData.mockReturnValue({
        rank: 'S',
        gold: 5000,
      });

      // Act
      eventBus.emit('ui:day:end:requested');

      // Assert
      await vi.waitFor(() => {
        expect(eventBus.emit).toHaveBeenCalledWith(
          'app:game:clear',
          expect.objectContaining({
            stats: expect.any(Object),
          })
        );
      });
    });
  });
});
```

### 2. Applicationå±¤é€£æºãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase4/ApplicationLayerIntegration.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { EventBusAdapter } from '@/presentation/phaser/events/EventBusAdapter';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';

describe('Application Layer Integration', () => {
  let eventBus: EventBus;
  let eventBusAdapter: EventBusAdapter;
  let stateManager: PhaserStateManager;

  beforeEach(() => {
    eventBus = new EventBus();
    stateManager = new PhaserStateManager(eventBus);
    eventBusAdapter = new EventBusAdapter(eventBus);
  });

  describe('Event Flow', () => {
    it('UIâ†’Appâ†’UIã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼ãŒæ­£ã—ãå‹•ä½œã™ã‚‹', async () => {
      // Arrange
      const uiCallback = vi.fn();
      eventBus.on('app:quest:accepted', uiCallback);

      // Act
      eventBus.emit('ui:quest:accept:requested', { questId: 'quest_001' });

      // Assert
      await vi.waitFor(() => {
        expect(uiCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            quest: expect.any(Object),
          })
        );
      });
    });

    it('ã‚¨ãƒ©ãƒ¼æ™‚ã«error:occurredã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      // Arrange
      const errorCallback = vi.fn();
      eventBus.on('app:error:occurred', errorCallback);

      // Act - å­˜åœ¨ã—ãªã„ä¾é ¼ID
      eventBus.emit('ui:quest:accept:requested', { questId: 'invalid_quest' });

      // Assert
      await vi.waitFor(() => {
        expect(errorCallback).toHaveBeenCalled();
      });
    });
  });

  describe('State Synchronization', () => {
    it('çŠ¶æ…‹æ›´æ–°ãŒEventBusã«è‡ªå‹•é€šçŸ¥ã•ã‚Œã‚‹', () => {
      // Arrange
      const callback = vi.fn();
      eventBus.on('app:player:data:updated', callback);

      // Act
      stateManager.updatePlayer({ gold: 1500 });

      // Assert
      expect(callback).toHaveBeenCalledWith(
        expect.objectContaining({
          gold: 1500,
        })
      );
    });

    it('è¤‡æ•°ãƒªã‚¹ãƒŠãƒ¼ãŒåŒæ™‚ã«é€šçŸ¥ã•ã‚Œã‚‹', () => {
      // Arrange
      const callback1 = vi.fn();
      const callback2 = vi.fn();
      eventBus.on('app:player:data:updated', callback1);
      eventBus.on('app:player:data:updated', callback2);

      // Act
      stateManager.updatePlayer({ exp: 50 });

      // Assert
      expect(callback1).toHaveBeenCalled();
      expect(callback2).toHaveBeenCalled();
    });

    it('ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºâ†’ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã§çŠ¶æ…‹ãŒä¿æŒã•ã‚Œã‚‹', () => {
      // Arrange
      stateManager.updatePlayer({ gold: 999, rank: 'B' });
      const serialized = stateManager.serialize();

      // Act
      const newStateManager = new PhaserStateManager(eventBus);
      newStateManager.deserialize(serialized);

      // Assert
      const player = newStateManager.getPlayerData();
      expect(player.gold).toBe(999);
      expect(player.rank).toBe('B');
    });
  });

  describe('Cross-component Communication', () => {
    it('ä¾é ¼å®Œäº†æ™‚ã«ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã¨ã‚´ãƒ¼ãƒ«ãƒ‰ãŒæ›´æ–°ã•ã‚Œã‚‹', async () => {
      // Arrange
      const goldCallback = vi.fn();
      const inventoryCallback = vi.fn();
      eventBus.on('app:player:data:updated', goldCallback);
      eventBus.on('app:inventory:updated', inventoryCallback);

      // ä¾é ¼ã‚’å—æ³¨
      eventBus.emit('ui:quest:accept:requested', { questId: 'quest_001' });
      await vi.waitFor(() => {});

      // Act - ä¾é ¼ã‚’ç´å“
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'quest_001',
        itemIds: ['item_001'],
      });

      // Assert
      await vi.waitFor(() => {
        expect(goldCallback).toHaveBeenCalled();
        expect(inventoryCallback).toHaveBeenCalled();
      });
    });
  });
});
```

### 3. ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰çµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase4/SaveLoadIntegration.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';
import { PhaserSaveLoadManager } from '@/presentation/phaser/save/PhaserSaveLoadManager';

// localStorage ãƒ¢ãƒƒã‚¯
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: vi.fn((key: string) => store[key] ?? null),
    setItem: vi.fn((key: string, value: string) => { store[key] = value; }),
    removeItem: vi.fn((key: string) => { delete store[key]; }),
    clear: vi.fn(() => { store = {}; }),
  };
})();

Object.defineProperty(window, 'localStorage', { value: localStorageMock });

describe('SaveLoad Integration', () => {
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;
  let saveLoadManager: PhaserSaveLoadManager;

  beforeEach(() => {
    localStorageMock.clear();
    eventBus = new EventBus();
    stateManager = new PhaserStateManager(eventBus);
    // flowManagerã¯ãƒ¢ãƒƒã‚¯
    const mockFlowManager = {
      loadGame: vi.fn().mockResolvedValue(undefined),
    };
    saveLoadManager = new PhaserSaveLoadManager(eventBus, stateManager, mockFlowManager as any);
  });

  afterEach(() => {
    saveLoadManager.destroy();
  });

  describe('Manual Save/Load', () => {
    it('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã§ãã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: 2000, rank: 'C' });
      stateManager.updateProgress({ currentDay: 15 });

      // Act
      const result = await saveLoadManager.save(1);

      // Assert
      expect(result).toBe(true);
      expect(localStorageMock.setItem).toHaveBeenCalled();
    });

    it('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: 2000, rank: 'C' });
      await saveLoadManager.save(1);

      // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      stateManager.reset();

      // Act
      const result = await saveLoadManager.load(1);

      // Assert
      expect(result).toBe(true);
      const player = stateManager.getPlayerData();
      expect(player.gold).toBe(2000);
      expect(player.rank).toBe('C');
    });

    it('å­˜åœ¨ã—ãªã„ã‚¹ãƒ­ãƒƒãƒˆã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨å¤±æ•—ã™ã‚‹', async () => {
      // Act
      const result = await saveLoadManager.load(3);

      // Assert
      expect(result).toBe(false);
    });

    it('ç„¡åŠ¹ãªã‚¹ãƒ­ãƒƒãƒˆIDã§ã¯æ“ä½œã§ããªã„', async () => {
      // Act & Assert
      const saveResult = await saveLoadManager.save(0);
      expect(saveResult).toBe(false);

      const loadResult = await saveLoadManager.load(4);
      expect(loadResult).toBe(false);
    });
  });

  describe('Save Slots', () => {
    it('ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 10 });
      stateManager.updatePlayer({ rank: 'D' });
      await saveLoadManager.save(1);

      // Act
      const slots = saveLoadManager.getSaveSlots();

      // Assert
      expect(slots).toHaveLength(3);
      expect(slots[0].exists).toBe(true);
      expect(slots[0].day).toBe(10);
      expect(slots[0].rank).toBe('D');
      expect(slots[1].exists).toBe(false);
      expect(slots[2].exists).toBe(false);
    });

    it('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
      // Arrange
      await saveLoadManager.save(1);

      // Act
      const result = saveLoadManager.deleteSave(1);

      // Assert
      expect(result).toBe(true);
      const slots = saveLoadManager.getSaveSlots();
      expect(slots[0].exists).toBe(false);
    });
  });

  describe('Auto Save', () => {
    it('ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ãŒæ©Ÿèƒ½ã™ã‚‹', async () => {
      // Arrange
      vi.useFakeTimers();
      saveLoadManager.enableAutoSave(1000); // 1ç§’é–“éš”

      // Act
      vi.advanceTimersByTime(1100);

      // Assert
      expect(saveLoadManager.hasAutoSave()).toBe(true);

      vi.useRealTimers();
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´æ™‚ã«ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã•ã‚Œã‚‹', async () => {
      // Arrange
      saveLoadManager.enableAutoSave();
      const saveSpy = vi.spyOn(saveLoadManager as any, 'autoSave');

      // Act
      eventBus.emit('app:phase:changed', { phase: 'gathering' });

      // Assert
      await vi.waitFor(() => {
        expect(saveSpy).toHaveBeenCalled();
      });
    });

    it('ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: 3000 });
      saveLoadManager.enableAutoSave(100);

      vi.useFakeTimers();
      vi.advanceTimersByTime(150);
      vi.useRealTimers();

      stateManager.reset();

      // Act
      const result = await saveLoadManager.loadAutoSave();

      // Assert
      expect(result).toBe(true);
      expect(stateManager.getPlayerData().gold).toBe(3000);
    });
  });

  describe('Playtime Tracking', () => {
    it('ãƒ—ãƒ¬ã‚¤æ™‚é–“ãŒè¿½è·¡ã•ã‚Œã‚‹', () => {
      // Arrange
      vi.useFakeTimers();
      saveLoadManager.startPlaytimeTracking();

      // Act
      vi.advanceTimersByTime(5000); // 5ç§’

      // Assert
      expect(saveLoadManager.getPlaytime()).toBe(5);

      saveLoadManager.stopPlaytimeTracking();
      vi.useRealTimers();
    });

    it('ãƒ—ãƒ¬ã‚¤æ™‚é–“ãŒã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã«å«ã¾ã‚Œã‚‹', async () => {
      // Arrange
      saveLoadManager.setPlaytime(3600); // 1æ™‚é–“
      await saveLoadManager.save(1);

      saveLoadManager.setPlaytime(0);
      await saveLoadManager.load(1);

      // Assert
      expect(saveLoadManager.getPlaytime()).toBe(3600);
    });
  });

  describe('Event Notifications', () => {
    it('ã‚»ãƒ¼ãƒ–å®Œäº†æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      // Arrange
      const callback = vi.fn();
      eventBus.on('save:complete', callback);

      // Act
      await saveLoadManager.save(1);

      // Assert
      expect(callback).toHaveBeenCalledWith({ slotId: 1 });
    });

    it('ãƒ­ãƒ¼ãƒ‰å®Œäº†æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      // Arrange
      await saveLoadManager.save(1);
      const callback = vi.fn();
      eventBus.on('load:complete', callback);

      // Act
      await saveLoadManager.load(1);

      // Assert
      expect(callback).toHaveBeenCalledWith({ slotId: 1 });
    });
  });
});
```

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0259` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸ |
|---------------|---------------|
| ShopScene | 85% |
| RankUpScene | 85% |
| GameOver/ClearScene | 80% |
| EventBusAdapter | 90% |
| PhaserStateManager | 90% |
| PhaserGameFlowManager | 85% |
| PhaserSaveLoadManager | 90% |
| **Phase 4 å…¨ä½“** | **80%ä»¥ä¸Š** |

---

## æ³¨æ„äº‹é …

- éåŒæœŸå‡¦ç†ã®ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒŸãƒ³ã‚°
- localStorageãƒ¢ãƒƒã‚¯ã®æ­£ç¢ºãªå®Ÿè£…
- ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«é †åºã®æ¤œè¨¼

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 3é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 3é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

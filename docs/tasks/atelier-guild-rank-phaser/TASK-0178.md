# TASK-0178: UIFactoryGridButtons生成実装

**タスクID**: TASK-0178
**タスクタイプ**: TDD
**推定工数**: 4時間
**フェーズ**: Phase 1 - Phaser基盤・インフラ構築
**信頼性レベル**: 🟡 *妥当な推測に基づく*

## 関連文書

- **概要**: [overview.md](./overview.md)
- **コアシステム**: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)

## タスク概要

UIFactoryのcreateGridButtons()メソッドを実装し、グリッド状に配置されたボタン群を生成できるようにする。

## 依存タスク

- **前提タスク**: TASK-0174
- **後続タスク**: TASK-0195, TASK-0220

## 完了条件

- [x] createGridButtons()メソッドが実装されている
- [x] グリッド状にアイテムが配置される
- [x] アイテムクリックイベントが動作する
- [x] 選択状態の視覚的表示がある
- [x] 動的なアイテム追加・削除ができる

---

## 実装詳細

### 1. createGridButtons実装 🟡

**信頼性**: 🟡 *rexUI.GridButtonsを使用*

**実装ファイル**: `src/presentation/phaser/ui/UIFactory.ts`に追加

```typescript
import GridButtons from 'phaser3-rex-plugins/templates/ui/gridbuttons/GridButtons';

export interface GridButtonsObject {
  grid: GridButtons;
  getSelectedId: () => string | null;
  setSelectedId: (id: string | null) => void;
  getItems: () => Array<{ id: string; data?: unknown }>;
  refresh: (items: GridButtonsOptions['items']) => void;
}

createGridButtons(options: GridButtonsOptions): GridButtonsObject {
  const {
    x, y, items, columns,
    cellWidth, cellHeight, space,
    onItemClick
  } = options;

  let selectedId: string | null = null;

  // ボタン生成関数
  const createButton = (item: typeof items[0], index: number) => {
    const isSelected = item.id === selectedId;

    const background = this.rexUI.add.roundRectangle(
      0, 0, cellWidth, cellHeight, 8,
      isSelected ? Colors.primary : Colors.panelBackground
    );

    let contentObj: Phaser.GameObjects.GameObject;
    if (typeof item.content === 'string') {
      contentObj = this.scene.add.text(0, 0, item.content, TextStyles.body);
    } else {
      contentObj = item.content;
    }

    const button = this.rexUI.add.label({
      width: cellWidth,
      height: cellHeight,
      background,
      text: typeof item.content === 'string' ? contentObj : undefined,
      icon: typeof item.content !== 'string' ? contentObj : undefined,
      align: 'center',
    });

    // データを保持
    (button as any).itemId = item.id;
    (button as any).itemData = item.data;

    return button;
  };

  // グリッド生成
  const buttons = items.map((item, i) => createButton(item, i));

  // 行に分割
  const rows: any[][] = [];
  for (let i = 0; i < buttons.length; i += columns) {
    rows.push(buttons.slice(i, i + columns));
  }

  // 不足分を埋める
  const lastRow = rows[rows.length - 1];
  while (lastRow && lastRow.length < columns) {
    lastRow.push(null as any); // プレースホルダー
  }

  const grid = this.rexUI.add.gridButtons({
    x, y,
    width: columns * cellWidth + (columns - 1) * (space?.column ?? 8),

    background: this.rexUI.add.roundRectangle(0, 0, 0, 0, 0, 0x000000, 0),

    buttons: rows,

    space: {
      column: space?.column ?? 8,
      row: space?.row ?? 8,
    },
  }).layout();

  // クリックイベント
  grid.on('button.click', (button: any, _index: number, _pointer: any) => {
    if (!button || !button.itemId) return;

    const prevSelected = selectedId;
    selectedId = button.itemId;

    // 選択状態の更新
    grid.getElement('buttons').flat().forEach((btn: any) => {
      if (!btn) return;
      const bg = btn.getElement('background');
      if (bg) {
        bg.setFillStyle(
          btn.itemId === selectedId ? Colors.primary : Colors.panelBackground
        );
      }
    });

    if (onItemClick) {
      onItemClick(button.itemId, button.itemData);
    }
  });

  // ホバーエフェクト
  grid.on('button.over', (button: any) => {
    if (!button || button.itemId === selectedId) return;
    const bg = button.getElement('background');
    if (bg) {
      bg.setFillStyle(Colors.backgroundLight);
    }
  });

  grid.on('button.out', (button: any) => {
    if (!button || button.itemId === selectedId) return;
    const bg = button.getElement('background');
    if (bg) {
      bg.setFillStyle(Colors.panelBackground);
    }
  });

  return {
    grid,
    getSelectedId: () => selectedId,
    setSelectedId: (id) => {
      selectedId = id;
      // 視覚的更新
      grid.getElement('buttons').flat().forEach((btn: any) => {
        if (!btn) return;
        const bg = btn.getElement('background');
        if (bg) {
          bg.setFillStyle(
            btn.itemId === selectedId ? Colors.primary : Colors.panelBackground
          );
        }
      });
    },
    getItems: () => items.map(i => ({ id: i.id, data: i.data })),
    refresh: (newItems) => {
      // 再構築が必要 - 複雑なので別途検討
      console.warn('GridButtons refresh not yet implemented');
    },
  };
}
```

---

## 単体テスト要件

### テストケース1: グリッドボタン生成 🟡

**Given**: UIFactoryインスタンスがある
**When**: createGridButtons()を呼ぶ
**Then**: GridButtonsObjectが返される

### テストケース2: アイテムクリック 🟡

**Given**: グリッドボタンがある
**When**: アイテムをクリックする
**Then**: onItemClickが呼ばれる

### テストケース3: 選択状態 🟡

**Given**: グリッドボタンがある
**When**: setSelectedId()を呼ぶ
**Then**: 指定アイテムが選択状態になる

---

## 実装手順

1. `/tsumiki:tdd-requirements TASK-0178` - 詳細要件定義
2. `/tsumiki:tdd-testcases` - テストケース作成
3. `/tsumiki:tdd-red` - テスト実装（失敗）
4. `/tsumiki:tdd-green` - 最小実装
5. `/tsumiki:tdd-refactor` - リファクタリング
6. `/tsumiki:tdd-verify-complete` - 品質確認

---

## 注意事項

- 最後の行のアイテム数が足りない場合の処理
- 選択状態の永続化
- キーボードナビゲーションを検討

---

## 信頼性レベルサマリー

- **総項目数**: 1項目
- 🔵 **青信号**: 0項目 (0%)
- 🟡 **黄信号**: 1項目 (100%)
- 🔴 **赤信号**: 0項目 (0%)

**品質評価**: 中品質

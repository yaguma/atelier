# TASK-0210: DeckViewå®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0210
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 2 - åŸºæœ¬ã‚·ãƒ¼ãƒ³ãƒ»å…±é€šUIå®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬ã«åŸºã¥ã*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

ãƒ‡ãƒƒã‚­ï¼ˆå±±æœ­ï¼‰ã®è¦–è¦šçš„è¡¨ç¾ã‚’å®Ÿè£…ã™ã‚‹ã€‚æ®‹ã‚Šæšæ•°è¡¨ç¤ºã€ãƒ‰ãƒ­ãƒ¼/ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å«ã‚€ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0173
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0211

## å®Œäº†æ¡ä»¶

- [ ] IDeckViewã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ‡ãƒƒã‚­ã®é‡ãªã‚Šè¡¨ç¤ºãŒã‚ã‚‹
- [ ] æ®‹ã‚Šæšæ•°ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒ‰ãƒ­ãƒ¼æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹
- [ ] ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. DeckViewå®šæ•° ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *è¦–è¦šçš„è¡¨ç¾*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/deck/DeckViewConstants.ts`

```typescript
export const DeckViewLayout = {
  // ä½ç½®ï¼ˆç”»é¢å·¦ä¸‹ï¼‰
  X: 100,
  Y: 550,

  // ã‚«ãƒ¼ãƒ‰ã‚µã‚¤ã‚º
  CARD_WIDTH: 80,
  CARD_HEIGHT: 120,

  // ã‚¹ã‚¿ãƒƒã‚¯è¡¨ç¾
  STACK_OFFSET: 2,
  MAX_VISIBLE_STACK: 5,

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  DRAW_DURATION: 300,
  SHUFFLE_DURATION: 500,
} as const;

export const DeckColors = {
  CARD_BACK: 0x2a3a5a,
  CARD_BORDER: 0x4a5a7a,
  CARD_PATTERN: 0x3a4a6a,
  COUNT_BG: 0x1a1a2e,
} as const;
```

### 2. IDeckViewã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/deck/IDeckView.ts`

```typescript
import Phaser from 'phaser';

export interface DeckViewOptions {
  x?: number;
  y?: number;
  onClick?: () => void;
}

export interface IDeckView {
  // ã‚³ãƒ³ãƒ†ãƒŠå‚ç…§
  readonly container: Phaser.GameObjects.Container;

  // æšæ•°ç®¡ç†
  setCount(count: number): void;
  getCount(): number;

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  animateDraw(): Promise<Phaser.GameObjects.Container>;
  animateShuffle(): Promise<void>;
  animateAddCard(): Promise<void>;

  // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
  setInteractive(enabled: boolean): void;

  // è¡¨ç¤ºåˆ¶å¾¡
  setVisible(visible: boolean): void;

  // ç ´æ£„
  destroy(): void;
}
```

### 3. DeckViewå®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ãƒ‡ãƒƒã‚­è¡¨ç¤º*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/deck/DeckView.ts`

```typescript
import Phaser from 'phaser';
import { IDeckView, DeckViewOptions } from './IDeckView';
import { DeckViewLayout, DeckColors } from './DeckViewConstants';
import { TextStyles } from '../../config/TextStyles';

export class DeckView implements IDeckView {
  public readonly container: Phaser.GameObjects.Container;

  private scene: Phaser.Scene;
  private count: number = 0;
  private onClick?: () => void;

  private stackCards: Phaser.GameObjects.Container[] = [];
  private countBadge!: Phaser.GameObjects.Container;
  private countText!: Phaser.GameObjects.Text;

  constructor(scene: Phaser.Scene, options: DeckViewOptions = {}) {
    this.scene = scene;
    this.onClick = options.onClick;

    const x = options.x ?? DeckViewLayout.X;
    const y = options.y ?? DeckViewLayout.Y;

    this.container = scene.add.container(x, y);
    this.container.setDepth(50);

    this.createDeckStack();
    this.createCountBadge();
    this.setupInteraction();
  }

  private createDeckStack(): void {
    const { CARD_WIDTH, CARD_HEIGHT, STACK_OFFSET, MAX_VISIBLE_STACK } = DeckViewLayout;

    for (let i = 0; i < MAX_VISIBLE_STACK; i++) {
      const cardBack = this.createCardBack(
        -i * STACK_OFFSET,
        -i * STACK_OFFSET
      );
      this.stackCards.push(cardBack);
      this.container.add(cardBack);
    }

    // é€†é †ã§è¿½åŠ ï¼ˆä¸‹ã‹ã‚‰ä¸Šã¸ï¼‰
    this.stackCards.reverse();
  }

  private createCardBack(offsetX: number, offsetY: number): Phaser.GameObjects.Container {
    const { CARD_WIDTH, CARD_HEIGHT } = DeckViewLayout;
    const cardContainer = this.scene.add.container(offsetX, offsetY);

    // ã‚«ãƒ¼ãƒ‰èƒŒé¢
    const card = this.scene.add.graphics();
    card.fillStyle(DeckColors.CARD_BACK, 1);
    card.fillRoundedRect(-CARD_WIDTH / 2, -CARD_HEIGHT / 2, CARD_WIDTH, CARD_HEIGHT, 8);
    card.lineStyle(2, DeckColors.CARD_BORDER);
    card.strokeRoundedRect(-CARD_WIDTH / 2, -CARD_HEIGHT / 2, CARD_WIDTH, CARD_HEIGHT, 8);
    cardContainer.add(card);

    // è£é¢ãƒ‘ã‚¿ãƒ¼ãƒ³
    const pattern = this.scene.add.graphics();
    pattern.fillStyle(DeckColors.CARD_PATTERN, 1);
    pattern.fillRoundedRect(-CARD_WIDTH / 2 + 10, -CARD_HEIGHT / 2 + 10, CARD_WIDTH - 20, CARD_HEIGHT - 20, 4);
    cardContainer.add(pattern);

    // ä¸­å¤®ã®ã‚·ãƒ³ãƒœãƒ«
    const symbol = this.scene.add.text(0, 0, 'âš—ï¸', {
      fontSize: '32px',
    }).setOrigin(0.5);
    cardContainer.add(symbol);

    return cardContainer;
  }

  private createCountBadge(): void {
    const { CARD_WIDTH, CARD_HEIGHT } = DeckViewLayout;

    this.countBadge = this.scene.add.container(CARD_WIDTH / 2, CARD_HEIGHT / 2);

    // ãƒãƒƒã‚¸èƒŒæ™¯
    const bg = this.scene.add.graphics();
    bg.fillStyle(DeckColors.COUNT_BG, 0.9);
    bg.fillCircle(0, 0, 20);
    bg.lineStyle(2, DeckColors.CARD_BORDER);
    bg.strokeCircle(0, 0, 20);
    this.countBadge.add(bg);

    // æšæ•°ãƒ†ã‚­ã‚¹ãƒˆ
    this.countText = this.scene.add.text(0, 0, '0', {
      ...TextStyles.body,
      fontSize: '14px',
      fontStyle: 'bold',
    }).setOrigin(0.5);
    this.countBadge.add(this.countText);

    this.container.add(this.countBadge);
  }

  private setupInteraction(): void {
    const { CARD_WIDTH, CARD_HEIGHT } = DeckViewLayout;

    this.container.setInteractive(
      new Phaser.Geom.Rectangle(-CARD_WIDTH / 2, -CARD_HEIGHT / 2, CARD_WIDTH, CARD_HEIGHT),
      Phaser.Geom.Rectangle.Contains
    );

    this.container.on('pointerdown', () => {
      if (this.onClick) this.onClick();
    });

    this.container.on('pointerover', () => {
      this.scene.tweens.add({
        targets: this.container,
        scaleX: 1.05,
        scaleY: 1.05,
        duration: 100,
        ease: 'Power2',
      });
    });

    this.container.on('pointerout', () => {
      this.scene.tweens.add({
        targets: this.container,
        scaleX: 1,
        scaleY: 1,
        duration: 100,
        ease: 'Power2',
      });
    });
  }

  setCount(count: number): void {
    this.count = count;
    this.countText.setText(`${count}`);

    // æ®‹ã‚Šæšæ•°ã«å¿œã˜ã¦ã‚¹ã‚¿ãƒƒã‚¯ã®è¦‹ãŸç›®ã‚’å¤‰æ›´
    const visibleCount = Math.min(count, DeckViewLayout.MAX_VISIBLE_STACK);
    this.stackCards.forEach((card, index) => {
      card.setVisible(index < visibleCount);
    });

    // 0æšæ™‚ã¯å…¨ã¦éè¡¨ç¤º
    if (count === 0) {
      this.stackCards.forEach(card => card.setVisible(false));
    }
  }

  getCount(): number {
    return this.count;
  }

  async animateDraw(): Promise<Phaser.GameObjects.Container> {
    return new Promise((resolve) => {
      const { DRAW_DURATION } = DeckViewLayout;

      // ä¸€ç•ªä¸Šã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦é£›ã°ã™
      const topCard = this.createCardBack(0, 0);
      this.scene.add.existing(topCard);
      topCard.setPosition(this.container.x, this.container.y);
      topCard.setDepth(150);

      // ã‚«ãƒ¼ãƒ‰ã‚’æ‰‹æœ­ä½ç½®ã«ç§»å‹•
      this.scene.tweens.add({
        targets: topCard,
        x: 640, // ç”»é¢ä¸­å¤®ï¼ˆæ‰‹æœ­ä½ç½®ï¼‰
        y: 650,
        scaleX: 0.8,
        scaleY: 0.8,
        rotation: Phaser.Math.DegToRad(5),
        duration: DRAW_DURATION,
        ease: 'Power2.easeOut',
        onComplete: () => {
          // æšæ•°ã‚’æ¸›ã‚‰ã™
          if (this.count > 0) {
            this.setCount(this.count - 1);
          }
          resolve(topCard);
        },
      });
    });
  }

  async animateShuffle(): Promise<void> {
    return new Promise((resolve) => {
      const { SHUFFLE_DURATION } = DeckViewLayout;

      // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚«ãƒ¼ãƒ‰ãŒæ•£ã‚‰ã°ã£ã¦æˆ»ã‚‹ï¼‰
      const timeline = this.scene.tweens.createTimeline();

      // æ•£ã‚‰ã°ã‚‹
      this.stackCards.forEach((card, index) => {
        timeline.add({
          targets: card,
          x: Phaser.Math.Between(-20, 20),
          y: Phaser.Math.Between(-20, 20),
          rotation: Phaser.Math.DegToRad(Phaser.Math.Between(-15, 15)),
          duration: SHUFFLE_DURATION / 3,
          ease: 'Power2.easeOut',
        });
      });

      // æˆ»ã‚‹
      this.stackCards.forEach((card, index) => {
        timeline.add({
          targets: card,
          x: -index * DeckViewLayout.STACK_OFFSET,
          y: -index * DeckViewLayout.STACK_OFFSET,
          rotation: 0,
          duration: SHUFFLE_DURATION / 3,
          ease: 'Back.easeOut',
        });
      });

      timeline.on('complete', resolve);
      timeline.play();
    });
  }

  async animateAddCard(): Promise<void> {
    return new Promise((resolve) => {
      // ã‚«ãƒ¼ãƒ‰ãŒãƒ‡ãƒƒã‚­ã«è¿½åŠ ã•ã‚Œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      const newCard = this.createCardBack(0, 0);
      this.scene.add.existing(newCard);
      newCard.setPosition(640, 650); // æ‰‹æœ­ä½ç½®ã‹ã‚‰
      newCard.setDepth(150);

      this.scene.tweens.add({
        targets: newCard,
        x: this.container.x,
        y: this.container.y,
        scaleX: 1,
        scaleY: 1,
        duration: 300,
        ease: 'Power2.easeIn',
        onComplete: () => {
          newCard.destroy();
          this.setCount(this.count + 1);
          resolve();
        },
      });
    });
  }

  setInteractive(enabled: boolean): void {
    if (enabled) {
      this.container.setInteractive();
    } else {
      this.container.disableInteractive();
    }
  }

  setVisible(visible: boolean): void {
    this.container.setVisible(visible);
  }

  destroy(): void {
    this.container.destroy();
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: æšæ•°è¡¨ç¤º ğŸŸ¡

**Given**: DeckViewã‚’ç”Ÿæˆã™ã‚‹
**When**: setCount(20)ã‚’å‘¼ã¶
**Then**: ãƒãƒƒã‚¸ã«"20"ãŒè¡¨ç¤ºã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ã‚¹ã‚¿ãƒƒã‚¯è¡¨ç¤º ğŸŸ¡

**Given**: DeckViewãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: setCount(3)ã‚’å‘¼ã¶
**Then**: 3æšåˆ†ã®ã‚¹ã‚¿ãƒƒã‚¯ãŒè¡¨ç¤ºã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: 0æšæ™‚ã®è¡¨ç¤º ğŸŸ¡

**Given**: DeckViewãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: setCount(0)ã‚’å‘¼ã¶
**Then**: ã‚«ãƒ¼ãƒ‰ã‚¹ã‚¿ãƒƒã‚¯ãŒéè¡¨ç¤ºã«ãªã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0210` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚«ãƒ¼ãƒ‰ã®é‡ãªã‚Šè¡¨ç¾
- ãƒ‰ãƒ­ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®åº§æ¨™è¨ˆç®—
- é€£ç¶šãƒ‰ãƒ­ãƒ¼æ™‚ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 3é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 3é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ª

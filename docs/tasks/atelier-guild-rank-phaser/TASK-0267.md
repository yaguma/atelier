# TASK-0267: ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çµ±åˆãƒ†ã‚¹ãƒˆ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0267
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–ãƒ»ä»•ä¸Šã’
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼**: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¡ä»¶ã¨çµæœè¡¨ç¤ºã®çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚æ—¥æ•°è¶…éã€ã‚´ãƒ¼ãƒ«ãƒ‰æ¯æ¸‡ç­‰ã®ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šã€çµ±è¨ˆè¡¨ç¤ºã€ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0247 (GameOverSceneå®Ÿè£…), TASK-0263 (è¤‡æ•°æ—¥é€²è¡Œãƒ†ã‚¹ãƒˆ)
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0269

## å®Œäº†æ¡ä»¶

- [ ] æ—¥æ•°è¶…éåˆ¤å®šã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] ã‚´ãƒ¼ãƒ«ãƒ‰æ¯æ¸‡åˆ¤å®šã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çµ±è¨ˆè¡¨ç¤ºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹

---

## ãƒ†ã‚¹ãƒˆå®Ÿè£…è©³ç´°

### 1. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase5/GameOverIntegration.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createTestGame, waitForScene, advanceDay } from '../../../utils/phaserTestUtils';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';
import { SceneKeys } from '@/presentation/phaser/config/SceneKeys';

describe('Game Over Integration', () => {
  let game: Phaser.Game;
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;

  beforeEach(async () => {
    const testSetup = await createTestGame();
    game = testSetup.game;
    eventBus = testSetup.eventBus;
    stateManager = game.registry.get('stateManager');

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    eventBus.emit('ui:game:start:requested', { isNewGame: true });
  });

  afterEach(() => {
    game.destroy(true);
  });

  describe('Game Over Condition - Day Limit Exceeded', () => {
    it('30æ—¥ã‚’è¶…ãˆã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'C' }); // Sãƒ©ãƒ³ã‚¯æœªé”

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            reason: expect.stringContaining('æœŸé™'),
          })
        );
      });
    });

    it('æœ€çµ‚æ—¥ã§Sãƒ©ãƒ³ã‚¯æœªé”ã®å ´åˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', async () => {
      // Arrange - å„ãƒ©ãƒ³ã‚¯ã§ãƒ†ã‚¹ãƒˆ
      const nonClearRanks = ['E', 'D', 'C', 'B', 'A'];

      for (const rank of nonClearRanks) {
        const testSetup = await createTestGame();
        const localStateManager = testSetup.game.registry.get('stateManager');
        const localEventBus = testSetup.eventBus;

        localEventBus.emit('ui:game:start:requested', { isNewGame: true });

        localStateManager.updateProgress({ currentDay: 30, maxDay: 30 });
        localStateManager.updatePlayer({ rank });

        const gameOverCallback = vi.fn();
        localEventBus.on('app:game:over', gameOverCallback);

        await advanceDay(testSetup.game, localEventBus);

        expect(gameOverCallback).toHaveBeenCalled();
        testSetup.game.destroy(true);
      }
    });

    it('GameOverSceneã«é·ç§»ã™ã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'B' });

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await waitForScene(game, SceneKeys.GAME_OVER);
      expect(game.scene.isActive(SceneKeys.GAME_OVER)).toBe(true);
    });
  });

  describe('Game Over Condition - Gold Depletion', () => {
    it('ã‚´ãƒ¼ãƒ«ãƒ‰ãŒãƒã‚¤ãƒŠã‚¹ã«ãªã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: -1 });

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act - ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«ãƒã‚§ãƒƒã‚¯
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            reason: expect.stringContaining('æ‰€æŒé‡‘'),
          })
        );
      });
    });

    it('ã‚´ãƒ¼ãƒ«ãƒ‰0ã¯è¨±å®¹ã•ã‚Œã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: 0 });
      stateManager.updateProgress({ currentDay: 1, maxDay: 30 });

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert - ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ã¯ãªã‚‰ãªã„
      await new Promise(resolve => setTimeout(resolve, 500));
      expect(gameOverCallback).not.toHaveBeenCalled();
    });
  });

  describe('Game Over Statistics', () => {
    beforeEach(async () => {
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç›´å‰ã®çŠ¶æ…‹ã‚’è¨­å®š
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({
        rank: 'B',
        exp: 500,
        maxExp: 800,
        gold: 2000,
      });
      stateManager.updateQuests({
        completed: [
          { id: 'q1' }, { id: 'q2' }, { id: 'q3' }, { id: 'q4' }, { id: 'q5' },
        ],
        accepted: [{ id: 'q6' }],
        available: [],
      });
    });

    it('æœ€çµ‚æ—¥æ•°ãŒè¨˜éŒ²ã•ã‚Œã‚‹', async () => {
      // Arrange
      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            stats: expect.objectContaining({
              finalDay: 30,
            }),
          })
        );
      });
    });

    it('æœ€çµ‚ãƒ©ãƒ³ã‚¯ãŒè¨˜éŒ²ã•ã‚Œã‚‹', async () => {
      // Arrange
      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            stats: expect.objectContaining({
              finalRank: 'B',
            }),
          })
        );
      });
    });

    it('å®Œäº†ã—ãŸä¾é ¼æ•°ãŒè¨˜éŒ²ã•ã‚Œã‚‹', async () => {
      // Arrange
      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            stats: expect.objectContaining({
              totalQuests: 5,
            }),
          })
        );
      });
    });

    it('ãƒ—ãƒ¬ã‚¤æ™‚é–“ãŒè¨˜éŒ²ã•ã‚Œã‚‹', async () => {
      // Arrange
      const saveLoadManager = game.registry.get('saveLoadManager');
      saveLoadManager.setPlaytime(1800); // 30åˆ†

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(gameOverCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            stats: expect.objectContaining({
              playTime: expect.any(Number),
            }),
          })
        );
      });
    });
  });

  describe('Game Over Scene', () => {
    beforeEach(async () => {
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'C' });
    });

    it('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç†ç”±ãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Arrange
      eventBus.emit('app:game:over', {
        reason: '30æ—¥ä»¥å†…ã«Sãƒ©ãƒ³ã‚¯ã«åˆ°é”ã§ãã¾ã›ã‚“ã§ã—ãŸ',
        stats: { finalDay: 30, finalRank: 'C' },
      });

      // Act
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Assert
      const gameOverScene = game.scene.getScene(SceneKeys.GAME_OVER);
      expect(gameOverScene.data.get('reason')).toContain('30æ—¥');
    });

    it('çµ±è¨ˆãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Arrange
      const stats = {
        finalDay: 30,
        finalRank: 'C',
        totalQuests: 8,
        totalGold: 1500,
        playTime: 2400,
      };

      eventBus.emit('app:game:over', {
        reason: 'test',
        stats,
      });

      // Act
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Assert
      const gameOverScene = game.scene.getScene(SceneKeys.GAME_OVER);
      expect(gameOverScene.data.get('finalRank')).toBe('C');
      expect(gameOverScene.data.get('finalDay')).toBe(30);
    });

    it('ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ãŒæ©Ÿèƒ½ã™ã‚‹', async () => {
      // Arrange
      await advanceDay(game, eventBus);
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Act
      eventBus.emit('ui:return:title:requested');

      // Assert
      await waitForScene(game, SceneKeys.TITLE);
      expect(game.scene.isActive(SceneKeys.TITLE)).toBe(true);
    });

    it('ãƒªãƒˆãƒ©ã‚¤ãƒœã‚¿ãƒ³ãŒæ©Ÿèƒ½ã™ã‚‹', async () => {
      // Arrange
      await advanceDay(game, eventBus);
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Act
      eventBus.emit('ui:game:restart:requested');

      // Assert
      await waitForScene(game, SceneKeys.MAIN);
      expect(game.scene.isActive(SceneKeys.MAIN)).toBe(true);

      // çŠ¶æ…‹ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹
      const player = stateManager.getPlayerData();
      expect(player.rank).toBe('E');
      expect(stateManager.getProgress().currentDay).toBe(1);
    });

    it('æœ€å¾Œã®ã‚»ãƒ¼ãƒ–ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹', async () => {
      // Arrange - ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
      const saveLoadManager = game.registry.get('saveLoadManager');
      stateManager.updateProgress({ currentDay: 20 });
      stateManager.updatePlayer({ rank: 'B', gold: 3000 });
      await saveLoadManager.save(1);

      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«
      stateManager.updateProgress({ currentDay: 30 });
      stateManager.updatePlayer({ rank: 'C' });
      await advanceDay(game, eventBus);
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Act
      eventBus.emit('ui:game:load:requested', { slotId: 1 });

      // Assert
      await waitForScene(game, SceneKeys.MAIN);
      const progress = stateManager.getProgress();
      expect(progress.currentDay).toBe(20);
    });
  });

  describe('Game Over Reasons', () => {
    it('æ—¥æ•°è¶…éã®ç†ç”±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé©åˆ‡', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'C' });

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        const call = gameOverCallback.mock.calls[0];
        expect(call[0].reason).toMatch(/æœŸé™|30æ—¥|Sãƒ©ãƒ³ã‚¯/);
      });
    });

    it('ã‚´ãƒ¼ãƒ«ãƒ‰æ¯æ¸‡ã®ç†ç”±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé©åˆ‡', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 15 });
      stateManager.updatePlayer({ gold: -100 });

      const gameOverCallback = vi.fn();
      eventBus.on('app:game:over', gameOverCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        const call = gameOverCallback.mock.calls[0];
        expect(call[0].reason).toMatch(/æ‰€æŒé‡‘|ã‚´ãƒ¼ãƒ«ãƒ‰|0/);
      });
    });
  });

  describe('State Reset After Game Over', () => {
    it('ãƒªãƒˆãƒ©ã‚¤å¾Œã«å…¨çŠ¶æ…‹ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 30, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'B', gold: 100, exp: 500 });
      stateManager.updateQuests({
        completed: [{ id: 'q1' }],
        accepted: [{ id: 'q2' }],
        available: [],
      });

      await advanceDay(game, eventBus);
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Act
      eventBus.emit('ui:game:restart:requested');
      await waitForScene(game, SceneKeys.MAIN);

      // Assert
      const player = stateManager.getPlayerData();
      const progress = stateManager.getProgress();
      const quests = stateManager.getQuests();

      expect(player.rank).toBe('E');
      expect(player.gold).toBe(500); // åˆæœŸå€¤
      expect(player.exp).toBe(0);
      expect(progress.currentDay).toBe(1);
      expect(quests.completed.length).toBe(0);
      expect(quests.accepted.length).toBe(0);
    });

    it('ãƒ—ãƒ¬ã‚¤æ™‚é–“ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹', async () => {
      // Arrange
      const saveLoadManager = game.registry.get('saveLoadManager');
      saveLoadManager.setPlaytime(3600);

      stateManager.updateProgress({ currentDay: 30 });
      stateManager.updatePlayer({ rank: 'C' });
      await advanceDay(game, eventBus);
      await waitForScene(game, SceneKeys.GAME_OVER);

      // Act
      eventBus.emit('ui:game:restart:requested');
      await waitForScene(game, SceneKeys.MAIN);

      // Assert
      expect(saveLoadManager.getPlaytime()).toBe(0);
    });
  });

  describe('Warning Before Game Over', () => {
    it('æ®‹ã‚Š5æ—¥ã§è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Arrange
      stateManager.updateProgress({ currentDay: 25, maxDay: 30 });
      stateManager.updatePlayer({ rank: 'C' });

      const warningCallback = vi.fn();
      eventBus.on('app:day:warning', warningCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(warningCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            remainingDays: 4,
          })
        );
      });
    });

    it('ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä½ä¸‹ã™ã‚‹ã¨è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ gold: 50 });

      const warningCallback = vi.fn();
      eventBus.on('app:gold:warning', warningCallback);

      // Act
      await advanceDay(game, eventBus);

      // Assert
      await vi.waitFor(() => {
        expect(warningCallback).toHaveBeenCalled();
      });
    });
  });
});
```

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0267` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| ãƒ†ã‚¹ãƒˆå¯¾è±¡ | ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸ |
|-----------|---------------|
| æ—¥æ•°è¶…éåˆ¤å®š | 100% |
| ã‚´ãƒ¼ãƒ«ãƒ‰æ¯æ¸‡åˆ¤å®š | 100% |
| çµ±è¨ˆè¡¨ç¤º | 95% |
| ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ | 95% |

---

## æ³¨æ„äº‹é …

- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¡ä»¶ã®ç¢ºå®Ÿãªæ¤œå‡º
- çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆã®å®Œå…¨æ€§
- ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã®å¾©å¸°

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 1é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

# TASK-0231: RewardCardSelector設計・実装

**タスクID**: TASK-0231
**タスクタイプ**: TDD
**推定工数**: 4時間
**フェーズ**: Phase 3 - フェーズコンテナ・メイン画面実装
**信頼性レベル**: 🔵 *設計書に記載*

## 関連文書

- **概要**: [overview.md](./overview.md)
- **UI設計**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## タスク概要

依頼納品成功時の報酬カード選択UIを実装する。複数のカードから1枚を選択するダイアログ形式のコンポーネント。

## 依存タスク

- **前提タスク**: TASK-0175, TASK-0194
- **後続タスク**: TASK-0232

## 完了条件

- [ ] IRewardCardSelectorインターフェースが定義されている
- [ ] 報酬カードがダイアログで表示される
- [ ] カードを選択できる
- [ ] 選択確定時にコールバックが呼ばれる
- [ ] カード詳細がホバーで表示される

---

## 実装詳細

### 1. IRewardCardSelectorインターフェース 🔵

**信頼性**: 🔵 *報酬選択設計*

**実装ファイル**: `src/presentation/phaser/ui/reward/IRewardCardSelector.ts`

```typescript
import Phaser from 'phaser';
import { Card } from '../../../../domain/card/Card';

export interface RewardCardSelectorOptions {
  scene: Phaser.Scene;
  x?: number;
  y?: number;
  cards: Card[];
  title?: string;
  onSelect?: (card: Card) => void;
  onCancel?: () => void;
}

export interface IRewardCardSelector {
  readonly container: Phaser.GameObjects.Container;

  // カード設定
  setCards(cards: Card[]): void;
  getCards(): Card[];

  // 選択
  getSelectedCard(): Card | null;
  selectCard(card: Card): void;

  // 操作
  confirm(): void;
  cancel(): void;

  // 表示制御
  show(): void;
  hide(): void;

  // 破棄
  destroy(): void;
}
```

### 2. RewardCardSelector実装 🔵

**信頼性**: 🔵 *報酬カード選択*

**実装ファイル**: `src/presentation/phaser/ui/reward/RewardCardSelector.ts`

```typescript
import Phaser from 'phaser';
import { IRewardCardSelector, RewardCardSelectorOptions } from './IRewardCardSelector';
import { Card } from '../../../../domain/card/Card';
import { CardView } from '../card/CardView';
import { Colors } from '../../config/ColorPalette';
import { TextStyles } from '../../config/TextStyles';

export class RewardCardSelector implements IRewardCardSelector {
  public readonly container: Phaser.GameObjects.Container;

  private scene: Phaser.Scene;
  private cards: Card[] = [];
  private selectedCard: Card | null = null;
  private title: string;

  // UI要素
  private overlay!: Phaser.GameObjects.Graphics;
  private panel!: Phaser.GameObjects.Graphics;
  private titleText!: Phaser.GameObjects.Text;
  private cardViews: CardView[] = [];
  private confirmButton!: Phaser.GameObjects.Container;
  private cancelButton?: Phaser.GameObjects.Container;
  private selectedHighlight?: Phaser.GameObjects.Graphics;

  private onSelect?: (card: Card) => void;
  private onCancel?: () => void;

  constructor(options: RewardCardSelectorOptions) {
    this.scene = options.scene;
    this.cards = options.cards;
    this.title = options.title ?? '🎁 報酬を選択してください';
    this.onSelect = options.onSelect;
    this.onCancel = options.onCancel;

    this.container = this.scene.add.container(0, 0);
    this.container.setDepth(200);

    this.create();
    this.displayCards();
  }

  private create(): void {
    const width = this.scene.cameras.main.width;
    const height = this.scene.cameras.main.height;

    // オーバーレイ
    this.overlay = this.scene.add.graphics();
    this.overlay.fillStyle(0x000000, 0.8);
    this.overlay.fillRect(0, 0, width, height);
    this.container.add(this.overlay);

    // パネル
    const panelWidth = 700;
    const panelHeight = 450;
    const panelX = (width - panelWidth) / 2;
    const panelY = (height - panelHeight) / 2;

    this.panel = this.scene.add.graphics();
    this.panel.fillStyle(Colors.panelBackground, 1);
    this.panel.fillRoundedRect(panelX, panelY, panelWidth, panelHeight, 16);
    this.panel.lineStyle(2, Colors.accent);
    this.panel.strokeRoundedRect(panelX, panelY, panelWidth, panelHeight, 16);
    this.container.add(this.panel);

    // タイトル
    this.titleText = this.scene.add.text(width / 2, panelY + 30, this.title, {
      ...TextStyles.heading,
      fontSize: '22px',
      color: '#ffd700',
    }).setOrigin(0.5, 0);
    this.container.add(this.titleText);

    // サブタイトル
    const subTitle = this.scene.add.text(width / 2, panelY + 65, '1枚を選択してください', {
      ...TextStyles.body,
      fontSize: '14px',
      color: '#aaaaaa',
    }).setOrigin(0.5, 0);
    this.container.add(subTitle);

    // 確定ボタン
    this.confirmButton = this.createButton(
      width / 2 + 80,
      panelY + panelHeight - 50,
      '✅ 選択する',
      () => this.confirm(),
      true
    );
    this.confirmButton.setAlpha(0.5); // 初期は非活性
    this.container.add(this.confirmButton);

    // キャンセルボタン（オプション）
    if (this.onCancel) {
      this.cancelButton = this.createButton(
        width / 2 - 80,
        panelY + panelHeight - 50,
        'キャンセル',
        () => this.cancel(),
        false
      );
      this.container.add(this.cancelButton);
    }

    // 出現アニメーション
    this.container.setAlpha(0);
    this.scene.tweens.add({
      targets: this.container,
      alpha: 1,
      duration: 300,
      ease: 'Power2',
    });
  }

  private createButton(
    x: number,
    y: number,
    text: string,
    onClick: () => void,
    primary: boolean
  ): Phaser.GameObjects.Container {
    const btn = this.scene.add.container(x, y);

    const bg = this.scene.add.graphics();
    const bgColor = primary ? Colors.accent : 0x4a4a6a;
    bg.fillStyle(bgColor, 1);
    bg.fillRoundedRect(-60, -18, 120, 36, 8);
    btn.add(bg);

    const label = this.scene.add.text(0, 0, text, {
      ...TextStyles.body,
      fontSize: '14px',
    }).setOrigin(0.5);
    btn.add(label);

    btn.setInteractive(
      new Phaser.Geom.Rectangle(-60, -18, 120, 36),
      Phaser.Geom.Rectangle.Contains
    );

    btn.on('pointerover', () => {
      bg.clear();
      bg.fillStyle(primary ? 0x7a7aff : 0x6a6a8a, 1);
      bg.fillRoundedRect(-60, -18, 120, 36, 8);
    });

    btn.on('pointerout', () => {
      bg.clear();
      bg.fillStyle(bgColor, 1);
      bg.fillRoundedRect(-60, -18, 120, 36, 8);
    });

    btn.on('pointerdown', onClick);

    return btn;
  }

  private displayCards(): void {
    const width = this.scene.cameras.main.width;
    const height = this.scene.cameras.main.height;
    const startY = height / 2 - 30;

    const cardWidth = 120;
    const cardSpacing = 30;
    const totalWidth = this.cards.length * cardWidth + (this.cards.length - 1) * cardSpacing;
    const startX = (width - totalWidth) / 2 + cardWidth / 2;

    this.cards.forEach((card, index) => {
      const x = startX + index * (cardWidth + cardSpacing);
      const y = startY;

      const cardView = new CardView(this.scene, {
        x: x,
        y: y,
        card: card,
        scale: 0.9,
        interactive: true,
        onClick: () => this.handleCardClick(card, index),
        onHover: () => this.handleCardHover(card, index),
        onHoverOut: () => this.handleCardHoverOut(card, index),
      });

      // 出現アニメーション
      cardView.container.setAlpha(0);
      cardView.container.setY(y + 50);
      this.scene.tweens.add({
        targets: cardView.container,
        alpha: 1,
        y: y,
        duration: 300,
        delay: index * 100,
        ease: 'Back.easeOut',
      });

      this.container.add(cardView.container);
      this.cardViews.push(cardView);
    });
  }

  private handleCardClick(card: Card, index: number): void {
    // 前の選択をクリア
    this.clearSelection();

    // 新しい選択
    this.selectedCard = card;
    this.showSelectionHighlight(index);

    // 確定ボタンを有効化
    this.confirmButton.setAlpha(1);

    // 選択アニメーション
    const cardView = this.cardViews[index];
    this.scene.tweens.add({
      targets: cardView.container,
      y: cardView.container.y - 20,
      scaleX: 1.0,
      scaleY: 1.0,
      duration: 200,
      ease: 'Back.easeOut',
    });
  }

  private handleCardHover(card: Card, index: number): void {
    if (this.selectedCard === card) return;

    const cardView = this.cardViews[index];
    this.scene.tweens.add({
      targets: cardView.container,
      scaleX: 0.95,
      scaleY: 0.95,
      duration: 100,
      ease: 'Power2',
    });
  }

  private handleCardHoverOut(card: Card, index: number): void {
    if (this.selectedCard === card) return;

    const cardView = this.cardViews[index];
    this.scene.tweens.add({
      targets: cardView.container,
      scaleX: 0.9,
      scaleY: 0.9,
      duration: 100,
      ease: 'Power2',
    });
  }

  private clearSelection(): void {
    if (this.selectedHighlight) {
      this.selectedHighlight.destroy();
      this.selectedHighlight = undefined;
    }

    // 前の選択カードを元の位置に戻す
    this.cardViews.forEach((cv, i) => {
      if (this.cards[i] === this.selectedCard) {
        this.scene.tweens.add({
          targets: cv.container,
          y: cv.container.y + 20,
          scaleX: 0.9,
          scaleY: 0.9,
          duration: 200,
        });
      }
    });

    this.selectedCard = null;
  }

  private showSelectionHighlight(index: number): void {
    const cardView = this.cardViews[index];
    const x = cardView.container.x;
    const y = cardView.container.y;

    this.selectedHighlight = this.scene.add.graphics();
    this.selectedHighlight.lineStyle(4, Colors.accent);
    this.selectedHighlight.strokeRoundedRect(x - 65, y - 95, 130, 190, 12);

    // グロー効果
    this.scene.tweens.add({
      targets: this.selectedHighlight,
      alpha: 0.5,
      duration: 500,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut',
    });

    this.container.add(this.selectedHighlight);
  }

  setCards(cards: Card[]): void {
    // 既存のカードビューを破棄
    this.cardViews.forEach(cv => cv.destroy());
    this.cardViews = [];

    this.cards = cards;
    this.selectedCard = null;
    this.displayCards();
  }

  getCards(): Card[] {
    return [...this.cards];
  }

  getSelectedCard(): Card | null {
    return this.selectedCard;
  }

  selectCard(card: Card): void {
    const index = this.cards.indexOf(card);
    if (index >= 0) {
      this.handleCardClick(card, index);
    }
  }

  confirm(): void {
    if (!this.selectedCard) return;

    // 確定アニメーション
    this.scene.tweens.add({
      targets: this.container,
      alpha: 0,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        if (this.onSelect && this.selectedCard) {
          this.onSelect(this.selectedCard);
        }
      },
    });
  }

  cancel(): void {
    this.scene.tweens.add({
      targets: this.container,
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => {
        if (this.onCancel) {
          this.onCancel();
        }
      },
    });
  }

  show(): void {
    this.container.setVisible(true);
    this.container.setAlpha(0);
    this.scene.tweens.add({
      targets: this.container,
      alpha: 1,
      duration: 300,
      ease: 'Power2',
    });
  }

  hide(): void {
    this.scene.tweens.add({
      targets: this.container,
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => this.container.setVisible(false),
    });
  }

  destroy(): void {
    this.cardViews.forEach(cv => cv.destroy());
    this.container.destroy();
  }
}
```

---

## 単体テスト要件

### テストケース1: カード表示 🔵

**Given**: 3枚のカードを設定
**When**: RewardCardSelectorを表示
**Then**: 3枚のカードが表示される

### テストケース2: カード選択 🔵

**Given**: カードが表示されている
**When**: カードをクリック
**Then**: 選択状態になりハイライトされる

### テストケース3: 選択確定 🔵

**Given**: カードが選択されている
**When**: 確定ボタンをクリック
**Then**: onSelectコールバックが選択カードと共に呼ばれる

---

## 実装手順

1. `/tsumiki:tdd-requirements TASK-0231` - 詳細要件定義
2. `/tsumiki:tdd-testcases` - テストケース作成
3. `/tsumiki:tdd-red` - テスト実装（失敗）
4. `/tsumiki:tdd-green` - 最小実装
5. `/tsumiki:tdd-refactor` - リファクタリング
6. `/tsumiki:tdd-verify-complete` - 品質確認

---

## 注意事項

- CardViewの再利用
- モーダルダイアログの深度管理
- キーボード操作対応

---

## 信頼性レベルサマリー

- **総項目数**: 2項目
- 🔵 **青信号**: 2項目 (100%)
- 🟡 **黄信号**: 0項目 (0%)
- 🔴 **赤信号**: 0項目 (0%)

**品質評価**: 高品質

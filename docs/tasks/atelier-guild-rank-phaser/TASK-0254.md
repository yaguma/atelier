# TASK-0254: Applicationå±¤é€£æºãƒ†ã‚¹ãƒˆ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0254
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4 - ã‚µãƒ–ã‚·ãƒ¼ãƒ³ãƒ»Applicationå±¤ä¿®æ­£
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ **: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

EventBus-UseCaseé€£æºã€StateManagerã€GameFlowManagerã®çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0251, TASK-0252, TASK-0253
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0259

## å®Œäº†æ¡ä»¶

- [ ] EventBus-UseCaseé€£æºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] StateManagerçŠ¶æ…‹åŒæœŸã®ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] GameFlowManagerãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã®ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] UI-Applicationå±¤é–“ã®åŒæ–¹å‘é€šä¿¡ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. EventBus-UseCaseé€£æºãƒ†ã‚¹ãƒˆ ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/application/EventBusUseCaseIntegration.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { EventBusAdapter } from '@/presentation/phaser/events/EventBusAdapter';
import { GameUseCaseHandler } from '@/presentation/phaser/application/GameUseCaseHandler';
import { createMockUseCases } from '@tests/utils/mockUseCases';

describe('EventBus-UseCaseé€£æº', () => {
  let eventBus: EventBus;
  let adapter: EventBusAdapter;
  let handler: GameUseCaseHandler;
  let mockUseCases: ReturnType<typeof createMockUseCases>;

  beforeEach(() => {
    eventBus = new EventBus();
    adapter = new EventBusAdapter(eventBus);
    mockUseCases = createMockUseCases();
    handler = new GameUseCaseHandler(adapter, mockUseCases);
  });

  describe('ä¾é ¼å—æ³¨ãƒ•ãƒ­ãƒ¼', () => {
    it('UIã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰UseCaseãŒå‘¼ã°ã‚Œã‚‹', async () => {
      mockUseCases.questUseCase.acceptQuest.mockResolvedValue({
        quest: { id: 'quest1', name: 'ãƒ†ã‚¹ãƒˆä¾é ¼' },
        acceptedQuests: [],
      });

      eventBus.emit('quest:accept:request', { questId: 'quest1' });

      await vi.waitFor(() => {
        expect(mockUseCases.questUseCase.acceptQuest).toHaveBeenCalledWith('quest1');
      });
    });

    it('UseCaseå®Œäº†å¾Œã«UIã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      const quest = { id: 'quest1', name: 'ãƒ†ã‚¹ãƒˆä¾é ¼' };
      mockUseCases.questUseCase.acceptQuest.mockResolvedValue({
        quest,
        acceptedQuests: [quest],
      });

      const acceptedHandler = vi.fn();
      eventBus.on('quest:accepted', acceptedHandler);

      eventBus.emit('quest:accept:request', { questId: 'quest1' });

      await vi.waitFor(() => {
        expect(acceptedHandler).toHaveBeenCalledWith({
          quest,
          acceptedQuests: [quest],
        });
      });
    });
  });

  describe('æ¡å–ãƒ•ãƒ­ãƒ¼', () => {
    it('æ¡å–å®Ÿè¡ŒãŒUseCaseã«ä¼é”ã•ã‚Œã‚‹', async () => {
      mockUseCases.gatheringUseCase.executeGathering.mockResolvedValue({
        materials: [{ id: 'mat1', name: 'è–¬è‰' }],
        apUsed: 1,
        remainingAp: 2,
      });

      eventBus.emit('gathering:execute:request', {
        cardId: 'card1',
        selectedMaterialIds: ['mat1'],
      });

      await vi.waitFor(() => {
        expect(mockUseCases.gatheringUseCase.executeGathering).toHaveBeenCalledWith(
          'card1',
          ['mat1']
        );
      });
    });

    it('æ¡å–å®Œäº†å¾Œã«ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      mockUseCases.gatheringUseCase.executeGathering.mockResolvedValue({
        materials: [{ id: 'mat1', name: 'è–¬è‰' }],
        apUsed: 1,
        remainingAp: 2,
      });

      const inventoryHandler = vi.fn();
      eventBus.on('inventory:updated', inventoryHandler);

      eventBus.emit('gathering:execute:request', {
        cardId: 'card1',
        selectedMaterialIds: ['mat1'],
      });

      await vi.waitFor(() => {
        expect(inventoryHandler).toHaveBeenCalled();
      });
    });
  });

  describe('èª¿åˆãƒ•ãƒ­ãƒ¼', () => {
    it('èª¿åˆãŒUseCaseã«ä¼é”ã•ã‚Œã‚‹', async () => {
      mockUseCases.alchemyUseCase.craft.mockResolvedValue({
        item: { id: 'item1', name: 'ãƒ’ãƒ¼ãƒ«ãƒãƒ¼ã‚·ãƒ§ãƒ³' },
        quality: 50,
        traits: [],
        success: true,
      });

      eventBus.emit('alchemy:craft:request', {
        recipeCardId: 'recipe1',
        materialIds: ['mat1', 'mat2'],
      });

      await vi.waitFor(() => {
        expect(mockUseCases.alchemyUseCase.craft).toHaveBeenCalledWith(
          'recipe1',
          ['mat1', 'mat2']
        );
      });
    });
  });

  describe('ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°', () => {
    it('UseCaseå¤±æ•—æ™‚ã«ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹', async () => {
      mockUseCases.questUseCase.acceptQuest.mockRejectedValue(
        new Error('ä¾é ¼æ ãŒã„ã£ã±ã„ã§ã™')
      );

      const errorHandler = vi.fn();
      eventBus.on('error:occurred', errorHandler);

      eventBus.emit('quest:accept:request', { questId: 'quest1' });

      await vi.waitFor(() => {
        expect(errorHandler).toHaveBeenCalledWith({
          code: 'quest:accept',
          message: 'ä¾é ¼æ ãŒã„ã£ã±ã„ã§ã™',
          recoverable: true,
        });
      });
    });
  });
});
```

### 2. StateManagerçµ±åˆãƒ†ã‚¹ãƒˆ ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *çŠ¶æ…‹åŒæœŸ*

```typescript
// tests/integration/state/StateManagerIntegration.test.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';

describe('StateManagerçµ±åˆ', () => {
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;

  beforeEach(() => {
    eventBus = new EventBus();
    stateManager = new PhaserStateManager(eventBus);
  });

  describe('çŠ¶æ…‹æ›´æ–°â†’EventBusé€šçŸ¥', () => {
    it('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°ã§EventBusã«é€šçŸ¥ã•ã‚Œã‚‹', () => {
      const handler = vi.fn();
      eventBus.on('app:player:data:updated', handler);

      stateManager.updatePlayer({ gold: 1000 });

      expect(handler).toHaveBeenCalledWith(
        expect.objectContaining({ gold: 1000 })
      );
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´ã§EventBusã«é€šçŸ¥ã•ã‚Œã‚‹', () => {
      const handler = vi.fn();
      eventBus.on('app:phase:changed', handler);

      stateManager.updateProgress({ currentPhase: 'gathering' });

      expect(handler).toHaveBeenCalledWith({
        phase: 'gathering',
        previousPhase: 'quest-accept',
      });
    });

    it('ä¾é ¼æ›´æ–°ã§EventBusã«é€šçŸ¥ã•ã‚Œã‚‹', () => {
      const availableHandler = vi.fn();
      const acceptedHandler = vi.fn();
      eventBus.on('app:quests:available:updated', availableHandler);
      eventBus.on('app:quests:accepted:updated', acceptedHandler);

      const newQuest = { id: 'quest1', name: 'ãƒ†ã‚¹ãƒˆ' };
      stateManager.updateQuests({
        available: [newQuest],
        accepted: [],
      });

      expect(availableHandler).toHaveBeenCalledWith({
        quests: [newQuest],
      });
      expect(acceptedHandler).toHaveBeenCalled();
    });

    it('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ›´æ–°ã§EventBusã«é€šçŸ¥ã•ã‚Œã‚‹', () => {
      const handler = vi.fn();
      eventBus.on('app:inventory:updated', handler);

      const material = { id: 'mat1', name: 'è–¬è‰', quantity: 5 };
      stateManager.updateInventory({
        materials: [material],
      });

      expect(handler).toHaveBeenCalledWith(
        expect.objectContaining({
          items: expect.arrayContaining([material]),
        })
      );
    });

    it('ãƒ‡ãƒƒã‚­æ›´æ–°ã§EventBusã«é€šçŸ¥ã•ã‚Œã‚‹', () => {
      const handHandler = vi.fn();
      const deckHandler = vi.fn();
      eventBus.on('app:hand:updated', handHandler);
      eventBus.on('app:deck:updated', deckHandler);

      const card = { id: 'card1', name: 'ãƒ†ã‚¹ãƒˆã‚«ãƒ¼ãƒ‰' };
      stateManager.updateDeck({
        cards: [card, card],
        hand: [card],
        discard: [],
      });

      expect(handHandler).toHaveBeenCalledWith({ cards: [card] });
      expect(deckHandler).toHaveBeenCalledWith({
        deckCount: 2,
        discardCount: 0,
      });
    });
  });

  describe('ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º', () => {
    it('çŠ¶æ…‹ã‚’æ­£ã—ãã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã§ãã‚‹', () => {
      stateManager.updatePlayer({ gold: 1500, rank: 'D' });
      stateManager.updateProgress({ currentDay: 5 });

      const serialized = stateManager.serialize();
      const parsed = JSON.parse(serialized);

      expect(parsed.player.gold).toBe(1500);
      expect(parsed.player.rank).toBe('D');
      expect(parsed.progress.currentDay).toBe(5);
    });

    it('çŠ¶æ…‹ã‚’æ­£ã—ããƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã§ãã‚‹', () => {
      const saveData = JSON.stringify({
        player: { rank: 'C', exp: 50, maxExp: 100, gold: 2000, ap: { current: 2, max: 4 } },
        progress: { currentDay: 10, maxDay: 30, currentPhase: 'alchemy' },
        quests: { available: [], accepted: [], completed: [] },
        inventory: { materials: [], craftedItems: [], artifacts: [] },
        deck: { cards: [], hand: [], discard: [] },
      });

      stateManager.deserialize(saveData);

      expect(stateManager.getPlayerData().rank).toBe('C');
      expect(stateManager.getProgress().currentDay).toBe(10);
    });
  });
});
```

### 3. GameFlowManagerçµ±åˆãƒ†ã‚¹ãƒˆ ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡*

```typescript
// tests/integration/flow/GameFlowManagerIntegration.test.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';
import { PhaserGameFlowManager } from '@/presentation/phaser/flow/PhaserGameFlowManager';
import { createMockSceneManager } from '@tests/utils/mockSceneManager';

describe('GameFlowManagerçµ±åˆ', () => {
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;
  let sceneManager: any;
  let flowManager: PhaserGameFlowManager;

  beforeEach(() => {
    eventBus = new EventBus();
    stateManager = new PhaserStateManager(eventBus);
    sceneManager = createMockSceneManager();
    flowManager = new PhaserGameFlowManager(eventBus, sceneManager, stateManager);
  });

  describe('ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ', () => {
    it('ãƒ•ã‚§ãƒ¼ã‚ºãŒé †ç•ªã«é€²ã‚€', async () => {
      expect(flowManager.getCurrentPhase()).toBe('quest-accept');

      await flowManager.advancePhase();
      expect(flowManager.getCurrentPhase()).toBe('gathering');

      await flowManager.advancePhase();
      expect(flowManager.getCurrentPhase()).toBe('alchemy');

      await flowManager.advancePhase();
      expect(flowManager.getCurrentPhase()).toBe('delivery');
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´æ™‚ã«EventBusã«é€šçŸ¥ã•ã‚Œã‚‹', async () => {
      const handler = vi.fn();
      eventBus.on('app:phase:changed', handler);

      await flowManager.advancePhase();

      expect(handler).toHaveBeenCalledWith({
        phase: 'gathering',
        previousPhase: 'quest-accept',
      });
    });

    it('ã‚¹ã‚­ãƒƒãƒ—å¯èƒ½ãªãƒ•ã‚§ãƒ¼ã‚ºã‚’ã‚¹ã‚­ãƒƒãƒ—ã§ãã‚‹', async () => {
      await flowManager.skipPhase('quest-accept');

      expect(flowManager.getCurrentPhase()).toBe('gathering');
    });
  });

  describe('ã‚¿ãƒ¼ãƒ³çµ‚äº†', () => {
    it('deliveryãƒ•ã‚§ãƒ¼ã‚ºå¾Œã«ã‚¿ãƒ¼ãƒ³ãŒçµ‚äº†ã™ã‚‹', async () => {
      // deliveryã¾ã§é€²ã‚ã‚‹
      stateManager.updateProgress({ currentPhase: 'delivery' });

      const dayEndHandler = vi.fn();
      eventBus.on('app:day:ended', dayEndHandler);

      await flowManager.advancePhase();

      expect(dayEndHandler).toHaveBeenCalled();
      expect(stateManager.getProgress().currentDay).toBe(2);
      expect(flowManager.getCurrentPhase()).toBe('quest-accept');
    });

    it('APå›å¾©ãŒã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«è¡Œã‚ã‚Œã‚‹', async () => {
      stateManager.updatePlayer({ ap: { current: 0, max: 3 } });
      stateManager.updateProgress({ currentPhase: 'delivery' });

      await flowManager.advancePhase();

      const player = stateManager.getPlayerData();
      expect(player.ap.current).toBe(player.ap.max);
    });
  });

  describe('ã‚²ãƒ¼ãƒ çµ‚äº†åˆ¤å®š', () => {
    it('æ—¥æ•°è¶…éã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', async () => {
      stateManager.updateProgress({
        currentDay: 30,
        maxDay: 30,
        currentPhase: 'delivery',
      });

      const gameOverHandler = vi.fn();
      eventBus.on('app:game:over', gameOverHandler);

      await flowManager.advancePhase();

      expect(gameOverHandler).toHaveBeenCalledWith(
        expect.objectContaining({
          reason: expect.stringContaining('æœŸé™åˆ‡ã‚Œ'),
        })
      );
      expect(sceneManager.switchTo).toHaveBeenCalledWith(
        'GameOverScene',
        expect.anything()
      );
    });

    it('Sç´šåˆ°é”ã§ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢', async () => {
      stateManager.updatePlayer({ rank: 'S' });
      stateManager.updateProgress({ currentPhase: 'delivery' });

      const gameClearHandler = vi.fn();
      eventBus.on('app:game:clear', gameClearHandler);

      await flowManager.advancePhase();

      expect(gameClearHandler).toHaveBeenCalled();
      expect(sceneManager.switchTo).toHaveBeenCalledWith(
        'GameClearScene',
        expect.anything()
      );
    });
  });

  describe('æ–°è¦ã‚²ãƒ¼ãƒ ', () => {
    it('æ–°è¦ã‚²ãƒ¼ãƒ é–‹å§‹ã§çŠ¶æ…‹ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹', async () => {
      stateManager.updatePlayer({ gold: 9999, rank: 'A' });
      stateManager.updateProgress({ currentDay: 25 });

      await flowManager.startNewGame();

      const player = stateManager.getPlayerData();
      const progress = stateManager.getProgress();

      expect(player.gold).toBe(500);
      expect(player.rank).toBe('E');
      expect(progress.currentDay).toBe(1);
    });

    it('æ–°è¦ã‚²ãƒ¼ãƒ é–‹å§‹ã§ãƒ¡ã‚¤ãƒ³ã‚·ãƒ¼ãƒ³ã«é·ç§»', async () => {
      await flowManager.startNewGame();

      expect(sceneManager.switchTo).toHaveBeenCalledWith('MainScene');
    });
  });
});
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ ğŸŸ¡

- EventBus-UseCaseé€£æº: 100%
- StateManagerçŠ¶æ…‹åŒæœŸ: 100%
- GameFlowManagerãƒ•ãƒ­ãƒ¼åˆ¶å¾¡: 100%
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°: 100%

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0254` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ãƒ¢ãƒƒã‚¯ã®é©åˆ‡ãªè¨­è¨ˆ
- éåŒæœŸå‡¦ç†ã®ãƒ†ã‚¹ãƒˆæ–¹æ³•
- ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«é †åºã®æ¤œè¨¼

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 3é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 3é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ªï¼ˆå®Ÿè£…æ™‚ã«èª¿æ•´è¦ï¼‰

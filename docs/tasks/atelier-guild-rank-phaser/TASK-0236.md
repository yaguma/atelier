# TASK-0236: MainSceneãƒ•ã‚§ãƒ¼ã‚ºåˆ‡æ›¿æ©Ÿèƒ½å®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0236
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 3 - ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠãƒ»ãƒ¡ã‚¤ãƒ³ç”»é¢å®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

MainSceneã®ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠåˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚å„ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã®ç”Ÿæˆã€è¡¨ç¤ºã€éè¡¨ç¤ºã€ç ´æ£„ã‚’ç®¡ç†ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0235, TASK-0213
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0237

## å®Œäº†æ¡ä»¶

- [ ] ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠã‚’å‹•çš„ã«ç”Ÿæˆã§ãã‚‹
- [ ] ãƒ•ã‚§ãƒ¼ã‚ºé–“ã®é·ç§»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹
- [ ] å‰ã®ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠãŒé©åˆ‡ã«ç ´æ£„ã•ã‚Œã‚‹
- [ ] ãƒ•ã‚§ãƒ¼ã‚ºã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã¨åŒæœŸã—ã¦ã„ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒ³ãƒ†ãƒŠç®¡ç† ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ã‚³ãƒ³ãƒ†ãƒŠç®¡ç†*

```typescript
// MainSceneã«è¿½åŠ 

import { IPhaseContainer } from '../ui/phase/IPhaseContainer';
import { QuestAcceptContainer } from '../ui/phase/QuestAcceptContainer';
import { GatheringContainer } from '../ui/phase/GatheringContainer';
import { AlchemyContainer } from '../ui/phase/AlchemyContainer';
import { DeliveryContainer } from '../ui/phase/DeliveryContainer';

type PhaseType = 'quest-accept' | 'gathering' | 'alchemy' | 'delivery';

interface PhaseContainerInfo {
  type: PhaseType;
  container: IPhaseContainer | null;
  isActive: boolean;
}

private phaseContainers: Map<PhaseType, PhaseContainerInfo> = new Map();
private activePhase: PhaseType | null = null;

private initPhaseContainers(): void {
  const phases: PhaseType[] = ['quest-accept', 'gathering', 'alchemy', 'delivery'];

  phases.forEach(phase => {
    this.phaseContainers.set(phase, {
      type: phase,
      container: null,
      isActive: false,
    });
  });
}

private createPhaseContainer(phase: PhaseType): IPhaseContainer {
  const bounds = this.getMainAreaBounds();
  const options = {
    scene: this,
    eventBus: this.eventBus,
    x: bounds.x,
    y: bounds.y,
  };

  switch (phase) {
    case 'quest-accept':
      return new QuestAcceptContainer({
        ...options,
        onQuestAccepted: (quest) => this.handleQuestAccepted(quest),
        onSkip: () => this.handlePhaseComplete('quest-accept'),
      });

    case 'gathering':
      return new GatheringContainer({
        ...options,
        onGatheringComplete: (result) => this.handleGatheringComplete(result),
        onSkip: () => this.handlePhaseComplete('gathering'),
      });

    case 'alchemy':
      return new AlchemyContainer({
        ...options,
        onAlchemyComplete: (result) => this.handleAlchemyComplete(result),
        onSkip: () => this.handlePhaseComplete('alchemy'),
      });

    case 'delivery':
      return new DeliveryContainer({
        ...options,
        onDeliveryComplete: (result) => this.handleDeliveryComplete(result),
        onSkip: () => this.handlePhaseComplete('delivery'),
      });

    default:
      throw new Error(`Unknown phase: ${phase}`);
  }
}
```

### 2. ãƒ•ã‚§ãƒ¼ã‚ºé·ç§» ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *é·ç§»åˆ¶å¾¡*

```typescript
// MainSceneã«è¿½åŠ 

async switchToPhase(newPhase: PhaseType): Promise<void> {
  if (this.activePhase === newPhase) return;

  const previousPhase = this.activePhase;

  // å‰ã®ãƒ•ã‚§ãƒ¼ã‚ºã‚’é€€å‡º
  if (previousPhase) {
    await this.exitPhase(previousPhase);
  }

  // æ–°ã—ã„ãƒ•ã‚§ãƒ¼ã‚ºã«å…¥ã‚‹
  await this.enterPhase(newPhase);

  // ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°
  this.phaseIndicator.setCurrentPhase(newPhase);

  // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
  this.eventBus.emit('phase:changed', {
    previousPhase,
    newPhase,
  });
}

private async exitPhase(phase: PhaseType): Promise<void> {
  const info = this.phaseContainers.get(phase);
  if (!info || !info.container) return;

  // é€€å‡ºå‡¦ç†
  info.container.exit();

  // é€€å‡ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  await this.playPhaseExitAnimation(info.container);

  // ã‚³ãƒ³ãƒ†ãƒŠç ´æ£„
  info.container.destroy();
  info.container = null;
  info.isActive = false;
}

private async enterPhase(phase: PhaseType): Promise<void> {
  // ã‚³ãƒ³ãƒ†ãƒŠä½œæˆ
  const container = this.createPhaseContainer(phase);

  // æƒ…å ±æ›´æ–°
  const info = this.phaseContainers.get(phase)!;
  info.container = container;
  info.isActive = true;
  this.activePhase = phase;

  // ãƒ•ã‚§ãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿è¨­å®š
  this.setupPhaseData(phase, container);

  // å…¥å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  await this.playPhaseEnterAnimation(container);

  // å…¥å ´å‡¦ç†
  container.enter();
}

private setupPhaseData(phase: PhaseType, container: IPhaseContainer): void {
  // ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®ãƒ‡ãƒ¼ã‚¿è¨­å®š
  // Applicationå±¤ã‹ã‚‰å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
  switch (phase) {
    case 'quest-accept':
      const questContainer = container as QuestAcceptContainer;
      // questContainer.setAvailableQuests(this.gameData.availableQuests);
      break;

    case 'gathering':
      const gatheringContainer = container as GatheringContainer;
      // gatheringContainer.setCurrentAP(...);
      break;

    case 'alchemy':
      const alchemyContainer = container as AlchemyContainer;
      // alchemyContainer.setRecipeCards(...);
      break;

    case 'delivery':
      const deliveryContainer = container as DeliveryContainer;
      // deliveryContainer.setAcceptedQuests(...);
      break;
  }
}
```

### 3. é·ç§»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *è¦–è¦šåŠ¹æœ*

```typescript
// MainSceneã«è¿½åŠ 

private async playPhaseExitAnimation(container: IPhaseContainer): Promise<void> {
  return new Promise((resolve) => {
    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ + å·¦ã«ã‚¹ãƒ©ã‚¤ãƒ‰
    this.tweens.add({
      targets: container.container,
      alpha: 0,
      x: container.container.x - 50,
      duration: 250,
      ease: 'Power2.easeIn',
      onComplete: () => resolve(),
    });
  });
}

private async playPhaseEnterAnimation(container: IPhaseContainer): Promise<void> {
  return new Promise((resolve) => {
    // åˆæœŸçŠ¶æ…‹
    container.container.setAlpha(0);
    container.container.setX(container.container.x + 50);

    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ + å³ã‹ã‚‰ã‚¹ãƒ©ã‚¤ãƒ‰
    this.tweens.add({
      targets: container.container,
      alpha: 1,
      x: container.container.x - 50,
      duration: 300,
      ease: 'Power2.easeOut',
      onComplete: () => resolve(),
    });
  });
}
```

### 4. ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ãƒãƒ³ãƒ‰ãƒ© ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†*

```typescript
// MainSceneã«è¿½åŠ 

private handleQuestAccepted(quest: any): void {
  this.eventBus.emit('game:quest:accepted', { quest });
  // ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã§æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã¸é·ç§»ã™ã‚‹ã‹åˆ¤æ–­
}

private handleGatheringComplete(result: any): void {
  this.eventBus.emit('game:gathering:complete', result);
  // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ›´æ–°ã€APæ¶ˆè²»ãªã©ã®å‡¦ç†å¾Œã«æ¬¡ãƒ•ã‚§ãƒ¼ã‚ºã¸
}

private handleAlchemyComplete(result: any): void {
  this.eventBus.emit('game:alchemy:complete', result);
  // èª¿åˆã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ ãªã©ã®å‡¦ç†å¾Œã«æ¬¡ãƒ•ã‚§ãƒ¼ã‚ºã¸
}

private handleDeliveryComplete(result: any): void {
  this.eventBus.emit('game:delivery:complete', result);
  // å ±é…¬ä»˜ä¸ãªã©ã®å‡¦ç†å¾Œã«æ¬¡ãƒ•ã‚§ãƒ¼ã‚ºã¸
}

private handlePhaseComplete(phase: PhaseType): void {
  this.eventBus.emit('game:phase:complete', { phase });
  // ã‚¹ã‚­ãƒƒãƒ—æ™‚ã®å‡¦ç†
}

// å¤–éƒ¨ã‹ã‚‰ã®ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»æŒ‡ç¤ºã‚’å—ã‘ä»˜ã‘
setupPhaseNavigationListeners(): void {
  this.eventBus.on('navigate:phase', (data: { phase: PhaseType }) => {
    this.switchToPhase(data.phase);
  });

  this.eventBus.on('navigate:next-phase', () => {
    const nextPhase = this.getNextPhase(this.activePhase!);
    if (nextPhase) {
      this.switchToPhase(nextPhase);
    }
  });
}

private getNextPhase(current: PhaseType): PhaseType | null {
  const order: PhaseType[] = ['quest-accept', 'gathering', 'alchemy', 'delivery'];
  const index = order.indexOf(current);
  return index < order.length - 1 ? order[index + 1] : null;
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡æ›¿ ğŸŸ¡

**Given**: quest-acceptãƒ•ã‚§ãƒ¼ã‚ºãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: switchToPhase('gathering')ã‚’å‘¼ã¶
**Then**: gatheringãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»ã™ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: å‰ãƒ•ã‚§ãƒ¼ã‚ºç ´æ£„ ğŸŸ¡

**Given**: gatheringãƒ•ã‚§ãƒ¼ã‚ºãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: alchemyãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»
**Then**: gatheringã‚³ãƒ³ãƒ†ãƒŠãŒç ´æ£„ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: ã‚¤ãƒ™ãƒ³ãƒˆç™ºç« ğŸŸ¡

**Given**: MainSceneãŒã‚ã‚‹
**When**: ãƒ•ã‚§ãƒ¼ã‚ºãŒå¤‰ã‚ã‚‹
**Then**: phase:changedã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã™ã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0236` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- éåŒæœŸé·ç§»ä¸­ã®æ“ä½œåˆ¶é™
- ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ï¼ˆã‚³ãƒ³ãƒ†ãƒŠç ´æ£„ï¼‰
- Applicationå±¤ã¨ã®é€£æºè¨­è¨ˆ

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 4é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 4é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ªï¼ˆå®Ÿè£…æ™‚ã«è©³ç´°ç¢ºèªè¦ï¼‰

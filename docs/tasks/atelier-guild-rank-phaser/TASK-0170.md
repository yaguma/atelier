# TASK-0170: SceneManageré·ç§»æ©Ÿèƒ½å®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0170
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 1 - PhaseråŸºç›¤ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©æ§‹ç¯‰
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬ã«åŸºã¥ã*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ **: [core-systems.md](../../design/atelier-guild-rank-phaser/core-systems.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

SceneManagerã®åŸºæœ¬ã‚·ãƒ¼ãƒ³é·ç§»æ©Ÿèƒ½ï¼ˆgoToã€replaceã€goBackï¼‰ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0169
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0171, TASK-0185, TASK-0240, TASK-0244, TASK-0247, TASK-0248, TASK-0253

## å®Œäº†æ¡ä»¶

- [ ] goTo()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [ ] replace()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [ ] goBack()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹
- [ ] é·ç§»ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰ãŒå‹•ä½œã™ã‚‹
- [ ] é·ç§»å±¥æ­´ãŒæ­£ã—ãç®¡ç†ã•ã‚Œã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. SceneManageråŸºæœ¬å®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *Phaserã®ã‚·ãƒ¼ãƒ³ç®¡ç†APIã‚’ä½¿ç”¨*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/managers/SceneManager.ts`

```typescript
import Phaser from 'phaser';
import { ISceneManager } from './ISceneManager';
import { SceneKey } from '../config/SceneKeys';
import {
  TransitionConfig,
  DefaultTransitions,
  SceneTransitionData
} from './SceneTransition';
import { EventBus } from '../events/EventBus';

export class SceneManager implements ISceneManager {
  private static instance: SceneManager | null = null;
  private game: Phaser.Game | null = null;
  private currentScene: SceneKey | null = null;
  private history: SceneTransitionData[] = [];
  private transitioning = false;
  private openOverlays: Set<SceneKey> = new Set();
  private eventBus: EventBus;

  private constructor() {
    this.eventBus = EventBus.getInstance();
  }

  public static getInstance(): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager();
    }
    return SceneManager.instance;
  }

  public static resetInstance(): void {
    SceneManager.instance = null;
  }

  public setGame(game: Phaser.Game): void {
    this.game = game;
  }

  getCurrentScene(): SceneKey {
    if (!this.currentScene) {
      throw new Error('No current scene');
    }
    return this.currentScene;
  }

  async goTo(
    sceneKey: SceneKey,
    data?: Record<string, unknown>,
    transition: TransitionConfig = DefaultTransitions.standard
  ): Promise<void> {
    if (this.transitioning || !this.game) return;

    const from = this.currentScene;
    this.transitioning = true;

    this.eventBus.emit('scene:transition:start' as any, { from, to: sceneKey });

    // å±¥æ­´ã«è¿½åŠ 
    if (from) {
      this.history.push({
        from,
        to: sceneKey,
        transition,
        data,
      });
    }

    await this.performTransition(from, sceneKey, data, transition);

    this.currentScene = sceneKey;
    this.transitioning = false;

    this.eventBus.emit('scene:transition:complete' as any, { from, to: sceneKey });
  }

  async replace(
    sceneKey: SceneKey,
    data?: Record<string, unknown>,
    transition: TransitionConfig = DefaultTransitions.standard
  ): Promise<void> {
    if (this.transitioning || !this.game) return;

    const from = this.currentScene;
    this.transitioning = true;

    // å±¥æ­´ã«ã¯è¿½åŠ ã—ãªã„ï¼ˆreplaceï¼‰

    await this.performTransition(from, sceneKey, data, transition);

    this.currentScene = sceneKey;
    this.transitioning = false;
  }

  async goBack(
    transition: TransitionConfig = DefaultTransitions.standard
  ): Promise<boolean> {
    if (this.history.length === 0) return false;

    const lastTransition = this.history.pop()!;
    await this.replace(lastTransition.from, undefined, transition);
    return true;
  }

  getHistory(): SceneTransitionData[] {
    return [...this.history];
  }

  clearHistory(): void {
    this.history = [];
  }

  isTransitioning(): boolean {
    return this.transitioning;
  }

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤é–¢é€£ã¯TASK-0171ã§å®Ÿè£…
  openOverlay(): Promise<void> { throw new Error('Not implemented'); }
  closeOverlay(): Promise<void> { throw new Error('Not implemented'); }
  closeAllOverlays(): Promise<void> { throw new Error('Not implemented'); }
  isOverlayOpen(): boolean { return false; }
  getOpenOverlays(): SceneKey[] { return []; }

  // é·ç§»å‡¦ç†
  private async performTransition(
    from: SceneKey | null,
    to: SceneKey,
    data?: Record<string, unknown>,
    transition?: TransitionConfig
  ): Promise<void> {
    if (!this.game) return;

    const scenePlugin = this.game.scene;

    if (transition?.type === 'fade' && transition.duration > 0) {
      // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
      const currentScene = from ? scenePlugin.getScene(from) : null;
      if (currentScene) {
        await this.fadeOut(currentScene, transition.duration / 2);
      }

      // ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
      if (from) {
        scenePlugin.stop(from);
      }
      scenePlugin.start(to, data);

      // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
      const newScene = scenePlugin.getScene(to);
      if (newScene) {
        await this.fadeIn(newScene, transition.duration / 2);
      }
    } else {
      // å³æ™‚é·ç§»
      if (from) {
        scenePlugin.stop(from);
      }
      scenePlugin.start(to, data);
    }
  }

  private fadeOut(scene: Phaser.Scene, duration: number): Promise<void> {
    return new Promise(resolve => {
      scene.cameras.main.fadeOut(duration, 0, 0, 0);
      scene.cameras.main.once('camerafadeoutcomplete', resolve);
    });
  }

  private fadeIn(scene: Phaser.Scene, duration: number): Promise<void> {
    return new Promise(resolve => {
      scene.cameras.main.fadeIn(duration, 0, 0, 0);
      scene.cameras.main.once('camerafadeincomplete', resolve);
    });
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: goToåŸºæœ¬å‹•ä½œ ğŸŸ¡

**Given**: SceneManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚‹
**When**: goTo('TitleScene')ã‚’å‘¼ã¶
**Then**: currentSceneãŒTitleSceneã«ãªã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: å±¥æ­´ç®¡ç† ğŸŸ¡

**Given**: TitleScene â†’ MainSceneã¨é·ç§»ã—ãŸ
**When**: getHistory()ã‚’å‘¼ã¶
**Then**: å±¥æ­´ã«1ä»¶ã®é·ç§»è¨˜éŒ²ãŒã‚ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: goBack ğŸŸ¡

**Given**: é·ç§»å±¥æ­´ãŒã‚ã‚‹
**When**: goBack()ã‚’å‘¼ã¶
**Then**: å‰ã®ã‚·ãƒ¼ãƒ³ã«æˆ»ã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹4: replace ğŸŸ¡

**Given**: TitleSceneã«ã„ã‚‹
**When**: replace('MainScene')ã‚’å‘¼ã¶
**Then**: å±¥æ­´ã«è¿½åŠ ã•ã‚ŒãšMainSceneã«é·ç§»ã™ã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0170` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- é·ç§»ä¸­ã®é‡è¤‡é·ç§»è¦æ±‚ã‚’ãƒ–ãƒ­ãƒƒã‚¯
- ãƒ•ã‚§ãƒ¼ãƒ‰å‡¦ç†ã¯éåŒæœŸã§å®Œäº†ã‚’å¾…ã¤
- å±¥æ­´ã®æœ€å¤§ã‚µã‚¤ã‚ºåˆ¶é™ã‚’æ¤œè¨

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 1é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ª

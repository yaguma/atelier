# TASK-0262: 1ã‚¿ãƒ¼ãƒ³ã‚µã‚¤ã‚¯ãƒ«çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆå¾ŒåŠï¼‰

**ã‚¿ã‚¹ã‚¯ID**: TASK-0262
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–ãƒ»ä»•ä¸Šã’
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**: [dataflow.md](../../design/atelier-guild-rank-phaser/dataflow.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

1ã‚¿ãƒ¼ãƒ³ï¼ˆ1æ—¥ï¼‰ã®ã‚²ãƒ¼ãƒ ã‚µã‚¤ã‚¯ãƒ«ã®å¾ŒåŠéƒ¨åˆ†ï¼ˆèª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã€ç´å“ãƒ•ã‚§ãƒ¼ã‚ºï¼‰ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0230 (AlchemyContainerãƒ†ã‚¹ãƒˆ), TASK-0234 (DeliveryContainerãƒ†ã‚¹ãƒˆ)
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0263

## å®Œäº†æ¡ä»¶

- [x] èª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [x] ç´å“ãƒ•ã‚§ãƒ¼ã‚ºã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [x] ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†ã®çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [x] å ±é…¬ç²å¾—ã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [x] æ—¥çµ‚äº†ã‚µãƒãƒªãƒ¼ã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹

**âœ… å®Œäº†** (TDDé–‹ç™ºå®Œäº† - 18ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å…¨é€šéã€è¦ä»¶ç¶²ç¾…ç‡100%)

---

## ãƒ†ã‚¹ãƒˆå®Ÿè£…è©³ç´°

### 1. 1ã‚¿ãƒ¼ãƒ³å¾ŒåŠçµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *çµ±åˆãƒ†ã‚¹ãƒˆ*

**ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/phaser/phase5/TurnCycleSecondHalf.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createTestGame, waitForPhase, setupGameState } from '../../../utils/phaserTestUtils';
import { EventBus } from '@/presentation/phaser/core/EventBus';
import { PhaserStateManager } from '@/presentation/phaser/state/PhaserStateManager';

describe('Turn Cycle Second Half Integration', () => {
  let game: Phaser.Game;
  let eventBus: EventBus;
  let stateManager: PhaserStateManager;

  beforeEach(async () => {
    const testSetup = await createTestGame();
    game = testSetup.game;
    eventBus = testSetup.eventBus;
    stateManager = game.registry.get('stateManager');

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    eventBus.emit('ui:game:start:requested', { isNewGame: true });
    await waitForPhase(game, 'quest-accept');

    // èª¿åˆãƒ•ã‚§ãƒ¼ã‚ºã¾ã§é€²ã‚ã‚‹
    eventBus.emit('ui:phase:complete', { phase: 'quest-accept' });
    await waitForPhase(game, 'gathering');
    eventBus.emit('ui:phase:complete', { phase: 'gathering' });
    await waitForPhase(game, 'alchemy');
  });

  afterEach(() => {
    game.destroy(true);
  });

  describe('Alchemy Phase', () => {
    beforeEach(() => {
      // ç´ æã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«è¿½åŠ 
      stateManager.updateInventory({
        materials: [
          { id: 'herb_001', name: 'è–¬è‰', quantity: 5, quality: 80 },
          { id: 'water_001', name: 'æ°´', quantity: 3, quality: 70 },
          { id: 'crystal_001', name: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ«', quantity: 2, quality: 90 },
        ],
      });

      // ãƒ¬ã‚·ãƒ”ã‚«ãƒ¼ãƒ‰ã‚’æ‰‹æœ­ã«è¿½åŠ 
      stateManager.updateDeck({
        hand: [
          {
            id: 'recipe_potion_001',
            type: 'recipe',
            name: 'å›å¾©è–¬',
            requirements: [
              { itemId: 'herb_001', quantity: 2 },
              { itemId: 'water_001', quantity: 1 },
            ],
            output: { id: 'potion_001', name: 'å›å¾©è–¬' },
          },
        ],
        cards: [],
        discard: [],
      });
    });

    it('ãƒ¬ã‚·ãƒ”ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Assert
      const deck = stateManager.getDeck();
      const recipeCards = deck.hand.filter((c: any) => c.type === 'recipe');
      expect(recipeCards.length).toBeGreaterThan(0);
    });

    it('ã‚¢ã‚¤ãƒ†ãƒ ã‚’èª¿åˆã§ãã‚‹', async () => {
      // Arrange
      const initialCraftedItems = stateManager.getInventory().craftedItems.length;

      // Act
      eventBus.emit('ui:alchemy:craft:requested', {
        recipeCardId: 'recipe_potion_001',
        materialIds: ['herb_001', 'herb_001', 'water_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const inventory = stateManager.getInventory();
        expect(inventory.craftedItems.length).toBeGreaterThan(initialCraftedItems);
      });
    });

    it('èª¿åˆã§ç´ æãŒæ¶ˆè²»ã•ã‚Œã‚‹', async () => {
      // Arrange
      const initialHerb = stateManager.getInventory().materials.find(m => m.id === 'herb_001');

      // Act
      eventBus.emit('ui:alchemy:craft:requested', {
        recipeCardId: 'recipe_potion_001',
        materialIds: ['herb_001', 'herb_001', 'water_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const herb = stateManager.getInventory().materials.find(m => m.id === 'herb_001');
        expect(herb!.quantity).toBe(initialHerb!.quantity - 2);
      });
    });

    it('ç´ æä¸è¶³æ™‚ã¯èª¿åˆã§ããªã„', async () => {
      // Arrange - ç´ æã‚’ç©ºã«
      stateManager.updateInventory({ materials: [] });

      const errorCallback = vi.fn();
      eventBus.on('app:error:occurred', errorCallback);

      // Act
      eventBus.emit('ui:alchemy:craft:requested', {
        recipeCardId: 'recipe_potion_001',
        materialIds: ['herb_001', 'herb_001', 'water_001'],
      });

      // Assert
      await vi.waitFor(() => {
        expect(errorCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            message: expect.stringContaining('ç´ æ'),
          })
        );
      });
    });

    it('èª¿åˆçµæœã«å“è³ªãŒåæ˜ ã•ã‚Œã‚‹', async () => {
      // Act
      eventBus.emit('ui:alchemy:craft:requested', {
        recipeCardId: 'recipe_potion_001',
        materialIds: ['herb_001', 'herb_001', 'water_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const craftedItems = stateManager.getInventory().craftedItems;
        const potion = craftedItems.find(i => i.id.startsWith('potion'));
        expect(potion).toBeDefined();
        expect(potion!.quality).toBeGreaterThan(0);
      });
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã§ç´å“ãƒ•ã‚§ãƒ¼ã‚ºã«é·ç§»ã™ã‚‹', async () => {
      // Act
      eventBus.emit('ui:phase:complete', { phase: 'alchemy' });

      // Assert
      await waitForPhase(game, 'delivery');
      expect(stateManager.getProgress().currentPhase).toBe('delivery');
    });
  });

  describe('Delivery Phase', () => {
    beforeEach(async () => {
      // ä¾é ¼ã‚’å—æ³¨æ¸ˆã¿çŠ¶æ…‹ã«
      stateManager.updateQuests({
        available: [],
        accepted: [
          {
            id: 'quest_001',
            name: 'å›å¾©è–¬ã®ç´å“',
            requirements: [{ itemId: 'potion_001', quantity: 1 }],
            rewards: { gold: 100, exp: 50 },
          },
        ],
        completed: [],
      });

      // ç´å“å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”¨æ„
      stateManager.updateInventory({
        craftedItems: [
          { id: 'potion_001', name: 'å›å¾©è–¬', quantity: 1, quality: 80 },
        ],
        materials: [],
        artifacts: [],
      });

      // ç´å“ãƒ•ã‚§ãƒ¼ã‚ºã¸é·ç§»
      eventBus.emit('ui:phase:complete', { phase: 'alchemy' });
      await waitForPhase(game, 'delivery');
    });

    it('å—æ³¨ä¸­ã®ä¾é ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Assert
      const quests = stateManager.getQuests();
      expect(quests.accepted.length).toBeGreaterThan(0);
    });

    it('ä¾é ¼ã‚’ç´å“ã§ãã‚‹', async () => {
      // Arrange
      const initialGold = stateManager.getPlayerData().gold;

      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'quest_001',
        itemIds: ['potion_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const quests = stateManager.getQuests();
        expect(quests.completed).toContainEqual(
          expect.objectContaining({ id: 'quest_001' })
        );
        expect(quests.accepted).not.toContainEqual(
          expect.objectContaining({ id: 'quest_001' })
        );
      });
    });

    it('ç´å“ã§å ±é…¬ã‚’ç²å¾—ã™ã‚‹', async () => {
      // Arrange
      const initialGold = stateManager.getPlayerData().gold;
      const initialExp = stateManager.getPlayerData().exp;

      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'quest_001',
        itemIds: ['potion_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const player = stateManager.getPlayerData();
        expect(player.gold).toBe(initialGold + 100);
        expect(player.exp).toBe(initialExp + 50);
      });
    });

    it('ç´å“ã§ã‚¢ã‚¤ãƒ†ãƒ ãŒæ¶ˆè²»ã•ã‚Œã‚‹', async () => {
      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'quest_001',
        itemIds: ['potion_001'],
      });

      // Assert
      await vi.waitFor(() => {
        const inventory = stateManager.getInventory();
        expect(inventory.craftedItems.find(i => i.id === 'potion_001')).toBeUndefined();
      });
    });

    it('å¿…è¦ã‚¢ã‚¤ãƒ†ãƒ ä¸è¶³æ™‚ã¯ç´å“ã§ããªã„', async () => {
      // Arrange - ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç©ºã«
      stateManager.updateInventory({ craftedItems: [], materials: [], artifacts: [] });

      const errorCallback = vi.fn();
      eventBus.on('app:error:occurred', errorCallback);

      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'quest_001',
        itemIds: [],
      });

      // Assert
      await vi.waitFor(() => {
        expect(errorCallback).toHaveBeenCalled();
      });
    });
  });

  describe('Turn End', () => {
    beforeEach(async () => {
      // ç´å“ãƒ•ã‚§ãƒ¼ã‚ºã¾ã§é€²ã‚ã‚‹
      eventBus.emit('ui:phase:complete', { phase: 'alchemy' });
      await waitForPhase(game, 'delivery');
    });

    it('ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã§ã‚¿ãƒ¼ãƒ³ãŒçµ‚äº†ã™ã‚‹', async () => {
      // Arrange
      const initialDay = stateManager.getProgress().currentDay;

      // Act
      eventBus.emit('ui:phase:complete', { phase: 'delivery' });

      // Assert
      await vi.waitFor(() => {
        expect(stateManager.getProgress().currentDay).toBe(initialDay + 1);
      });
    });

    it('ã‚¿ãƒ¼ãƒ³çµ‚äº†ã§APãŒå›å¾©ã™ã‚‹', async () => {
      // Arrange
      stateManager.updatePlayer({ ap: { current: 0, max: 3 } });

      // Act
      eventBus.emit('ui:phase:complete', { phase: 'delivery' });

      // Assert
      await vi.waitFor(() => {
        const player = stateManager.getPlayerData();
        expect(player.ap.current).toBe(player.ap.max);
      });
    });

    it('ã‚¿ãƒ¼ãƒ³çµ‚äº†ã§ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºã«æˆ»ã‚‹', async () => {
      // Act
      eventBus.emit('ui:phase:complete', { phase: 'delivery' });

      // Assert
      await waitForPhase(game, 'quest-accept');
      expect(stateManager.getProgress().currentPhase).toBe('quest-accept');
    });

    it('ã‚¿ãƒ¼ãƒ³çµ‚äº†ã‚µãƒãƒªãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
      // Arrange
      const dayEndedCallback = vi.fn();
      eventBus.on('app:day:ended', dayEndedCallback);

      // Act
      eventBus.emit('ui:phase:complete', { phase: 'delivery' });

      // Assert
      await vi.waitFor(() => {
        expect(dayEndedCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            newDay: expect.any(Number),
            summary: expect.any(Object),
          })
        );
      });
    });

    it('å ±é…¬ã‚«ãƒ¼ãƒ‰é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã‚‹ï¼ˆä¾é ¼å®Œäº†æ™‚ï¼‰', async () => {
      // Arrange - ä¾é ¼ã‚’å®Œäº†ã•ã›ã‚‹
      stateManager.updateQuests({
        accepted: [{
          id: 'quest_002',
          requirements: [{ itemId: 'item_001', quantity: 1 }],
          rewards: { gold: 100, exp: 50 },
          rewardCards: ['card_option_1', 'card_option_2', 'card_option_3'],
        }],
        available: [],
        completed: [],
      });
      stateManager.updateInventory({
        craftedItems: [{ id: 'item_001', quantity: 1 }],
        materials: [],
        artifacts: [],
      });

      const rewardCardCallback = vi.fn();
      eventBus.on('app:reward:card:selection', rewardCardCallback);

      // Act
      eventBus.emit('ui:quest:delivery:requested', {
        questId: 'quest_002',
        itemIds: ['item_001'],
      });

      // Assert
      await vi.waitFor(() => {
        expect(rewardCardCallback).toHaveBeenCalledWith(
          expect.objectContaining({
            cards: expect.any(Array),
          })
        );
      });
    });
  });

  describe('Full Turn Cycle', () => {
    it('1ã‚¿ãƒ¼ãƒ³å…¨ä½“ãŒæ­£å¸¸ã«å®Œäº†ã™ã‚‹', async () => {
      // Phase 1: Quest Accept
      expect(stateManager.getProgress().currentPhase).toBe('alchemy');

      // Go back to start for full cycle test
      stateManager.updateProgress({ currentPhase: 'quest-accept', currentDay: 1 });

      // Phase transitions
      const phases = ['quest-accept', 'gathering', 'alchemy', 'delivery'];
      let currentIndex = 0;

      for (const phase of phases) {
        expect(stateManager.getProgress().currentPhase).toBe(phase);
        eventBus.emit('ui:phase:complete', { phase });

        if (phase !== 'delivery') {
          await waitForPhase(game, phases[++currentIndex]);
        }
      }

      // After delivery, should be day 2, quest-accept phase
      await vi.waitFor(() => {
        expect(stateManager.getProgress().currentDay).toBe(2);
        expect(stateManager.getProgress().currentPhase).toBe('quest-accept');
      });
    });
  });
});
```

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0262` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| ãƒ†ã‚¹ãƒˆå¯¾è±¡ | ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸ |
|-----------|---------------|
| èª¿åˆãƒ•ã‚§ãƒ¼ã‚º | 90% |
| ç´å“ãƒ•ã‚§ãƒ¼ã‚º | 90% |
| ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç† | 100% |

---

## æ³¨æ„äº‹é …

- ç´ æ/ã‚¢ã‚¤ãƒ†ãƒ ã®çŠ¶æ…‹ç®¡ç†
- å ±é…¬è¨ˆç®—ã®æ­£ç¢ºæ€§
- ã‚¿ãƒ¼ãƒ³çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆã®é †åº

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 1é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 1é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

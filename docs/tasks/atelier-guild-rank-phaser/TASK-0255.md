# TASK-0255: ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰ Phaserå¯¾å¿œ

**ã‚¿ã‚¹ã‚¯ID**: TASK-0255
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 4 - ã‚µãƒ–ã‚·ãƒ¼ãƒ³ãƒ»Applicationå±¤ä¿®æ­£
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”µ *è¨­è¨ˆæ›¸ã«è¨˜è¼‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ¼ãƒ**: [data-schema.md](../../design/atelier-guild-rank-phaser/data-schema.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’Phaserç’°å¢ƒã«å¯¾å¿œã•ã›ã‚‹ã€‚æ—¢å­˜ã®SaveLoadUseCaseã¨PhaserStateManagerã®é€£æºã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0253
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0259

## å®Œäº†æ¡ä»¶

- [ ] ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ãŒPhaserç’°å¢ƒã§å‹•ä½œã™ã‚‹
- [ ] ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ãŒPhaserç’°å¢ƒã§å‹•ä½œã™ã‚‹
- [ ] ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆç®¡ç†UIãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. PhaserSaveLoadManagerå®Ÿè£… ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/save/PhaserSaveLoadManager.ts`

```typescript
import { EventBus } from '../core/EventBus';
import { PhaserStateManager } from '../state/PhaserStateManager';
import { PhaserGameFlowManager } from '../flow/PhaserGameFlowManager';

export interface SaveSlotInfo {
  slotId: number;
  exists: boolean;
  timestamp?: number;
  day?: number;
  rank?: string;
  playtime?: number;
}

export interface SaveData {
  version: string;
  timestamp: number;
  playtime: number;
  state: string; // ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸçŠ¶æ…‹
}

const SAVE_KEY_PREFIX = 'atelier_guild_rank_save_';
const SAVE_VERSION = '1.0.0';
const MAX_SLOTS = 3;

/**
 * Phaserç’°å¢ƒå‘ã‘ã®ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰ç®¡ç†ã‚¯ãƒ©ã‚¹
 */
export class PhaserSaveLoadManager {
  private eventBus: EventBus;
  private stateManager: PhaserStateManager;
  private flowManager: PhaserGameFlowManager;
  private playtime: number = 0;
  private playtimeTimer: number | null = null;

  constructor(
    eventBus: EventBus,
    stateManager: PhaserStateManager,
    flowManager: PhaserGameFlowManager
  ) {
    this.eventBus = eventBus;
    this.stateManager = stateManager;
    this.flowManager = flowManager;
  }

  // ===== ãƒ—ãƒ¬ã‚¤æ™‚é–“ç®¡ç† =====

  startPlaytimeTracking(): void {
    if (this.playtimeTimer !== null) return;

    this.playtimeTimer = window.setInterval(() => {
      this.playtime++;
    }, 1000);
  }

  stopPlaytimeTracking(): void {
    if (this.playtimeTimer !== null) {
      window.clearInterval(this.playtimeTimer);
      this.playtimeTimer = null;
    }
  }

  getPlaytime(): number {
    return this.playtime;
  }

  setPlaytime(time: number): void {
    this.playtime = time;
  }

  // ===== ã‚¹ãƒ­ãƒƒãƒˆç®¡ç† =====

  getSaveSlots(): SaveSlotInfo[] {
    const slots: SaveSlotInfo[] = [];

    for (let i = 1; i <= MAX_SLOTS; i++) {
      const key = `${SAVE_KEY_PREFIX}${i}`;
      const dataStr = localStorage.getItem(key);

      if (dataStr) {
        try {
          const data = JSON.parse(dataStr) as SaveData;
          const state = JSON.parse(data.state);

          slots.push({
            slotId: i,
            exists: true,
            timestamp: data.timestamp,
            day: state.progress?.currentDay,
            rank: state.player?.rank,
            playtime: data.playtime,
          });
        } catch {
          slots.push({
            slotId: i,
            exists: false,
          });
        }
      } else {
        slots.push({
          slotId: i,
          exists: false,
        });
      }
    }

    return slots;
  }

  // ===== ã‚»ãƒ¼ãƒ– =====

  async save(slotId: number): Promise<boolean> {
    if (slotId < 1 || slotId > MAX_SLOTS) {
      console.error(`Invalid slot ID: ${slotId}`);
      return false;
    }

    try {
      const saveData: SaveData = {
        version: SAVE_VERSION,
        timestamp: Date.now(),
        playtime: this.playtime,
        state: this.stateManager.serialize(),
      };

      const key = `${SAVE_KEY_PREFIX}${slotId}`;
      localStorage.setItem(key, JSON.stringify(saveData));

      this.eventBus.emit('save:complete', { slotId });

      return true;
    } catch (error) {
      console.error('Save failed:', error);
      this.eventBus.emit('save:failed', { slotId, error });
      return false;
    }
  }

  // ===== ãƒ­ãƒ¼ãƒ‰ =====

  async load(slotId: number): Promise<boolean> {
    if (slotId < 1 || slotId > MAX_SLOTS) {
      console.error(`Invalid slot ID: ${slotId}`);
      return false;
    }

    try {
      const key = `${SAVE_KEY_PREFIX}${slotId}`;
      const dataStr = localStorage.getItem(key);

      if (!dataStr) {
        throw new Error('Save data not found');
      }

      const saveData = JSON.parse(dataStr) as SaveData;

      // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
      if (saveData.version !== SAVE_VERSION) {
        console.warn(`Save version mismatch: ${saveData.version} vs ${SAVE_VERSION}`);
        // å°†æ¥çš„ã«ã¯ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
      }

      // ãƒ—ãƒ¬ã‚¤æ™‚é–“å¾©å…ƒ
      this.playtime = saveData.playtime;

      // çŠ¶æ…‹å¾©å…ƒ
      this.stateManager.deserialize(saveData.state);

      // ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼å¾©å…ƒ
      await this.flowManager.loadGame(saveData.state);

      this.eventBus.emit('load:complete', { slotId });

      return true;
    } catch (error) {
      console.error('Load failed:', error);
      this.eventBus.emit('load:failed', { slotId, error });
      return false;
    }
  }

  // ===== å‰Šé™¤ =====

  deleteSave(slotId: number): boolean {
    if (slotId < 1 || slotId > MAX_SLOTS) {
      console.error(`Invalid slot ID: ${slotId}`);
      return false;
    }

    try {
      const key = `${SAVE_KEY_PREFIX}${slotId}`;
      localStorage.removeItem(key);

      this.eventBus.emit('save:deleted', { slotId });

      return true;
    } catch (error) {
      console.error('Delete failed:', error);
      return false;
    }
  }

  // ===== ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ– =====

  private autoSaveTimer: number | null = null;
  private autoSaveInterval: number = 60000; // 1åˆ†

  enableAutoSave(intervalMs?: number): void {
    if (intervalMs) {
      this.autoSaveInterval = intervalMs;
    }

    if (this.autoSaveTimer !== null) {
      this.disableAutoSave();
    }

    this.autoSaveTimer = window.setInterval(() => {
      this.autoSave();
    }, this.autoSaveInterval);

    // ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´æ™‚ã«ã‚‚ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–
    this.eventBus.on('app:phase:changed', () => {
      this.autoSave();
    });
  }

  disableAutoSave(): void {
    if (this.autoSaveTimer !== null) {
      window.clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }

  private async autoSave(): Promise<void> {
    // ã‚¹ãƒ­ãƒƒãƒˆ0ã‚’ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ç”¨ã«ä½¿ç”¨ï¼ˆã¾ãŸã¯åˆ¥ã‚­ãƒ¼ï¼‰
    const autoSaveKey = `${SAVE_KEY_PREFIX}auto`;

    try {
      const saveData: SaveData = {
        version: SAVE_VERSION,
        timestamp: Date.now(),
        playtime: this.playtime,
        state: this.stateManager.serialize(),
      };

      localStorage.setItem(autoSaveKey, JSON.stringify(saveData));
      console.log('Auto-save complete');
    } catch (error) {
      console.error('Auto-save failed:', error);
    }
  }

  hasAutoSave(): boolean {
    return localStorage.getItem(`${SAVE_KEY_PREFIX}auto`) !== null;
  }

  async loadAutoSave(): Promise<boolean> {
    try {
      const dataStr = localStorage.getItem(`${SAVE_KEY_PREFIX}auto`);

      if (!dataStr) {
        return false;
      }

      const saveData = JSON.parse(dataStr) as SaveData;
      this.playtime = saveData.playtime;
      this.stateManager.deserialize(saveData.state);
      await this.flowManager.loadGame(saveData.state);

      return true;
    } catch (error) {
      console.error('Load auto-save failed:', error);
      return false;
    }
  }

  // ===== ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— =====

  destroy(): void {
    this.stopPlaytimeTracking();
    this.disableAutoSave();
  }
}
```

### 2. ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰UI ğŸ”µ

**ä¿¡é ¼æ€§**: ğŸ”µ *UIå®Ÿè£…*

```typescript
// src/presentation/phaser/ui/save/SaveLoadPanel.ts

import Phaser from 'phaser';
import { UIFactory } from '../UIFactory';
import { Colors } from '../../config/ColorPalette';
import { TextStyles } from '../../config/TextStyles';
import { SaveSlotInfo } from '../../save/PhaserSaveLoadManager';

export interface SaveLoadPanelOptions {
  scene: Phaser.Scene;
  x: number;
  y: number;
  mode: 'save' | 'load';
  slots: SaveSlotInfo[];
  onSlotSelect: (slotId: number) => void;
  onClose: () => void;
}

export class SaveLoadPanel extends Phaser.GameObjects.Container {
  private mode: 'save' | 'load';
  private slots: SaveSlotInfo[];
  private onSlotSelect: (slotId: number) => void;
  private onClose: () => void;

  constructor(options: SaveLoadPanelOptions) {
    super(options.scene, options.x, options.y);

    this.mode = options.mode;
    this.slots = options.slots;
    this.onSlotSelect = options.onSlotSelect;
    this.onClose = options.onClose;

    this.createPanel();
    options.scene.add.existing(this);
  }

  private createPanel(): void {
    const width = 400;
    const height = 350;

    // èƒŒæ™¯
    const bg = this.scene.add.graphics();
    bg.fillStyle(Colors.panelBackground, 0.95);
    bg.fillRoundedRect(-width / 2, -height / 2, width, height, 12);
    bg.lineStyle(2, Colors.primary);
    bg.strokeRoundedRect(-width / 2, -height / 2, width, height, 12);
    this.add(bg);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const title = this.scene.add.text(
      0,
      -height / 2 + 30,
      this.mode === 'save' ? 'ã‚»ãƒ¼ãƒ–' : 'ãƒ­ãƒ¼ãƒ‰',
      {
        ...TextStyles.heading,
        fontSize: '24px',
      }
    ).setOrigin(0.5);
    this.add(title);

    // ã‚¹ãƒ­ãƒƒãƒˆä¸€è¦§
    this.slots.forEach((slot, index) => {
      const slotY = -height / 2 + 80 + index * 80;
      const slotItem = this.createSlotItem(slot, 0, slotY);
      this.add(slotItem);
    });

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
    const closeBtn = UIFactory.createButton(this.scene, {
      x: 0,
      y: height / 2 - 40,
      width: 120,
      height: 40,
      text: 'é–‰ã˜ã‚‹',
      style: 'secondary',
      onClick: () => this.onClose(),
    });
    this.add(closeBtn);
  }

  private createSlotItem(slot: SaveSlotInfo, x: number, y: number): Phaser.GameObjects.Container {
    const container = this.scene.add.container(x, y);
    const width = 350;
    const height = 70;

    // èƒŒæ™¯
    const bg = this.scene.add.graphics();
    bg.fillStyle(slot.exists ? Colors.backgroundMedium : 0x333333, 1);
    bg.fillRoundedRect(-width / 2, -height / 2, width, height, 8);
    container.add(bg);

    // ã‚¹ãƒ­ãƒƒãƒˆç•ªå·
    const slotNum = this.scene.add.text(-width / 2 + 20, 0, `ã‚¹ãƒ­ãƒƒãƒˆ ${slot.slotId}`, {
      ...TextStyles.body,
      fontSize: '16px',
      fontStyle: 'bold',
    }).setOrigin(0, 0.5);
    container.add(slotNum);

    if (slot.exists) {
      // æ—¥æ•°ãƒ»ãƒ©ãƒ³ã‚¯
      const info = this.scene.add.text(-width / 2 + 20, 15, `${slot.day}æ—¥ç›® / ãƒ©ãƒ³ã‚¯ ${slot.rank}`, {
        ...TextStyles.body,
        fontSize: '12px',
        color: '#aaaaaa',
      }).setOrigin(0, 0);
      container.add(info);

      // ä¿å­˜æ—¥æ™‚
      const dateStr = slot.timestamp
        ? new Date(slot.timestamp).toLocaleString('ja-JP')
        : '';
      const date = this.scene.add.text(width / 2 - 20, -10, dateStr, {
        ...TextStyles.body,
        fontSize: '11px',
        color: '#888888',
      }).setOrigin(1, 0.5);
      container.add(date);

      // ãƒ—ãƒ¬ã‚¤æ™‚é–“
      const playtimeStr = this.formatPlaytime(slot.playtime ?? 0);
      const playtime = this.scene.add.text(width / 2 - 20, 10, playtimeStr, {
        ...TextStyles.body,
        fontSize: '11px',
        color: '#888888',
      }).setOrigin(1, 0.5);
      container.add(playtime);
    } else {
      // ç©ºãã‚¹ãƒ­ãƒƒãƒˆ
      const empty = this.scene.add.text(0, 0, 'ç©ºãã‚¹ãƒ­ãƒƒãƒˆ', {
        ...TextStyles.body,
        fontSize: '14px',
        color: '#666666',
      }).setOrigin(0.5);
      container.add(empty);
    }

    // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
    container.setSize(width, height);
    container.setInteractive({ useHandCursor: true });

    container.on('pointerover', () => {
      bg.clear();
      bg.fillStyle(Colors.buttonHover, 1);
      bg.fillRoundedRect(-width / 2, -height / 2, width, height, 8);
    });

    container.on('pointerout', () => {
      bg.clear();
      bg.fillStyle(slot.exists ? Colors.backgroundMedium : 0x333333, 1);
      bg.fillRoundedRect(-width / 2, -height / 2, width, height, 8);
    });

    container.on('pointerdown', () => {
      // ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§ç©ºã‚¹ãƒ­ãƒƒãƒˆã¯é¸æŠä¸å¯
      if (this.mode === 'load' && !slot.exists) {
        return;
      }
      this.onSlotSelect(slot.slotId);
    });

    return container;
  }

  private formatPlaytime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours > 0) {
      return `ãƒ—ãƒ¬ã‚¤æ™‚é–“: ${hours}æ™‚é–“${minutes}åˆ†`;
    }
    return `ãƒ—ãƒ¬ã‚¤æ™‚é–“: ${minutes}åˆ†`;
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: ã‚»ãƒ¼ãƒ– ğŸ”µ

**Given**: ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãŒã‚ã‚‹
**When**: save(1)ã‚’å‘¼ã¶
**Then**: localStorageã«ä¿å­˜ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ãƒ­ãƒ¼ãƒ‰ ğŸ”µ

**Given**: ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹
**When**: load(1)ã‚’å‘¼ã¶
**Then**: çŠ¶æ…‹ãŒå¾©å…ƒã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ– ğŸ”µ

**Given**: ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ãŒæœ‰åŠ¹
**When**: ãƒ•ã‚§ãƒ¼ã‚ºãŒå¤‰ã‚ã‚‹
**Then**: ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ãŒå®Ÿè¡Œã•ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0255` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- localStorageã®å®¹é‡åˆ¶é™
- ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§
- ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 2é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 2é …ç›® (100%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: é«˜å“è³ª

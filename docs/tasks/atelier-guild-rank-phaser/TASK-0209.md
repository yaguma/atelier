# TASK-0209: PhaseIndicatorå®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0209
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 2 - åŸºæœ¬ã‚·ãƒ¼ãƒ³ãƒ»å…±é€šUIå®Ÿè£…
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸŸ¡ *å¦¥å½“ãªæ¨æ¸¬ã«åŸºã¥ã*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **UIè¨­è¨ˆ**: [ui-design/overview.md](../../design/atelier-guild-rank-phaser/ui-design/overview.md)

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ãƒ•ã‚§ãƒ¼ã‚ºã‚’è¦–è¦šçš„ã«è¡¨ç¤ºã™ã‚‹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹ã€‚ä¾é ¼å—æ³¨â†’æ¡å–â†’èª¿åˆâ†’ç´å“ã®é€²è¡ŒçŠ¶æ³ã‚’è¡¨ç¤ºã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0173
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0210

## å®Œäº†æ¡ä»¶

- [ ] IPhaseIndicatorã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹
- [ ] 4ã¤ã®ãƒ•ã‚§ãƒ¼ã‚ºãŒæ¨ªä¸¦ã³ã§è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ç¾åœ¨ãƒ•ã‚§ãƒ¼ã‚ºãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã‚‹
- [ ] ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆæ™‚ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹
- [ ] ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´ã‚’è¦æ±‚ã§ãã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

---

## å®Ÿè£…è©³ç´°

### 1. PhaseIndicatorå®šæ•° ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ui-design/overview.mdã‚’å‚è€ƒ*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/phase/PhaseIndicatorConstants.ts`

```typescript
import { GamePhase } from '../../../../domain/common/GamePhase';

export const PhaseIndicatorLayout = {
  // ä½ç½®
  X: 200,
  Y: 100,

  // ã‚µã‚¤ã‚º
  ITEM_WIDTH: 150,
  ITEM_HEIGHT: 50,
  ITEM_SPACING: 10,

  // ã‚³ãƒã‚¯ã‚¿ï¼ˆãƒ•ã‚§ãƒ¼ã‚ºé–“ã®ç·šï¼‰
  CONNECTOR_WIDTH: 30,
  CONNECTOR_HEIGHT: 4,
} as const;

export const PhaseInfo: Record<GamePhase, { label: string; icon: string }> = {
  quest_accept: { label: 'ä¾é ¼å—æ³¨', icon: 'ğŸ“‹' },
  gathering: { label: 'æ¡å–', icon: 'ğŸŒ¿' },
  alchemy: { label: 'èª¿åˆ', icon: 'âš—ï¸' },
  delivery: { label: 'ç´å“', icon: 'ğŸ“¦' },
};

export const PhaseColors = {
  ACTIVE_BG: 0x4a8a4a,
  ACTIVE_BORDER: 0x6aaa6a,
  INACTIVE_BG: 0x3a3a5a,
  INACTIVE_BORDER: 0x4a4a6a,
  COMPLETED_BG: 0x2a5a2a,
  CONNECTOR_ACTIVE: 0x6aaa6a,
  CONNECTOR_INACTIVE: 0x4a4a6a,
} as const;
```

### 2. IPhaseIndicatorã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/phase/IPhaseIndicator.ts`

```typescript
import Phaser from 'phaser';
import { GamePhase } from '../../../../domain/common/GamePhase';

export interface PhaseIndicatorOptions {
  x?: number;
  y?: number;
  onPhaseClick?: (phase: GamePhase) => void;
  clickable?: boolean;
}

export interface IPhaseIndicator {
  // ã‚³ãƒ³ãƒ†ãƒŠå‚ç…§
  readonly container: Phaser.GameObjects.Container;

  // ç¾åœ¨ãƒ•ã‚§ãƒ¼ã‚º
  setCurrentPhase(phase: GamePhase, animate?: boolean): void;
  getCurrentPhase(): GamePhase;

  // å®Œäº†ãƒ•ã‚§ãƒ¼ã‚º
  markPhaseCompleted(phase: GamePhase): void;
  clearCompletedPhases(): void;

  // ãƒ•ã‚§ãƒ¼ã‚ºã®æœ‰åŠ¹/ç„¡åŠ¹
  setPhaseEnabled(phase: GamePhase, enabled: boolean): void;

  // è¡¨ç¤ºåˆ¶å¾¡
  setVisible(visible: boolean): void;

  // ç ´æ£„
  destroy(): void;
}
```

### 3. PhaseIndicatorå®Ÿè£… ğŸŸ¡

**ä¿¡é ¼æ€§**: ğŸŸ¡ *ãƒ•ã‚§ãƒ¼ã‚ºè¡¨ç¤º*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/ui/phase/PhaseIndicator.ts`

```typescript
import Phaser from 'phaser';
import { GamePhase } from '../../../../domain/common/GamePhase';
import { IPhaseIndicator, PhaseIndicatorOptions } from './IPhaseIndicator';
import { PhaseIndicatorLayout, PhaseInfo, PhaseColors } from './PhaseIndicatorConstants';
import { TextStyles } from '../../config/TextStyles';

interface PhaseItemData {
  container: Phaser.GameObjects.Container;
  background: Phaser.GameObjects.Graphics;
  icon: Phaser.GameObjects.Text;
  label: Phaser.GameObjects.Text;
  phase: GamePhase;
  completed: boolean;
  enabled: boolean;
}

export class PhaseIndicator implements IPhaseIndicator {
  public readonly container: Phaser.GameObjects.Container;

  private scene: Phaser.Scene;
  private phases: GamePhase[] = ['quest_accept', 'gathering', 'alchemy', 'delivery'];
  private phaseItems: Map<GamePhase, PhaseItemData> = new Map();
  private connectors: Phaser.GameObjects.Graphics[] = [];
  private currentPhase: GamePhase = 'quest_accept';

  private onPhaseClick?: (phase: GamePhase) => void;
  private clickable: boolean;

  constructor(scene: Phaser.Scene, options: PhaseIndicatorOptions = {}) {
    this.scene = scene;
    this.onPhaseClick = options.onPhaseClick;
    this.clickable = options.clickable ?? false;

    const x = options.x ?? PhaseIndicatorLayout.X;
    const y = options.y ?? PhaseIndicatorLayout.Y;

    this.container = scene.add.container(x, y);
    this.container.setDepth(300);

    this.createPhaseItems();
    this.createConnectors();
    this.setCurrentPhase('quest_accept', false);
  }

  private createPhaseItems(): void {
    const { ITEM_WIDTH, ITEM_HEIGHT, ITEM_SPACING, CONNECTOR_WIDTH } = PhaseIndicatorLayout;

    this.phases.forEach((phase, index) => {
      const x = index * (ITEM_WIDTH + ITEM_SPACING + CONNECTOR_WIDTH);
      const itemContainer = this.scene.add.container(x, 0);

      // èƒŒæ™¯
      const background = this.scene.add.graphics();
      background.fillStyle(PhaseColors.INACTIVE_BG, 1);
      background.fillRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
      background.lineStyle(2, PhaseColors.INACTIVE_BORDER);
      background.strokeRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
      itemContainer.add(background);

      // ã‚¢ã‚¤ã‚³ãƒ³
      const info = PhaseInfo[phase];
      const icon = this.scene.add.text(15, ITEM_HEIGHT / 2, info.icon, {
        fontSize: '24px',
      }).setOrigin(0, 0.5);
      itemContainer.add(icon);

      // ãƒ©ãƒ™ãƒ«
      const label = this.scene.add.text(50, ITEM_HEIGHT / 2, info.label, {
        ...TextStyles.body,
        fontSize: '14px',
      }).setOrigin(0, 0.5);
      itemContainer.add(label);

      // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
      if (this.clickable) {
        itemContainer.setInteractive(
          new Phaser.Geom.Rectangle(0, 0, ITEM_WIDTH, ITEM_HEIGHT),
          Phaser.Geom.Rectangle.Contains
        );
        itemContainer.on('pointerdown', () => this.handlePhaseClick(phase));
        itemContainer.on('pointerover', () => this.handlePhaseHover(phase, true));
        itemContainer.on('pointerout', () => this.handlePhaseHover(phase, false));
      }

      this.container.add(itemContainer);

      this.phaseItems.set(phase, {
        container: itemContainer,
        background,
        icon,
        label,
        phase,
        completed: false,
        enabled: true,
      });
    });
  }

  private createConnectors(): void {
    const { ITEM_WIDTH, ITEM_SPACING, CONNECTOR_WIDTH, CONNECTOR_HEIGHT, ITEM_HEIGHT } = PhaseIndicatorLayout;

    for (let i = 0; i < this.phases.length - 1; i++) {
      const x = (i + 1) * ITEM_WIDTH + i * (ITEM_SPACING + CONNECTOR_WIDTH) + ITEM_SPACING / 2;
      const y = ITEM_HEIGHT / 2 - CONNECTOR_HEIGHT / 2;

      const connector = this.scene.add.graphics();
      connector.fillStyle(PhaseColors.CONNECTOR_INACTIVE, 1);
      connector.fillRect(x, y, CONNECTOR_WIDTH, CONNECTOR_HEIGHT);
      this.container.add(connector);
      this.connectors.push(connector);
    }
  }

  setCurrentPhase(phase: GamePhase, animate: boolean = true): void {
    const previousPhase = this.currentPhase;
    this.currentPhase = phase;

    // å…¨ãƒ•ã‚§ãƒ¼ã‚ºã®è¡¨ç¤ºã‚’æ›´æ–°
    this.phases.forEach((p, index) => {
      const item = this.phaseItems.get(p);
      if (!item) return;

      const isCurrent = p === phase;
      const isPrevious = this.phases.indexOf(p) < this.phases.indexOf(phase);

      this.updatePhaseItemVisual(item, isCurrent, isPrevious);

      // ã‚³ãƒã‚¯ã‚¿ã®æ›´æ–°
      if (index < this.connectors.length) {
        this.updateConnector(index, isPrevious || isCurrent);
      }
    });

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    if (animate) {
      const currentItem = this.phaseItems.get(phase);
      if (currentItem) {
        this.animatePhaseChange(currentItem);
      }
    }
  }

  private updatePhaseItemVisual(item: PhaseItemData, isCurrent: boolean, isCompleted: boolean): void {
    const { ITEM_WIDTH, ITEM_HEIGHT } = PhaseIndicatorLayout;

    let bgColor: number;
    let borderColor: number;

    if (isCurrent) {
      bgColor = PhaseColors.ACTIVE_BG;
      borderColor = PhaseColors.ACTIVE_BORDER;
    } else if (isCompleted || item.completed) {
      bgColor = PhaseColors.COMPLETED_BG;
      borderColor = PhaseColors.ACTIVE_BORDER;
    } else {
      bgColor = PhaseColors.INACTIVE_BG;
      borderColor = PhaseColors.INACTIVE_BORDER;
    }

    item.background.clear();
    item.background.fillStyle(bgColor, item.enabled ? 1 : 0.5);
    item.background.fillRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);
    item.background.lineStyle(2, borderColor);
    item.background.strokeRoundedRect(0, 0, ITEM_WIDTH, ITEM_HEIGHT, 8);

    item.label.setAlpha(item.enabled ? 1 : 0.5);
    item.icon.setAlpha(item.enabled ? 1 : 0.5);
  }

  private updateConnector(index: number, active: boolean): void {
    const connector = this.connectors[index];
    const { ITEM_WIDTH, ITEM_SPACING, CONNECTOR_WIDTH, CONNECTOR_HEIGHT, ITEM_HEIGHT } = PhaseIndicatorLayout;

    const x = (index + 1) * ITEM_WIDTH + index * (ITEM_SPACING + CONNECTOR_WIDTH) + ITEM_SPACING / 2;
    const y = ITEM_HEIGHT / 2 - CONNECTOR_HEIGHT / 2;

    connector.clear();
    connector.fillStyle(active ? PhaseColors.CONNECTOR_ACTIVE : PhaseColors.CONNECTOR_INACTIVE, 1);
    connector.fillRect(x, y, CONNECTOR_WIDTH, CONNECTOR_HEIGHT);
  }

  private animatePhaseChange(item: PhaseItemData): void {
    // ãƒ‘ãƒ«ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    this.scene.tweens.add({
      targets: item.container,
      scaleX: 1.05,
      scaleY: 1.05,
      duration: 150,
      yoyo: true,
      ease: 'Power2',
    });
  }

  getCurrentPhase(): GamePhase {
    return this.currentPhase;
  }

  markPhaseCompleted(phase: GamePhase): void {
    const item = this.phaseItems.get(phase);
    if (item) {
      item.completed = true;
      this.updatePhaseItemVisual(item, phase === this.currentPhase, true);
    }
  }

  clearCompletedPhases(): void {
    this.phaseItems.forEach(item => {
      item.completed = false;
    });
    this.setCurrentPhase(this.currentPhase, false);
  }

  setPhaseEnabled(phase: GamePhase, enabled: boolean): void {
    const item = this.phaseItems.get(phase);
    if (item) {
      item.enabled = enabled;
      this.updatePhaseItemVisual(item, phase === this.currentPhase, item.completed);
    }
  }

  private handlePhaseClick(phase: GamePhase): void {
    const item = this.phaseItems.get(phase);
    if (!item?.enabled) return;

    if (this.onPhaseClick) {
      this.onPhaseClick(phase);
    }
  }

  private handlePhaseHover(phase: GamePhase, hovering: boolean): void {
    const item = this.phaseItems.get(phase);
    if (!item?.enabled || phase === this.currentPhase) return;

    // ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    this.scene.tweens.add({
      targets: item.container,
      scaleX: hovering ? 1.02 : 1,
      scaleY: hovering ? 1.02 : 1,
      duration: 100,
      ease: 'Power2',
    });
  }

  setVisible(visible: boolean): void {
    this.container.setVisible(visible);
  }

  destroy(): void {
    this.container.destroy();
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: åˆæœŸãƒ•ã‚§ãƒ¼ã‚º ğŸŸ¡

**Given**: PhaseIndicatorã‚’ç”Ÿæˆã™ã‚‹
**When**: ä½•ã‚‚ã—ãªã„
**Then**: ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆ ğŸŸ¡

**Given**: PhaseIndicatorãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: setCurrentPhase('gathering')ã‚’å‘¼ã¶
**Then**: æ¡å–ãƒ•ã‚§ãƒ¼ã‚ºãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ãƒãƒ¼ã‚¯ ğŸŸ¡

**Given**: PhaseIndicatorãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
**When**: markPhaseCompleted('quest_accept')ã‚’å‘¼ã¶
**Then**: ä¾é ¼å—æ³¨ãƒ•ã‚§ãƒ¼ã‚ºãŒå®Œäº†è‰²ã«ãªã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0209` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ãƒ•ã‚§ãƒ¼ã‚ºé–“ã®ã‚³ãƒã‚¯ã‚¿è¡¨ç¤º
- ãƒ•ã‚§ãƒ¼ã‚ºã‚¹ã‚­ãƒƒãƒ—æ™‚ã®è¡¨ç¤º
- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ»‘ã‚‰ã‹ã•

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 3é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 3é …ç›® (100%)
- ğŸ”´ **èµ¤ä¿¡å·**: 0é …ç›® (0%)

**å“è³ªè©•ä¾¡**: ä¸­å“è³ª

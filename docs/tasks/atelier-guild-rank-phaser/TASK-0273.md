# TASK-0273: ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯å¯¾ç­–å®Ÿè£…

**ã‚¿ã‚¹ã‚¯ID**: TASK-0273
**ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—**: TDD
**æ¨å®šå·¥æ•°**: 4æ™‚é–“
**ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–ãƒ»ä»•ä¸Šã’
**ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«**: ğŸ”´ *Phaserå›ºæœ‰*

## é–¢é€£æ–‡æ›¸

- **æ¦‚è¦**: [overview.md](./overview.md)
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬**: TASK-0270

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

ã‚·ãƒ¼ãƒ³é·ç§»æ™‚ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç ´æ£„æ™‚ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã®å¯¾ç­–ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ä¾å­˜ã‚¿ã‚¹ã‚¯

- **å‰æã‚¿ã‚¹ã‚¯**: TASK-0270 (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬)
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0274

## å®Œäº†æ¡ä»¶

- [x] ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [x] ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è‡ªå‹•è§£é™¤æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [x] ã‚·ãƒ¼ãƒ³ç ´æ£„æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [x] å¾ªç’°å‚ç…§é˜²æ­¢ç­–ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [x] å˜ä½“ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹

---

## å®Ÿè£…è©³ç´°

### 1. DisposableManagerå®Ÿè£… ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *ãƒ¡ãƒ¢ãƒªç®¡ç†*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/utils/DisposableManager.ts`

```typescript
/**
 * ç ´æ£„å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
 */
export interface IDisposable {
  dispose(): void;
}

/**
 * ç ´æ£„ç®¡ç†ã‚¯ãƒ©ã‚¹
 * ã‚·ãƒ¼ãƒ³çµ‚äº†æ™‚ã«ã¾ã¨ã‚ã¦ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾
 */
export class DisposableManager implements IDisposable {
  private disposables: Set<IDisposable> = new Set();
  private cleanupCallbacks: Set<() => void> = new Set();
  private isDisposed: boolean = false;

  /**
   * ç ´æ£„å¯¾è±¡ã‚’ç™»éŒ²
   */
  register(disposable: IDisposable): void {
    if (this.isDisposed) {
      console.warn('DisposableManager is already disposed');
      disposable.dispose();
      return;
    }
    this.disposables.add(disposable);
  }

  /**
   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ç™»éŒ²
   */
  onCleanup(callback: () => void): void {
    if (this.isDisposed) {
      console.warn('DisposableManager is already disposed');
      callback();
      return;
    }
    this.cleanupCallbacks.add(callback);
  }

  /**
   * ç™»éŒ²è§£é™¤
   */
  unregister(disposable: IDisposable): void {
    this.disposables.delete(disposable);
  }

  /**
   * å…¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´æ£„
   */
  dispose(): void {
    if (this.isDisposed) {
      return;
    }

    this.isDisposed = true;

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
    this.cleanupCallbacks.forEach(callback => {
      try {
        callback();
      } catch (error) {
        console.error('Cleanup callback error:', error);
      }
    });
    this.cleanupCallbacks.clear();

    // ç ´æ£„å¯¾è±¡ã‚’é€†é †ã§ç ´æ£„ï¼ˆå¾Œã«ç™»éŒ²ã•ã‚ŒãŸã‚‚ã®ã‚’å…ˆã«ï¼‰
    const disposableArray = Array.from(this.disposables).reverse();

    for (const disposable of disposableArray) {
      try {
        disposable.dispose();
      } catch (error) {
        console.error('Dispose error:', error);
      }
    }

    this.disposables.clear();
  }

  /**
   * ç ´æ£„æ¸ˆã¿ã‹ç¢ºèª
   */
  get disposed(): boolean {
    return this.isDisposed;
  }

  /**
   * ç™»éŒ²æ•°ã‚’å–å¾—
   */
  get count(): number {
    return this.disposables.size;
  }
}
```

### 2. EventListenerManagerå®Ÿè£… ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *ã‚¤ãƒ™ãƒ³ãƒˆç®¡ç†*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/utils/EventListenerManager.ts`

```typescript
import { IDisposable } from './DisposableManager';

type UnsubscribeFunction = () => void;

/**
 * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹
 * ç™»éŒ²ã—ãŸãƒªã‚¹ãƒŠãƒ¼ã‚’ä¸€æ‹¬è§£é™¤
 */
export class EventListenerManager implements IDisposable {
  private unsubscribers: Set<UnsubscribeFunction> = new Set();
  private isDisposed: boolean = false;

  /**
   * EventBusã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
   */
  addEventBusListener(
    eventBus: { on: (event: string, callback: Function) => UnsubscribeFunction },
    event: string,
    callback: Function
  ): void {
    if (this.isDisposed) {
      console.warn('EventListenerManager is disposed');
      return;
    }

    const unsubscribe = eventBus.on(event, callback);
    this.unsubscribers.add(unsubscribe);
  }

  /**
   * Phaser EventEmitterã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
   */
  addPhaserListener(
    emitter: Phaser.Events.EventEmitter,
    event: string,
    callback: Function,
    context?: object
  ): void {
    if (this.isDisposed) {
      console.warn('EventListenerManager is disposed');
      return;
    }

    emitter.on(event, callback, context);

    this.unsubscribers.add(() => {
      emitter.off(event, callback, context);
    });
  }

  /**
   * DOM EventListenerã‚’ç™»éŒ²
   */
  addDOMListener(
    element: EventTarget,
    event: string,
    callback: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void {
    if (this.isDisposed) {
      console.warn('EventListenerManager is disposed');
      return;
    }

    element.addEventListener(event, callback, options);

    this.unsubscribers.add(() => {
      element.removeEventListener(event, callback, options);
    });
  }

  /**
   * Tweenå®Œäº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’ç™»éŒ²
   */
  addTween(tween: Phaser.Tweens.Tween): void {
    if (this.isDisposed) {
      console.warn('EventListenerManager is disposed');
      tween.destroy();
      return;
    }

    this.unsubscribers.add(() => {
      if (tween.isPlaying()) {
        tween.stop();
      }
      tween.destroy();
    });
  }

  /**
   * Timerå®Œäº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’ç™»éŒ²
   */
  addTimer(timer: Phaser.Time.TimerEvent): void {
    if (this.isDisposed) {
      console.warn('EventListenerManager is disposed');
      timer.destroy();
      return;
    }

    this.unsubscribers.add(() => {
      timer.destroy();
    });
  }

  /**
   * å…¨ãƒªã‚¹ãƒŠãƒ¼ã‚’è§£é™¤
   */
  dispose(): void {
    if (this.isDisposed) {
      return;
    }

    this.isDisposed = true;

    this.unsubscribers.forEach(unsubscribe => {
      try {
        unsubscribe();
      } catch (error) {
        console.error('Unsubscribe error:', error);
      }
    });

    this.unsubscribers.clear();
  }

  /**
   * ç™»éŒ²æ•°ã‚’å–å¾—
   */
  get count(): number {
    return this.unsubscribers.size;
  }
}
```

### 3. SceneCleanupMixinå®Ÿè£… ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *ã‚·ãƒ¼ãƒ³ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/mixins/SceneCleanupMixin.ts`

```typescript
import Phaser from 'phaser';
import { DisposableManager, IDisposable } from '../utils/DisposableManager';
import { EventListenerManager } from '../utils/EventListenerManager';

/**
 * ã‚·ãƒ¼ãƒ³ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒŸãƒƒã‚¯ã‚¹ã‚¤ãƒ³
 * BaseGameSceneã«çµ„ã¿è¾¼ã‚“ã§ä½¿ç”¨
 */
export interface SceneCleanupCapable {
  disposables: DisposableManager;
  eventListeners: EventListenerManager;
  registerDisposable(disposable: IDisposable): void;
  cleanupScene(): void;
}

export function applySceneCleanupMixin<T extends Phaser.Scene>(
  scene: T
): T & SceneCleanupCapable {
  const enhanced = scene as T & SceneCleanupCapable;

  enhanced.disposables = new DisposableManager();
  enhanced.eventListeners = new EventListenerManager();

  // DisposableManagerã«EventListenerManagerã‚’ç™»éŒ²
  enhanced.disposables.register(enhanced.eventListeners);

  enhanced.registerDisposable = function (disposable: IDisposable): void {
    this.disposables.register(disposable);
  };

  enhanced.cleanupScene = function (): void {
    console.log(`[${this.scene.key}] Cleaning up scene...`);

    // å…¨Tweenã‚’åœæ­¢
    this.tweens.killAll();

    // å…¨Timerã‚’åœæ­¢
    this.time.removeAllEvents();

    // å…¥åŠ›ã‚’ç„¡åŠ¹åŒ–
    this.input.removeAllListeners();

    // DisposableManagerã§ç™»éŒ²ã—ãŸãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´æ£„
    this.disposables.dispose();

    console.log(`[${this.scene.key}] Cleanup complete`);
  };

  // ã‚·ãƒ¼ãƒ³ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³æ™‚ã«è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  scene.events.once('shutdown', () => {
    enhanced.cleanupScene();
  });

  scene.events.once('destroy', () => {
    enhanced.cleanupScene();
  });

  return enhanced;
}
```

### 4. WeakRefã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Ÿè£… ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *å¾ªç’°å‚ç…§é˜²æ­¢*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/utils/WeakCache.ts`

```typescript
/**
 * WeakRefã‚’ä½¿ç”¨ã—ãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥
 * å‚ç…§ãŒãªããªã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è‡ªå‹•çš„ã«GCã•ã‚Œã‚‹
 */
export class WeakCache<K, V extends object> {
  private cache: Map<K, WeakRef<V>> = new Map();
  private finalizationRegistry: FinalizationRegistry<K>;

  constructor() {
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒGCã•ã‚ŒãŸã¨ãã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
    this.finalizationRegistry = new FinalizationRegistry((key: K) => {
      this.cache.delete(key);
    });
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«è¿½åŠ 
   */
  set(key: K, value: V): void {
    // æ—¢å­˜ã‚¨ãƒ³ãƒˆãƒªãŒã‚ã‚Œã°å‰Šé™¤
    this.delete(key);

    const ref = new WeakRef(value);
    this.cache.set(key, ref);
    this.finalizationRegistry.register(value, key);
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—
   */
  get(key: K): V | undefined {
    const ref = this.cache.get(key);

    if (!ref) {
      return undefined;
    }

    const value = ref.deref();

    // GCã•ã‚Œã¦ã„ãŸã‚‰ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
    if (value === undefined) {
      this.cache.delete(key);
    }

    return value;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‰Šé™¤
   */
  delete(key: K): boolean {
    return this.cache.delete(key);
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºï¼ˆå‚ç…§ãŒæœ‰åŠ¹ãªã‚‚ã®ã®ã¿ï¼‰
   */
  get size(): number {
    let count = 0;

    for (const [key, ref] of this.cache) {
      if (ref.deref() !== undefined) {
        count++;
      } else {
        this.cache.delete(key);
      }
    }

    return count;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«å­˜åœ¨ã™ã‚‹ã‹
   */
  has(key: K): boolean {
    const ref = this.cache.get(key);

    if (!ref) {
      return false;
    }

    if (ref.deref() === undefined) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }
}
```

### 5. MemoryLeakDetectorå®Ÿè£… ğŸ”´

**ä¿¡é ¼æ€§**: ğŸ”´ *ãƒ‡ãƒãƒƒã‚°ç”¨*

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/presentation/phaser/debug/MemoryLeakDetector.ts`

```typescript
import Phaser from 'phaser';

interface ObjectTrackingInfo {
  type: string;
  createdAt: number;
  stackTrace: string;
}

/**
 * ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºå™¨ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
 */
export class MemoryLeakDetector {
  private static instance: MemoryLeakDetector | null = null;
  private trackedObjects: WeakMap<object, ObjectTrackingInfo> = new WeakMap();
  private objectCounts: Map<string, number> = new Map();
  private enabled: boolean = false;

  private constructor() {}

  static getInstance(): MemoryLeakDetector {
    if (!MemoryLeakDetector.instance) {
      MemoryLeakDetector.instance = new MemoryLeakDetector();
    }
    return MemoryLeakDetector.instance;
  }

  /**
   * æ¤œå‡ºã‚’æœ‰åŠ¹åŒ–
   */
  enable(): void {
    this.enabled = true;
    console.log('[MemoryLeakDetector] Enabled');
  }

  /**
   * æ¤œå‡ºã‚’ç„¡åŠ¹åŒ–
   */
  disable(): void {
    this.enabled = false;
    console.log('[MemoryLeakDetector] Disabled');
  }

  /**
   * ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½è·¡é–‹å§‹
   */
  track(obj: object, type: string): void {
    if (!this.enabled) return;

    const info: ObjectTrackingInfo = {
      type,
      createdAt: Date.now(),
      stackTrace: new Error().stack || '',
    };

    this.trackedObjects.set(obj, info);

    const count = this.objectCounts.get(type) || 0;
    this.objectCounts.set(type, count + 1);
  }

  /**
   * ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¿½è·¡ã‚’è§£é™¤
   */
  untrack(obj: object): void {
    if (!this.enabled) return;

    const info = this.trackedObjects.get(obj);

    if (info) {
      const count = this.objectCounts.get(info.type) || 0;
      this.objectCounts.set(info.type, Math.max(0, count - 1));
    }
  }

  /**
   * ãƒ¬ãƒãƒ¼ãƒˆã‚’å‡ºåŠ›
   */
  report(): void {
    console.group('[MemoryLeakDetector] Report');

    console.log('Object counts by type:');
    this.objectCounts.forEach((count, type) => {
      if (count > 0) {
        console.log(`  ${type}: ${count}`);
      }
    });

    // Phaserã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç¢ºèª
    if (typeof window !== 'undefined' && (window as any).game) {
      const game = (window as any).game as Phaser.Game;

      console.log('Phaser statistics:');
      console.log(`  Active scenes: ${game.scene.getScenes(true).length}`);
      console.log(`  Textures: ${game.textures.list ? Object.keys(game.textures.list).length : 'N/A'}`);
    }

    console.groupEnd();
  }

  /**
   * ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
   */
  reset(): void {
    this.objectCounts.clear();
    console.log('[MemoryLeakDetector] Reset');
  }

  /**
   * ç‰¹å®šã‚¿ã‚¤ãƒ—ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
   */
  getCount(type: string): number {
    return this.objectCounts.get(type) || 0;
  }

  /**
   * è­¦å‘Šã‚’å‡ºã™ã—ãã„å€¤ã‚’è¨­å®š
   */
  checkThreshold(type: string, threshold: number): boolean {
    const count = this.getCount(type);

    if (count > threshold) {
      console.warn(`[MemoryLeakDetector] ${type} count (${count}) exceeds threshold (${threshold})`);
      return true;
    }

    return false;
  }
}
```

---

## å˜ä½“ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: DisposableManageråŸºæœ¬å‹•ä½œ ğŸ”´

**Given**: DisposableManagerãŒä½œæˆã•ã‚Œã¦ã„ã‚‹
**When**: dispose()ã‚’å®Ÿè¡Œ
**Then**: ç™»éŒ²ã•ã‚ŒãŸå…¨ã¦ã®disposableãŒç ´æ£„ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: EventListenerManagerè§£é™¤ ğŸ”´

**Given**: è¤‡æ•°ã®ãƒªã‚¹ãƒŠãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹
**When**: dispose()ã‚’å®Ÿè¡Œ
**Then**: å…¨ãƒªã‚¹ãƒŠãƒ¼ãŒè§£é™¤ã•ã‚Œã‚‹

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: WeakCacheã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ ğŸ”´

**Given**: WeakCacheã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹
**When**: å‚ç…§ãŒãªããªã‚ŠGCãŒå®Ÿè¡Œã•ã‚Œã‚‹
**Then**: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚¨ãƒ³ãƒˆãƒªãŒå‰Šé™¤ã•ã‚Œã‚‹

---

## å®Ÿè£…æ‰‹é †

1. `/tsumiki:tdd-requirements TASK-0273` - è©³ç´°è¦ä»¶å®šç¾©
2. `/tsumiki:tdd-testcases` - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
3. `/tsumiki:tdd-red` - ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
4. `/tsumiki:tdd-green` - æœ€å°å®Ÿè£…
5. `/tsumiki:tdd-refactor` - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
6. `/tsumiki:tdd-verify-complete` - å“è³ªç¢ºèª

---

## æ³¨æ„äº‹é …

- ã‚·ãƒ¼ãƒ³é·ç§»æ™‚ã®ç¢ºå®Ÿãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è§£é™¤æ¼ã‚Œé˜²æ­¢
- å¾ªç’°å‚ç…§ã®å›é¿
- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿æ¤œå‡ºå™¨ã‚’æœ‰åŠ¹åŒ–

---

## ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã‚µãƒãƒªãƒ¼

- **ç·é …ç›®æ•°**: 5é …ç›®
- ğŸ”µ **é’ä¿¡å·**: 0é …ç›® (0%)
- ğŸŸ¡ **é»„ä¿¡å·**: 0é …ç›® (0%)
- ğŸ”´ **èµ¤ä¿¡å·**: 5é …ç›® (100%)

**å“è³ªè©•ä¾¡**: ä½å“è³ªï¼ˆå®Ÿè£…æ™‚ã«èª¿æ•´è¦ãƒ»Phaserå›ºæœ‰ï¼‰

# TASK-0021: カードUIコンポーネント - TDDテストケース定義書

**作成日**: 2026-01-18
**タスクID**: TASK-0021
**要件名**: atelier-guild-rank
**機能名**: カードUIコンポーネント
**出力ファイル**: docs/implements/atelier-guild-rank/TASK-0021/card-ui-testcases.md

---

## 重要な注意事項

**すべてのファイルパスは、プロジェクトルートを基準とした相対パスで記載しています。**
**絶対パス（/Users/... や C:\\... など）は使用していません。**

---

## 1. テストケース作成対象の情報

### 1.1 基本情報

| 項目 | 値 |
|------|-----|
| **機能名** | カードUIコンポーネント |
| **タスクID** | TASK-0021 |
| **要件名** | atelier-guild-rank |
| **フェーズ** | Phase 3 - UI層 |

### 1.2 参照した設計文書

| ドキュメント | パス | 信頼性 |
|-------------|------|--------|
| タスクファイル | docs/tasks/atelier-guild-rank/phase-3/TASK-0021.md | 🔵 |
| 要件定義書 | docs/implements/atelier-guild-rank/TASK-0021/card-ui-requirements.md | 🔵 |
| タスクノート | docs/implements/atelier-guild-rank/TASK-0021/note.md | 🔵 |
| 実装ファイル（CardUI） | atelier-guild-rank/src/presentation/ui/components/CardUI.ts | 🔵 |
| 実装ファイル（HandDisplay） | atelier-guild-rank/src/presentation/ui/components/HandDisplay.ts | 🔵 |
| 既存テスト（CardUI） | atelier-guild-rank/src/presentation/ui/components/CardUI.spec.ts | 🔵 |
| 既存テスト（HandDisplay） | atelier-guild-rank/src/presentation/ui/components/HandDisplay.spec.ts | 🔵 |

---

## 2. テスト対象コンポーネント

### 2.1 CardUIコンポーネント

**責務**: ゲーム内で使用されるカードの視覚的表現を提供する

**主要機能**:
- カードタイプ別の背景色表示（採取=緑、レシピ=ピンク、強化=青）
- カード情報の表示（アイコン、名前、コスト、効果）
- インタラクティブ機能（ホバー拡大、クリックイベント）
- メモリ管理（destroy()による適切なリソース解放）

### 2.2 HandDisplayコンポーネント

**責務**: プレイヤーの手札を横並びで表示し、カード選択状態を管理する

**主要機能**:
- 最大5枚のカード表示（横並びレイアウト）
- カード選択状態の管理
- 選択中カードの強調表示（Y座標 -20px）
- 手札の動的更新（updateCards）
- メモリ管理（全CardUIの破棄）

---

## 3. 開発言語・フレームワーク

### 3.1 使用技術

| 項目 | 技術 | 信頼性 |
|------|------|--------|
| **プログラミング言語** | TypeScript | 🔵 |
| **テストフレームワーク** | Vitest | 🔵 |
| **ゲームエンジン** | Phaser 3 | 🔵 |
| **UIライブラリ** | rexUI Plugin | 🔵 |

**言語選択の理由**: 🔵
- TypeScriptは型安全性を提供し、リファクタリング時の安全性を確保
- Phaserとの親和性が高く、型定義も充実している

**テストフレームワーク選択の理由**: 🔵
- Vitestは高速で、TypeScriptとの統合が優れている
- Viteビルドツールとシームレスに連携
- Viモック機能により、Phaserのモック作成が容易

**テスト実行環境**: 🔵
- Node.js環境でのユニットテスト
- Phaserシーンのモックを使用
- ブラウザ実行が不要（高速テスト実行）

---

## 4. 正常系テストケース（基本的な動作）

### 4.1 CardUI - 基本表示

#### TC-CARD-UI-001: CardUIの正常生成

- **テスト名**: CardUIの正常生成
  - **何をテストするか**: CardUIがCardエンティティを受け取り、正常にインスタンス化されること
  - **期待される動作**: エラーなく生成され、すべてのGameObjects（背景、アイコン、テキスト）が作成される
- **入力値**:
  ```typescript
  {
    card: Card('card-001', gatheringCardMaster),
    x: 100,
    y: 200,
    interactive: false
  }
  ```
  - **入力データの意味**: 採取カードを画面座標(100, 200)に非インタラクティブモードで表示
- **期待される結果**:
  - CardUIインスタンスが生成される
  - `scene.add.rectangle`が呼ばれる（背景とアイコン用に2回）
  - `scene.add.text`が呼ばれる（名前、コスト、効果用に3回）
  - `mockContainer.add`が呼ばれる（各GameObjectsがコンテナに追加される）
  - **期待結果の理由**: すべてのUI要素が正しく初期化され、Phaserシーンに追加される必要がある
- **テストの目的**: CardUIの基本的な初期化処理が正常に動作することを確認
  - **確認ポイント**: BaseComponentの継承が正しく動作し、create()メソッドが実行されること
- 🔵 このテストケースの信頼性レベル: 要件定義書とタスクファイルに明記

#### TC-CARD-UI-002: カード名の表示

- **テスト名**: カード名が正しく表示される
  - **何をテストするか**: Cardエンティティのnameプロパティがテキストとして表示されること
  - **期待される動作**: カード名がフォントサイズ14px、太字、中央揃えで表示される
- **入力値**:
  ```typescript
  {
    card: Card('card-001', { name: '採取カード', ... }),
    x: 0,
    y: 0
  }
  ```
  - **入力データの意味**: 「採取カード」という名前のカードを表示
- **期待される結果**:
  - `scene.add.text`が「採取カード」というテキストで呼ばれる
  - テキストスタイルが`{ fontSize: '14px', fontStyle: 'bold' }`である
  - `setOrigin(0.5, 0)`が呼ばれる（中央揃え）
  - **期待結果の理由**: プレイヤーがカード名を明確に識別できる必要がある
- **テストの目的**: カード名が要件定義通りに表示されることを確認
  - **確認ポイント**: Cardエンティティからの名前取得とテキスト表示が正しく連携していること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと要件定義書に基づく

#### TC-CARD-UI-003: カードコストの表示

- **テスト名**: カードコストが正しく表示される
  - **何をテストするか**: Cardエンティティのcostプロパティが"⚡ N"形式で表示されること
  - **期待される動作**: コストが稲妻マーク付きで12pxフォントサイズで表示される
- **入力値**:
  ```typescript
  {
    card: Card('card-001', { baseCost: 1, ... }),
    x: 0,
    y: 0
  }
  ```
  - **入力データの意味**: コスト1の採取カードを表示
- **期待される結果**:
  - `scene.add.text`が「⚡ 1」というテキストで呼ばれる
  - テキストスタイルが`{ fontSize: '12px' }`である
  - **期待結果の理由**: プレイヤーがカードコストを視覚的に識別できる必要がある
- **テストの目的**: カードコストが要件定義通りに表示されることを確認
  - **確認ポイント**: Card.costプロパティの値が正しくフォーマットされること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと要件定義書に基づく

#### TC-CARD-UI-004: getCard()メソッド

- **テスト名**: getCard()でカードエンティティを取得できる
  - **何をテストするか**: CardUIが保持しているCardエンティティを取得できること
  - **期待される動作**: コンストラクタで渡したCardインスタンスと同一のものが返される
- **入力値**:
  ```typescript
  const card = Card('card-001', gatheringCardMaster);
  const cardUI = new CardUI(scene, { card, x: 0, y: 0 });
  ```
  - **入力データの意味**: CardUIに渡したCardインスタンスの参照を保持
- **期待される結果**:
  - `cardUI.getCard()`が元のcardインスタンスを返す（参照が同一）
  - **期待結果の理由**: HandDisplayなどの親コンポーネントがカード情報にアクセスできる必要がある
- **テストの目的**: CardUIが正しくCardエンティティへの参照を保持していることを確認
  - **確認ポイント**: カードデータが適切にカプセル化されていること
- 🔵 このテストケースの信頼性レベル: 実装ファイルに基づく

### 4.2 CardUI - カードタイプ別色分け

#### TC-CARD-UI-005: 採取カードは緑色

- **テスト名**: 採取カードの背景は緑色(0x90ee90)
  - **何をテストするか**: CardType.GATHERINGのカードがLightGreen色で表示されること
  - **期待される動作**: 背景Rectangleが0x90ee90の色で生成される
- **入力値**:
  ```typescript
  {
    card: Card('card-001', { type: CardType.GATHERING, ... }),
    x: 0,
    y: 0
  }
  ```
  - **入力データの意味**: 採取カードタイプを持つカードを表示
- **期待される結果**:
  - `scene.add.rectangle(0, 0, 120, 160, 0x90ee90)`が呼ばれる
  - **期待結果の理由**: プレイヤーがカードタイプを色で素早く識別できる必要がある
- **テストの目的**: カードタイプ別の色分けルールが正しく実装されていることを確認
  - **確認ポイント**: getCardTypeColor()メソッドが正しいカラーコードを返すこと
- 🔵 このテストケースの信頼性レベル: 実装ファイルとタスクファイルに明記

#### TC-CARD-UI-006: レシピカードはピンク色

- **テスト名**: レシピカードの背景はピンク色(0xffb6c1)
  - **何をテストするか**: CardType.RECIPEのカードがLightPink色で表示されること
  - **期待される動作**: 背景Rectangleが0xffb6c1の色で生成される
- **入力値**:
  ```typescript
  {
    card: Card('card-002', { type: CardType.RECIPE, ... }),
    x: 0,
    y: 0
  }
  ```
  - **入力データの意味**: レシピカードタイプを持つカードを表示
- **期待される結果**:
  - `scene.add.rectangle(0, 0, 120, 160, 0xffb6c1)`が呼ばれる
  - **期待結果の理由**: プレイヤーがカードタイプを色で素早く識別できる必要がある
- **テストの目的**: カードタイプ別の色分けルールが正しく実装されていることを確認
  - **確認ポイント**: getCardTypeColor()メソッドが正しいカラーコードを返すこと
- 🔵 このテストケースの信頼性レベル: 実装ファイルとタスクファイルに明記

#### TC-CARD-UI-007: 強化カードは青色

- **テスト名**: 強化カードの背景は青色(0xadd8e6)
  - **何をテストするか**: CardType.ENHANCEMENTのカードがLightBlue色で表示されること
  - **期待される動作**: 背景Rectangleが0xadd8e6の色で生成される
- **入力値**:
  ```typescript
  {
    card: Card('card-003', { type: CardType.ENHANCEMENT, ... }),
    x: 0,
    y: 0
  }
  ```
  - **入力データの意味**: 強化カードタイプを持つカードを表示
- **期待される結果**:
  - `scene.add.rectangle(0, 0, 120, 160, 0xadd8e6)`が呼ばれる
  - **期待結果の理由**: プレイヤーがカードタイプを色で素早く識別できる必要がある
- **テストの目的**: カードタイプ別の色分けルールが正しく実装されていることを確認
  - **確認ポイント**: getCardTypeColor()メソッドが正しいカラーコードを返すこと
- 🔵 このテストケースの信頼性レベル: 実装ファイルとタスクファイルに明記

### 4.3 CardUI - インタラクティブ機能

#### TC-CARD-UI-008: interactiveがtrueの場合、イベントリスナーが設定される

- **テスト名**: インタラクティブモードでイベントが設定される
  - **何をテストするか**: interactive: trueの場合、背景にpointerover/out/downイベントが設定されること
  - **期待される動作**: 背景Rectangleが`setInteractive({ useHandCursor: true })`で設定され、3つのイベントリスナーが登録される
- **入力値**:
  ```typescript
  {
    card: Card('card-001', gatheringCardMaster),
    x: 0,
    y: 0,
    interactive: true
  }
  ```
  - **入力データの意味**: インタラクティブモードでカードを表示
- **期待される結果**:
  - `mockRectangle.setInteractive({ useHandCursor: true })`が呼ばれる
  - `mockRectangle.on('pointerover', ...)`が呼ばれる
  - `mockRectangle.on('pointerout', ...)`が呼ばれる
  - `mockRectangle.on('pointerdown', ...)`が呼ばれる
  - **期待結果の理由**: プレイヤーがカードとインタラクションできる必要がある
- **テストの目的**: インタラクティブ機能の初期化が正しく動作することを確認
  - **確認ポイント**: setupInteraction()メソッドが正しく呼ばれ、イベントリスナーが登録されること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-CARD-UI-009: ホバー時にスケールアニメーションが開始される

- **テスト名**: ホバー時にカードが1.1倍に拡大される
  - **何をテストするか**: pointeroverイベントでTweenアニメーションが開始されること
  - **期待される動作**: コンテナのscaleX/scaleYが1.1に、100msでアニメーションされる
- **入力値**:
  ```typescript
  {
    card: Card('card-001', gatheringCardMaster),
    x: 0,
    y: 0,
    interactive: true
  }
  ```
  - **入力データの意味**: インタラクティブモードでカードを表示し、ホバーイベントをシミュレート
- **期待される結果**:
  - `scene.tweens.add`が以下のパラメータで呼ばれる:
    ```typescript
    {
      targets: container,
      scaleX: 1.1,
      scaleY: 1.1,
      duration: 100,
      ease: 'Power2'
    }
    ```
  - **期待結果の理由**: ホバー時のフィードバックでカードが選択可能であることを示す
- **テストの目的**: ホバー時のアニメーション効果が正しく動作することを確認
  - **確認ポイント**: Tweenアニメーションのパラメータが要件通りであること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-CARD-UI-010: ホバー解除時に元のサイズに戻る

- **テスト名**: ホバー解除時にカードが元のサイズに戻る
  - **何をテストするか**: pointeroutイベントでTweenアニメーションが開始されること
  - **期待される動作**: コンテナのscaleX/scaleYが1.0に、100msでアニメーションされる
- **入力値**: (TC-CARD-UI-009と同様)
  - **入力データの意味**: ホバー後にマウスカーソルが外れる動作をシミュレート
- **期待される結果**:
  - `scene.tweens.add`が以下のパラメータで呼ばれる:
    ```typescript
    {
      targets: container,
      scaleX: 1,
      scaleY: 1,
      duration: 100,
      ease: 'Power2'
    }
    ```
  - **期待結果の理由**: カードが元のサイズに戻り、他のカードとの視覚的整合性を保つ
- **テストの目的**: ホバー解除時のアニメーション効果が正しく動作することを確認
  - **確認ポイント**: Tweenアニメーションが正しく元のサイズに戻すこと
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-CARD-UI-011: クリック時にコールバックが実行される

- **テスト名**: クリック時にonClickコールバックが実行される
  - **何をテストするか**: pointerdownイベントでonClickコールバックが呼ばれること
  - **期待される動作**: onClickコールバックがCardエンティティを引数として実行される
- **入力値**:
  ```typescript
  const onClickMock = vi.fn();
  {
    card: Card('card-001', gatheringCardMaster),
    x: 0,
    y: 0,
    interactive: true,
    onClick: onClickMock
  }
  ```
  - **入力データの意味**: クリック時のコールバックを設定し、クリックイベントをシミュレート
- **期待される結果**:
  - `onClickMock`が1回呼ばれる
  - 引数として`gatheringCard`が渡される
  - **期待結果の理由**: 親コンポーネント（HandDisplay）がカードクリックイベントを受け取る必要がある
- **テストの目的**: クリックイベントのコールバックが正しく動作することを確認
  - **確認ポイント**: オプショナルチェイニング(`?.`)が正しく動作し、コールバックがある場合のみ実行されること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

### 4.4 HandDisplay - 基本表示

#### TC-HAND-001: HandDisplayの正常生成

- **テスト名**: HandDisplayが正常に生成される
  - **何をテストするか**: HandDisplayがカード配列を受け取り、正常にインスタンス化されること
  - **期待される動作**: エラーなく生成され、すべてのCardUIが作成される
- **入力値**:
  ```typescript
  {
    x: 640,
    y: 600,
    cards: [card1, card2, card3]
  }
  ```
  - **入力データの意味**: 画面下部に3枚のカードを持つ手札を表示
- **期待される結果**:
  - HandDisplayインスタンスが生成される
  - 3つのCardUIが作成される
  - `mockContainer.add`が3回呼ばれる（各CardUIのコンテナが追加される）
  - `getCardCount()`が3を返す
  - **期待結果の理由**: 手札の初期化が正しく行われ、すべてのカードが表示される必要がある
- **テストの目的**: HandDisplayの基本的な初期化処理が正常に動作することを確認
  - **確認ポイント**: BaseComponentの継承とcreateCardUIs()メソッドが正しく動作すること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-002: 5枚のカードが横並びで表示される

- **テスト名**: 最大5枚のカードが横並びで表示される
  - **何をテストするか**: 5枚のカードが正しい間隔で横並びに配置されること
  - **期待される動作**: カード間スペーシング140pxで中央揃えに配置される
- **入力値**:
  ```typescript
  {
    x: 640,
    y: 600,
    cards: [card1, card2, card3, card4, card5]
  }
  ```
  - **入力データの意味**: 最大枚数（5枚）のカードを持つ手札を表示
- **期待される結果**:
  - `getCardCount()`が5を返す
  - 5つのCardUIが作成される
  - CardUIの配置座標が以下の通り:
    - card1: x = -280 (startX + 0 * 140)
    - card2: x = -140 (startX + 1 * 140)
    - card3: x = 0    (startX + 2 * 140)
    - card4: x = 140  (startX + 3 * 140)
    - card5: x = 280  (startX + 4 * 140)
  - **期待結果の理由**: 手札が画面幅内に収まり、視覚的にバランスよく配置される必要がある
- **テストの目的**: レイアウト計算ロジックが正しく動作することを確認
  - **確認ポイント**: 中央揃えの計算（totalWidth, startX）が正確であること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-003: 空の手札でもエラーにならない

- **テスト名**: カード配列が空でも正常に動作する
  - **何をテストするか**: cards: []の場合でもエラーにならないこと
  - **期待される動作**: 正常に生成されるが、CardUIは作成されない
- **入力値**:
  ```typescript
  {
    x: 640,
    y: 600,
    cards: []
  }
  ```
  - **入力データの意味**: 手札が空の状態（ゲーム開始時や全カード使用後）
- **期待される結果**:
  - エラーがスローされない
  - `getCardCount()`が0を返す
  - CardUIが作成されない
  - **期待結果の理由**: ゲームの特定の状態（手札空）でもUIが壊れない堅牢性が必要
- **テストの目的**: エッジケース（空配列）でも安全に動作することを確認
  - **確認ポイント**: 配列操作（forEach）が空配列でもエラーにならないこと
- 🔵 このテストケースの信頼性レベル: 既存テストに基づく

### 4.5 HandDisplay - カード選択管理

#### TC-HAND-004: setSelectedIndex()でカードを選択できる

- **テスト名**: カード選択状態を設定できる
  - **何をテストするか**: setSelectedIndex(index)で選択状態が更新されること
  - **期待される動作**: 選択されたカードが上に移動し、選択インデックスが保持される
- **入力値**:
  ```typescript
  handDisplay.setSelectedIndex(1);
  ```
  - **入力データの意味**: 2番目のカード（インデックス1）を選択
- **期待される結果**:
  - `getSelectedIndex()`が1を返す
  - `scene.tweens.add`が以下のパラメータで呼ばれる:
    ```typescript
    {
      targets: cardUI[1].getContainer(),
      y: -20,
      duration: 150,
      ease: 'Power2'
    }
    ```
  - **期待結果の理由**: プレイヤーが選択したカードを視覚的に識別できる必要がある
- **テストの目的**: カード選択ロジックが正しく動作することを確認
  - **確認ポイント**: highlightCard()メソッドが正しく呼ばれ、アニメーションが開始されること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-005: getSelectedCard()で選択中のカードを取得できる

- **テスト名**: 選択中のCardエンティティを取得できる
  - **何をテストするか**: getSelectedCard()が選択中のCardインスタンスを返すこと
  - **期待される動作**: setSelectedIndex()で選択したカードと同一のインスタンスが返される
- **入力値**:
  ```typescript
  const cards = [card1, card2, card3];
  handDisplay.setSelectedIndex(1);
  const selectedCard = handDisplay.getSelectedCard();
  ```
  - **入力データの意味**: 2番目のカードを選択し、Cardエンティティを取得
- **期待される結果**:
  - `selectedCard`が`card2`と同一のインスタンスである（参照が一致）
  - **期待結果の理由**: 親コンポーネント（MainScene）が選択されたカードの情報を使用できる必要がある
- **テストの目的**: 選択状態の管理が正しく動作することを確認
  - **確認ポイント**: 選択インデックスと実際のカード配列が正しく紐づいていること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-006: 選択を別のカードに変更できる

- **テスト名**: 選択状態を別のカードに変更できる
  - **何をテストするか**: 別のカードを選択すると、前のカードの強調が解除されること
  - **期待される動作**: 前のカードが元の位置に戻り、新しいカードが上に移動する
- **入力値**:
  ```typescript
  handDisplay.setSelectedIndex(0);
  handDisplay.setSelectedIndex(1);
  ```
  - **入力データの意味**: 最初のカードを選択後、2番目のカードに変更
- **期待される結果**:
  - `getSelectedIndex()`が1を返す
  - `scene.tweens.add`が2回呼ばれる:
    1. card[0]のy座標を0に戻す（clearSelection）
    2. card[1]のy座標を-20に移動（highlightCard）
  - **期待結果の理由**: 一度に1枚のカードのみが選択状態を保持する必要がある
- **テストの目的**: 選択の切り替えロジックが正しく動作することを確認
  - **確認ポイント**: 前の選択の解除処理が正しく実行されること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-007: setSelectedIndex(null)で選択を解除できる

- **テスト名**: nullを渡すことで選択を解除できる
  - **何をテストするか**: setSelectedIndex(null)で選択状態がクリアされること
  - **期待される動作**: 選択中のカードが元の位置に戻り、選択インデックスがnullになる
- **入力値**:
  ```typescript
  handDisplay.setSelectedIndex(1);
  handDisplay.setSelectedIndex(null);
  ```
  - **入力データの意味**: カードを選択後、選択を解除
- **期待される結果**:
  - `getSelectedIndex()`がnullを返す
  - `getSelectedCard()`がnullを返す
  - `scene.tweens.add`が呼ばれる（card[1]のy座標を0に戻す）
  - **期待結果の理由**: プレイヤーが選択をキャンセルできる必要がある
- **テストの目的**: 選択解除ロジックが正しく動作することを確認
  - **確認ポイント**: nullを適切にハンドリングし、nullチェックが正しく動作すること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

### 4.6 HandDisplay - 手札更新

#### TC-HAND-008: updateCards()で手札を更新できる

- **テスト名**: 手札のカード配列を動的に更新できる
  - **何をテストするか**: updateCards()で手札が新しいカード配列に置き換わること
  - **期待される動作**: 既存のCardUIが破棄され、新しいCardUIが作成される
- **入力値**:
  ```typescript
  const initialCards = [card1, card2, card3];
  const updatedCards = [card4];
  handDisplay.updateCards(updatedCards);
  ```
  - **入力データの意味**: 3枚の手札から1枚の手札に更新（カードプレイ後など）
- **期待される結果**:
  - `getCardCount()`が1を返す
  - 既存のCardUIの`destroy()`が呼ばれる
  - 新しいCardUIが作成される
  - **期待結果の理由**: ゲームの進行に応じて手札が動的に変化する必要がある
- **テストの目的**: 手札更新ロジックが正しく動作することを確認
  - **確認ポイント**: メモリリークが発生せず、古いCardUIが適切に破棄されること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-009: updateCards()で選択状態がリセットされる

- **テスト名**: 手札更新時に選択状態がクリアされる
  - **何をテストするか**: updateCards()実行後、selectedIndexがnullになること
  - **期待される動作**: 選択状態がリセットされ、新しい手札で再選択が必要になる
- **入力値**:
  ```typescript
  handDisplay.setSelectedIndex(1);
  handDisplay.updateCards([card4]);
  ```
  - **入力データの意味**: カードを選択後、手札を更新
- **期待される結果**:
  - `getSelectedIndex()`がnullを返す
  - `getSelectedCard()`がnullを返す
  - **期待結果の理由**: 更新前の選択インデックスが新しい配列で無効になる可能性があるため、安全のためリセットする
- **テストの目的**: 選択状態の整合性が保たれることを確認
  - **確認ポイント**: selectedIndexが適切にnullにリセットされること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

---

## 5. 異常系テストケース（エラーハンドリング）

### 5.1 CardUI - バリデーション

#### TC-CARD-UI-ERR-001: cardがnullの場合はエラー

- **テスト名**: cardが指定されていない場合にエラーをスローする
  - **エラーケースの概要**: 必須パラメータcardがnullまたはundefinedの場合
  - **エラー処理の重要性**: カード情報なしではUIを生成できないため、早期にエラーを検出する必要がある
- **入力値**:
  ```typescript
  {
    card: null as unknown as Card,
    x: 0,
    y: 0
  }
  ```
  - **不正な理由**: cardは必須パラメータであり、nullは許容されない
  - **実際の発生シナリオ**: プログラミングミス、または不正なAPIレスポンス
- **期待される結果**:
  - エラーがスローされる
  - エラーメッセージ: "CardUI: card is required"
  - **エラーメッセージの内容**: 開発者がすぐに問題を特定できる明確なメッセージ
  - **システムの安全性**: 不正な状態でのUI生成を防ぎ、予期しない動作を回避する
- **テストの目的**: 入力バリデーションが正しく動作することを確認
  - **品質保証の観点**: フェイルファストの原則に従い、早期にエラーを検出する
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

### 5.2 HandDisplay - バリデーション

#### TC-HAND-ERR-001: cardsがnullの場合はエラー

- **テスト名**: cards配列が指定されていない場合にエラーをスローする
  - **エラーケースの概要**: 必須パラメータcardsがnullまたはundefinedの場合
  - **エラー処理の重要性**: カード配列なしでは手札を表示できないため、早期にエラーを検出する必要がある
- **入力値**:
  ```typescript
  {
    cards: null as unknown as Card[],
    x: 0,
    y: 0
  }
  ```
  - **不正な理由**: cardsは必須パラメータであり、nullは許容されない
  - **実際の発生シナリオ**: プログラミングミス、または状態管理の不具合
- **期待される結果**:
  - エラーがスローされる
  - エラーメッセージ: "HandDisplay: cards array is required"
  - **エラーメッセージの内容**: 開発者が問題を特定しやすい明確なメッセージ
  - **システムの安全性**: 不正な状態での手札生成を防ぐ
- **テストの目的**: 入力バリデーションが正しく動作することを確認
  - **品質保証の観点**: フェイルファストの原則に従い、エラーを早期検出する
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-ERR-002: 6枚以上のカードを指定するとエラー

- **テスト名**: 手札枚数が最大値を超える場合にエラーをスローする
  - **エラーケースの概要**: cards配列のlengthが5を超える場合
  - **エラー処理の重要性**: 画面レイアウトの破綻を防ぎ、ゲームバランスを保つため
- **入力値**:
  ```typescript
  {
    cards: [card1, card2, card3, card4, card5, card6],
    x: 0,
    y: 0
  }
  ```
  - **不正な理由**: 手札の最大枚数は5枚に制限されている（仕様）
  - **実際の発生シナリオ**: ゲームロジックのバグ、またはカードドロー処理のミス
- **期待される結果**:
  - エラーがスローされる
  - エラーメッセージ: "HandDisplay: cards array exceeds maximum size of 5"
  - **エラーメッセージの内容**: 制限値を明示し、問題解決を容易にする
  - **システムの安全性**: 画面外にカードがはみ出すことを防ぐ
- **テストの目的**: 手札枚数制限が正しく実装されていることを確認
  - **品質保証の観点**: ゲームルールの制約がコード上でも保証される
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-ERR-003: updateCards()で6枚以上を指定するとエラー

- **テスト名**: 手札更新時に最大値を超える枚数を指定するとエラー
  - **エラーケースの概要**: updateCards()の引数が6枚以上の配列の場合
  - **エラー処理の重要性**: 初期生成だけでなく、更新時も制約を守る必要がある
- **入力値**:
  ```typescript
  handDisplay.updateCards([card1, card2, card3, card4, card5, card6]);
  ```
  - **不正な理由**: 手札の最大枚数制限（5枚）を超える
  - **実際の発生シナリオ**: カードドロー処理のバグ、または状態管理の不具合
- **期待される結果**:
  - エラーがスローされる
  - エラーメッセージ: "HandDisplay: cards array exceeds maximum size of 5"
  - **エラーメッセージの内容**: 初期生成時と同じエラーメッセージで一貫性を保つ
  - **システムの安全性**: 実行時にも制約が守られることを保証
- **テストの目的**: 更新時のバリデーションが正しく動作することを確認
  - **品質保証の観点**: 初期生成と更新で同じ制約が適用されることを保証
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

---

## 6. 境界値テストケース（最小値、最大値、null等）

### 6.1 CardUI - 境界値

#### TC-CARD-UI-BOUND-001: interactiveがfalseの場合、イベントリスナーは設定されない

- **テスト名**: インタラクティブ無効時はイベントが設定されない
  - **境界値の意味**: interactive: falseは非インタラクティブモードの境界値
  - **境界値での動作保証**: インタラクティブ機能が完全に無効化されること
- **入力値**:
  ```typescript
  {
    card: Card('card-001', gatheringCardMaster),
    x: 0,
    y: 0,
    interactive: false
  }
  ```
  - **境界値選択の根拠**: interactive: falseは「イベントなし」と「イベントあり」の境界
  - **実際の使用場面**: デッキビューや実績画面での非インタラクティブなカード表示
- **期待される結果**:
  - `mockRectangle.setInteractive`が呼ばれない
  - `mockRectangle.on`が呼ばれない（イベントリスナー登録なし）
  - **境界での正確性**: interactiveフラグが正確にイベント設定を制御すること
  - **一貫した動作**: interactiveがfalse/undefinedの両方で同じ動作をすること
- **テストの目的**: インタラクティブフラグの制御が正しく動作することを確認
  - **堅牢性の確認**: 非インタラクティブモードでも安定動作すること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-CARD-UI-BOUND-002: 未知のカードタイプは白色

- **テスト名**: 未知のカードタイプでも安全にフォールバック
  - **境界値の意味**: 定義されていないカードタイプは境界外のケース
  - **境界値での動作保証**: エラーにならず、デフォルト色で表示されること
- **入力値**:
  ```typescript
  {
    card: Card('card-999', { type: 'UNKNOWN', ... }),
    x: 0,
    y: 0
  }
  ```
  - **境界値選択の根拠**: 既知のカードタイプ（GATHERING/RECIPE/ENHANCEMENT）の範囲外
  - **実際の使用場面**: 将来的な拡張や、マスターデータの不整合
- **期待される結果**:
  - `scene.add.rectangle(0, 0, 120, 160, 0xffffff)`が呼ばれる（白色）
  - エラーがスローされない
  - **境界での正確性**: switch文のdefaultケースが正しく動作すること
  - **一貫した動作**: 未知のタイプでもUIが壊れないこと
- **テストの目的**: 予期しないデータでも安全に動作することを確認
  - **堅牢性の確認**: フォールバック処理が適切に実装されていること
- 🔵 このテストケースの信頼性レベル: 実装ファイルに基づく

### 6.2 HandDisplay - 境界値

#### TC-HAND-BOUND-001: 手札が0枚（空配列）

- **テスト名**: 手札が空でも正常動作する
  - **境界値の意味**: cards.length = 0は手札枚数の最小境界値
  - **境界値での動作保証**: エラーにならず、空の手札が表示されること
- **入力値**:
  ```typescript
  {
    cards: [],
    x: 640,
    y: 600
  }
  ```
  - **境界値選択の根拠**: 手札枚数の最小値（0枚）
  - **実際の使用場面**: ゲーム開始時、またはすべてのカードを使い切った後
- **期待される結果**:
  - エラーがスローされない
  - `getCardCount()`が0を返す
  - CardUIが作成されない
  - **境界での正確性**: 空配列のforEachが安全に動作すること
  - **一貫した動作**: 空の手札でも他の機能（選択、更新）が動作すること
- **テストの目的**: 最小境界値で安全に動作することを確認
  - **堅牢性の確認**: エッジケースでもクラッシュしないこと
- 🔵 このテストケースの信頼性レベル: 既存テストに基づく

#### TC-HAND-BOUND-002: 手札が5枚（最大枚数）

- **テスト名**: 手札が最大枚数でも正常動作する
  - **境界値の意味**: cards.length = 5は手札枚数の最大境界値
  - **境界値での動作保証**: すべてのカードが正しく配置され、画面内に収まること
- **入力値**:
  ```typescript
  {
    cards: [card1, card2, card3, card4, card5],
    x: 640,
    y: 600
  }
  ```
  - **境界値選択の根拠**: 手札枚数の最大値（5枚）
  - **実際の使用場面**: 通常のゲームプレイ中（最大手札）
- **期待される結果**:
  - エラーがスローされない
  - `getCardCount()`が5を返す
  - 5つのCardUIが作成される
  - すべてのカードが画面内に収まる（レイアウト計算が正確）
  - **境界での正確性**: 5枚時のレイアウト計算が正確であること
  - **一貫した動作**: 最大枚数でも選択やアニメーションが正常動作すること
- **テストの目的**: 最大境界値で安全に動作することを確認
  - **堅牢性の確認**: 最大枚数でもUIが破綻しないこと
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

#### TC-HAND-BOUND-003: 範囲外のインデックスで選択

- **テスト名**: 存在しないインデックスで選択しても安全
  - **境界値の意味**: selectedIndex >= cards.lengthは配列範囲外の境界値
  - **境界値での動作保証**: エラーにならず、選択が無効化されること
- **入力値**:
  ```typescript
  const handDisplay = new HandDisplay(scene, {
    cards: [card1, card2, card3],
    x: 0,
    y: 0
  });
  handDisplay.setSelectedIndex(999);
  ```
  - **境界値選択の根拠**: 配列の有効範囲（0-2）を超えるインデックス
  - **実際の使用場面**: プログラミングミス、または状態同期の不具合
- **期待される結果**:
  - エラーがスローされない（防御的プログラミング）
  - `getSelectedIndex()`が999を返す（設定はされる）
  - `getSelectedCard()`がnullを返す（配列範囲外）
  - アニメーションは実行されない（cardUIs[999]がundefined）
  - **境界での正確性**: 範囲外インデックスでもクラッシュしないこと
  - **一貫した動作**: nullチェックが適切に機能すること
- **テストの目的**: 範囲外の値でも安全に動作することを確認
  - **堅牢性の確認**: 防御的プログラミングが実装されていること
- 🟡 このテストケースの信頼性レベル: 実装ファイルから推測（明示的なバリデーションなし）

---

## 7. メモリ管理・リソース解放テストケース

### 7.1 CardUI - destroy()

#### TC-CARD-UI-DESTROY-001: destroy()ですべてのGameObjectsが破棄される

- **テスト名**: destroy()メソッドで全リソースが解放される
  - **何をテストするか**: destroy()実行時にすべてのGameObjectsとコンテナが破棄されること
  - **期待される動作**: メモリリークが発生せず、すべてのリソースが適切に解放される
- **入力値**:
  ```typescript
  const cardUI = new CardUI(scene, { card, x: 0, y: 0 });
  cardUI.destroy();
  ```
  - **入力データの意味**: CardUIを生成後、即座に破棄
- **期待される結果**:
  - `background.destroy()`が呼ばれる
  - `iconPlaceholder.destroy()`が呼ばれる
  - `nameText.destroy()`が呼ばれる
  - `costText.destroy()`が呼ばれる
  - `effectText.destroy()`が呼ばれる
  - `container.destroy()`が呼ばれる
  - **期待結果の理由**: メモリリークを防ぎ、長時間のゲームプレイでもパフォーマンスを維持する
- **テストの目的**: リソース管理が正しく実装されていることを確認
  - **確認ポイント**: すべてのGameObjectsに対してdestroy()が呼ばれること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

### 7.2 HandDisplay - destroy()

#### TC-HAND-DESTROY-001: destroy()ですべてのCardUIが破棄される

- **テスト名**: destroy()メソッドで全CardUIが破棄される
  - **何をテストするか**: destroy()実行時にすべてのCardUIとコンテナが破棄されること
  - **期待される動作**: メモリリークが発生せず、すべてのCardUIリソースが適切に解放される
- **入力値**:
  ```typescript
  const handDisplay = new HandDisplay(scene, {
    cards: [card1, card2, card3],
    x: 0,
    y: 0
  });
  handDisplay.destroy();
  ```
  - **入力データの意味**: HandDisplayを生成後、即座に破棄
- **期待される結果**:
  - 各CardUIの`destroy()`が呼ばれる（3回）
  - `container.destroy()`が呼ばれる
  - `cardUIs`配列が空になる
  - **期待結果の理由**: 大量のカード表示でもメモリリークを防ぐ
- **テストの目的**: リソース管理が正しく実装されていることを確認
  - **確認ポイント**: 子コンポーネント（CardUI）も含めてすべて破棄されること
- 🔵 このテストケースの信頼性レベル: 実装ファイルと既存テストに基づく

---

## 8. テストケース実装時の日本語コメント指針

### 8.1 テストケース開始時のコメント

すべてのテストケースの開始時には以下のコメントを含めること:

```typescript
// 【テスト目的】: CardUIが正常に生成され、すべてのGameObjectsが作成されることを確認
// 【テスト内容】: CardUIコンストラクタを呼び出し、create()メソッドが実行されることを検証
// 【期待される動作】: エラーなく生成され、背景、アイコン、テキストが作成される
// 🔵 信頼性レベル: 実装ファイルと既存テストに基づく
```

### 8.2 Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: 採取カードのマスターデータを用意
// 【初期条件設定】: Phaserシーンのモックを作成し、CardUIの依存を注入
// 【前提条件確認】: モックが正しく動作することを確認
const gatheringMaster: CardMaster = {
  id: 'gather_001',
  name: '採取カード',
  type: CardType.GATHERING,
  baseCost: 1,
  materialPool: ['herb', 'stone', 'wood'],
  baseQuantity: 3,
  rarity: 'COMMON',
};
const card = new Card('card-001' as CardId, gatheringMaster);
```

### 8.3 When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: CardUIコンストラクタを呼び出し、create()を実行
// 【処理内容】: カードUIの初期化処理が実行される
// 【実行タイミング】: コンストラクタ内でthis.create()が呼ばれる
const cardUI = new CardUI(scene, {
  card: card,
  x: 100,
  y: 200,
  interactive: false,
});
```

### 8.4 Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: すべてのGameObjectsが作成されたことを確認
// 【期待値確認】: scene.add.rectangleが背景とアイコン用に2回呼ばれる
// 【品質保証】: CardUIの初期化が完全に行われ、メモリリークがないことを保証
expect(scene.add.rectangle).toHaveBeenCalledTimes(2); // 【確認内容】: 背景とアイコンプレースホルダーが作成される
expect(scene.add.text).toHaveBeenCalledTimes(3); // 【確認内容】: 名前、コスト、効果テキストが作成される
expect(mockContainer.add).toHaveBeenCalled(); // 【確認内容】: コンテナにGameObjectsが追加される
```

### 8.5 セットアップ・クリーンアップのコメント

```typescript
beforeEach(() => {
  // 【テスト前準備】: 各テスト実行前にモックをリセットし、クリーンな環境を用意
  // 【環境初期化】: Phaserシーンのモックと各GameObjectsのモックを作成
  // 【理由】: テスト間の依存を排除し、独立したテストを実現するため
  mockRectangle = {
    setStrokeStyle: vi.fn().mockReturnThis(),
    setInteractive: vi.fn().mockReturnThis(),
    on: vi.fn().mockReturnThis(),
    destroy: vi.fn(),
  };
  // ... 他のモック初期化
});

afterEach(() => {
  // 【テスト後処理】: 各テスト実行後にリソースをクリーンアップ
  // 【状態復元】: 次のテストに影響しないようモックをクリア
  // 【理由】: メモリリークを防ぎ、テストスイート全体のパフォーマンスを保つため
  vi.clearAllMocks();
});
```

---

## 9. テストケース対応表

### 9.1 要件定義書との対応

| テストケースID | 対応する要件 | 要件定義書のセクション | 信頼性 |
|---------------|-------------|---------------------|--------|
| TC-CARD-UI-001 | REQ-UI-001 | 2.1 CardUIコンポーネント | 🔵 |
| TC-CARD-UI-002 | REQ-UI-003 | 2.1 CardUIコンポーネント（表示内容） | 🔵 |
| TC-CARD-UI-003 | REQ-UI-003 | 2.1 CardUIコンポーネント（表示内容） | 🔵 |
| TC-CARD-UI-005 | REQ-UI-002 | 2.1 CardUIコンポーネント（カードタイプ別の背景色） | 🔵 |
| TC-CARD-UI-006 | REQ-UI-002 | 2.1 CardUIコンポーネント（カードタイプ別の背景色） | 🔵 |
| TC-CARD-UI-007 | REQ-UI-002 | 2.1 CardUIコンポーネント（カードタイプ別の背景色） | 🔵 |
| TC-CARD-UI-008 | REQ-UI-004 | 2.1 CardUIコンポーネント（インタラクティブ機能） | 🔵 |
| TC-CARD-UI-009 | REQ-UI-004 | 2.1 CardUIコンポーネント（ホバー時の拡大） | 🔵 |
| TC-CARD-UI-011 | REQ-UI-004 | 2.1 CardUIコンポーネント（クリックイベント） | 🔵 |
| TC-HAND-001 | REQ-UI-005 | 2.2 HandDisplayコンポーネント | 🔵 |
| TC-HAND-002 | REQ-UI-005 | 2.2 HandDisplayコンポーネント（レイアウト仕様） | 🔵 |
| TC-HAND-004 | REQ-UI-006 | 2.2 HandDisplayコンポーネント（選択時の移動） | 🔵 |
| TC-CARD-UI-ERR-001 | EDGE-UI-001 | 4.2 エッジケース（E-001） | 🔵 |
| TC-HAND-ERR-002 | EDGE-UI-002 | 4.2 エッジケース（E-002） | 🔵 |
| TC-CARD-UI-DESTROY-001 | NFR-MEM-001 | 3.2 パフォーマンス要件（メモリ管理要件） | 🔵 |
| TC-HAND-DESTROY-001 | NFR-MEM-001 | 3.2 パフォーマンス要件（メモリ管理要件） | 🔵 |

### 9.2 タスクファイルの統合テストとの対応

| テストID（タスクファイル） | 対応するテストケース | 信頼性 |
|------------------------|------------------|--------|
| T-0021-01: カード表示 | TC-CARD-UI-001, TC-CARD-UI-002, TC-CARD-UI-003 | 🔵 |
| T-0021-02: タイプ別色 | TC-CARD-UI-005, TC-CARD-UI-006, TC-CARD-UI-007 | 🔵 |
| T-0021-03: 手札表示 | TC-HAND-001, TC-HAND-002 | 🔵 |
| T-0021-04: カード選択 | TC-HAND-004, TC-HAND-005, TC-HAND-006 | 🔵 |

---

## 10. テストケースサマリー

### 10.1 テストケース分類統計

| 分類 | 件数 | テストケースID |
|------|------|--------------|
| **正常系** | 21 | TC-CARD-UI-001 〜 TC-HAND-009 |
| **異常系** | 4 | TC-CARD-UI-ERR-001, TC-HAND-ERR-001 〜 003 |
| **境界値** | 4 | TC-CARD-UI-BOUND-001 〜 002, TC-HAND-BOUND-001 〜 003 |
| **メモリ管理** | 2 | TC-CARD-UI-DESTROY-001, TC-HAND-DESTROY-001 |
| **合計** | 31 | - |

### 10.2 信頼性レベルの分布

| 信頼性レベル | 件数 | 割合 |
|------------|------|------|
| 🔵 青信号（高信頼性） | 30 | 96.8% |
| 🟡 黄信号（妥当な推測） | 1 | 3.2% |
| 🔴 赤信号（要確認） | 0 | 0% |

### 10.3 カバレッジ目標

| カテゴリ | 目標カバレッジ | 備考 |
|---------|--------------|------|
| **ステートメントカバレッジ** | 95%以上 | すべての実行行をテスト |
| **ブランチカバレッジ** | 90%以上 | すべての条件分岐をテスト |
| **関数カバレッジ** | 100% | すべての公開メソッドをテスト |

---

## 11. 実装ファイルとの対応

### 11.1 テスト対象ファイル

| ファイルパス | 説明 | 信頼性 |
|-------------|------|--------|
| `atelier-guild-rank/src/presentation/ui/components/CardUI.ts` | CardUIコンポーネント実装 | 🔵 |
| `atelier-guild-rank/src/presentation/ui/components/HandDisplay.ts` | HandDisplayコンポーネント実装 | 🔵 |

### 11.2 テストファイル

| ファイルパス | 説明 | 信頼性 |
|-------------|------|--------|
| `atelier-guild-rank/src/presentation/ui/components/CardUI.spec.ts` | CardUIのユニットテスト | 🔵 |
| `atelier-guild-rank/src/presentation/ui/components/HandDisplay.spec.ts` | HandDisplayのユニットテスト | 🔵 |

### 11.3 依存ファイル

| ファイルパス | 説明 | 信頼性 |
|-------------|------|--------|
| `atelier-guild-rank/src/presentation/ui/components/BaseComponent.ts` | 基底クラス | 🔵 |
| `atelier-guild-rank/src/domain/entities/Card.ts` | Cardエンティティ | 🔵 |
| `atelier-guild-rank/src/shared/types/common.ts` | 共通型定義 | 🔵 |
| `atelier-guild-rank/src/shared/types/master-data.ts` | マスターデータ型定義 | 🔵 |

---

## 12. 次のステップ

### 12.1 Redフェーズ（失敗テスト作成）

次のコマンドで失敗するテストケースを作成:
```bash
/tdd-red atelier-guild-rank TASK-0021
```

### 12.2 実装の流れ

1. **Redフェーズ**: 失敗するテストケースを作成
2. **Greenフェーズ**: テストを通す最小限の実装
3. **Refactorフェーズ**: コードの品質向上とリファクタリング
4. **レビュー**: コードレビューと品質チェック

---

## 変更履歴

| 日付 | バージョン | 変更内容 |
|------|----------|---------|
| 2026-01-18 | 1.0.0 | 初版作成（TDDテストケース定義） |

---

**作成者**: Claude (Zundamon)
**最終更新**: 2026-01-18

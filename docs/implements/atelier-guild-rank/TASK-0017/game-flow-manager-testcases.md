# GameFlowManager - TDD用テストケース

**作成日**: 2026-01-17
**タスクID**: TASK-0017
**要件名**: atelier-guild-rank
**機能名**: GameFlowManager（ゲームフロー管理）

---

## 信頼性レベル指示

各テストケースについて、元の資料（要件定義、既存実装、設計文書等）との照合状況を以下の信号でコメントしています:

- 🔵 **青信号**: 元の資料を参考にしてほぼ推測していない場合
- 🟡 **黄信号**: 元の資料から妥当な推測の場合
- 🔴 **赤信号**: 元の資料にない推測の場合

---

## 1. 正常系テストケース（基本的な動作）

### T-0017-01: 新規ゲーム開始 🔵

- **テスト名**: 新規ゲーム開始時の初期化処理が正しく実行される
  - **何をテストするか**: `startNewGame()`メソッドが正しく動作するか
  - **期待される動作**: StateManagerとDeckServiceの初期化、日開始処理が順番に実行される
- **入力値**: なし（メソッド呼び出しのみ）
  - **入力データの意味**: 新規ゲームの開始操作を表す
- **期待される結果**:
  - `StateManager.initialize()`が1回呼び出される
  - `DeckService.initialize(INITIAL_DECK)`が1回呼び出される
  - `startDay()`が1回呼び出される（内部で）
  - AP が 3 に設定される
  - 日次依頼が生成される
  - `GameEventType.DAY_STARTED`イベントが発行される
  - 依頼受注フェーズ（`QUEST_ACCEPT`）に遷移
  - **期待結果の理由**: 設計文書の「新規ゲーム開始フロー」に明確に定義されている
- **テストの目的**: 新規ゲーム開始時の初期化処理の正確性を確認
  - **確認ポイント**: 各サービスの初期化順序、日開始処理の呼び出し
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-02: 日開始処理が正しく実行される 🔵

- **テスト名**: `startDay()`メソッドが日開始処理を正しく実行する
  - **何をテストするか**: 日開始時のAP回復、依頼生成、イベント発行、フェーズ遷移が正しく動作するか
  - **期待される動作**: AP回復→依頼生成→イベント発行→依頼受注フェーズへの遷移が順番に実行される
- **入力値**: なし（メソッド呼び出しのみ）
  - **入力データの意味**: 1日の開始を表す
- **期待される結果**:
  - APが最大値（3）に回復される（`StateManager.updateState({ actionPoints: 3 })`が呼び出される）
  - 現在のランクに応じた日次依頼が生成される（`QuestService.generateDailyQuests(currentRank)`が呼び出される）
  - `GameEventType.DAY_STARTED`イベントが発行される（現在の日数を含む）
  - 依頼受注フェーズ（`QUEST_ACCEPT`）に遷移する
  - **期待結果の理由**: 設計文書の「日開始処理」に詳細に定義されている
- **テストの目的**: 日開始処理の各ステップが正しい順序で実行されることを確認
  - **確認ポイント**: AP回復、依頼生成、イベント発行、フェーズ遷移の順序とタイミング
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-03: フェーズが順番に進行する 🔵

- **テスト名**: フェーズが依頼受注→採取→調合→納品の順に正しく遷移する
  - **何をテストするか**: `startPhase()`メソッドがフェーズを正しく遷移させるか
  - **期待される動作**: QUEST_ACCEPT → GATHERING → ALCHEMY → DELIVERY の順に遷移
- **入力値**:
  - 第1回: `GamePhase.GATHERING`
  - 第2回: `GamePhase.ALCHEMY`
  - 第3回: `GamePhase.DELIVERY`
  - **入力データの意味**: 各フェーズへの遷移操作を表す
- **期待される結果**:
  - 各フェーズ遷移で`StateManager.setPhase(phase)`が呼び出される
  - 各フェーズ遷移で`GameEventType.PHASE_CHANGED`イベントが発行される（StateManager経由）
  - 現在のフェーズが正しく更新される
  - **期待結果の理由**: 設計文書の「フェーズ進行ロジック」に明確に定義されている
- **テストの目的**: フェーズ遷移の正確性を確認
  - **確認ポイント**: 各フェーズの順序、StateManagerとの連携、イベント発行
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-04: endPhase()で次のフェーズに遷移する 🟡

- **テスト名**: `endPhase()`メソッドが現在のフェーズから次のフェーズに正しく遷移する
  - **何をテストするか**: `endPhase()`メソッドが自動的に次のフェーズへ遷移するか
  - **期待される動作**: 各フェーズから次のフェーズへの自動遷移、納品フェーズからは日終了処理へ
- **入力値**: なし（現在のフェーズに応じて自動判定）
  - **入力データの意味**: 現在のフェーズの終了操作を表す
- **期待される結果**:
  - QUEST_ACCEPT → GATHERING
  - GATHERING → ALCHEMY
  - ALCHEMY → DELIVERY
  - DELIVERY → `endDay()`が呼び出される
  - **期待結果の理由**: 設計文書の「フェーズ進行ロジック」から妥当に推測
- **テストの目的**: フェーズの自動遷移ロジックの正確性を確認
  - **確認ポイント**: 各フェーズからの遷移先、納品フェーズからの日終了呼び出し
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-05: 日終了処理が正しく実行される 🔵

- **テスト名**: `endDay()`メソッドが日終了処理を正しく実行する
  - **何をテストするか**: 期限処理、残り日数減少、イベント発行、ゲーム終了判定が正しく動作するか
  - **期待される動作**: 期限処理→日数更新→イベント発行→終了判定→次の日へ（または終了）の順に実行される
- **入力値**: なし（メソッド呼び出しのみ）
  - **入力データの意味**: 1日の終了を表す
- **期待される結果**:
  1. `QuestService.updateDeadlines()`が呼び出され、失敗した依頼リストを取得
  2. `StateManager.updateState()`で残り日数が-1、現在の日が+1される
  3. `GameEventType.DAY_ENDED`イベントが発行される（失敗依頼、残り日数を含む）
  4. `checkGameOver()`と`checkGameClear()`が呼び出される
  5. ゲーム継続の場合、`startDay()`が呼び出される
  - **期待結果の理由**: 設計文書の「日終了処理」に詳細に定義されている
- **テストの目的**: 日終了処理の各ステップが正しい順序で実行されることを確認
  - **確認ポイント**: 期限処理、日数更新、イベント発行、終了判定の順序とタイミング
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-06: ゲームクリア条件の判定が正しい 🔵

- **テスト名**: Sランク到達時に`checkGameClear()`が正しく判定する
  - **何をテストするか**: `checkGameClear()`メソッドがSランク到達時に正しく判定するか
  - **期待される動作**: Sランク到達時にGameEndConditionを返す
- **入力値**:
  - ゲーム状態: `currentRank = GuildRank.S`
  - **入力データの意味**: Sランク到達を表す
- **期待される結果**:
  - `GameEndCondition`オブジェクトが返される
  - `type: 'game_clear'`
  - `reason: 's_rank_achieved'`
  - `finalRank: GuildRank.S`
  - `totalDays: [現在の日数]`
  - **期待結果の理由**: 設計文書の「ゲームクリア条件」に明確に定義されている
- **テストの目的**: ゲームクリア判定ロジックの正確性を確認
  - **確認ポイント**: Sランク到達時の判定、GameEndConditionの内容
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-07: ゲームクリア後に次の日に進まない 🟡

- **テスト名**: ゲームクリア時に`GAME_CLEAR`イベントが発行され、次の日に進まない
  - **何をテストするか**: ゲームクリア時の処理が正しく動作するか
  - **期待される動作**: ゲームクリア時にイベントが発行され、次の日の処理が実行されない
- **入力値**:
  - ゲーム状態: `currentRank = GuildRank.S`
  - `endDay()`メソッド呼び出し
  - **入力データの意味**: Sランク到達後の日終了を表す
- **期待される結果**:
  - `GameEventType.GAME_CLEAR`イベントが発行される（GameEndConditionを含む）
  - `startDay()`が呼び出されない
  - **期待結果の理由**: 設計文書から妥当に推測
- **テストの目的**: ゲームクリア時の終了処理の正確性を確認
  - **確認ポイント**: イベント発行、次の日への進行停止
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-08: getCurrentPhase()で現在のフェーズを取得できる 🟡

- **テスト名**: `getCurrentPhase()`メソッドがStateManagerから現在のフェーズを正しく取得する
  - **何をテストするか**: `getCurrentPhase()`メソッドが正しく動作するか
  - **期待される動作**: StateManagerの現在のフェーズを返す
- **入力値**: なし（StateManagerの状態に依存）
  - **入力データの意味**: 現在のフェーズの取得操作を表す
- **期待される結果**:
  - `StateManager.getState().currentPhase`と同じ値が返される
  - **期待結果の理由**: インターフェース定義から妥当に推測
- **テストの目的**: 現在フェーズの取得処理の正確性を確認
  - **確認ポイント**: StateManagerとの連携
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-09: skipPhase()でフェーズをスキップできる 🟡

- **テスト名**: `skipPhase()`メソッドが現在のフェーズをスキップして次のフェーズに遷移する
  - **何をテストするか**: `skipPhase()`メソッドが正しく動作するか
  - **期待される動作**: 現在のフェーズをスキップして次のフェーズへ遷移
- **入力値**: なし（現在のフェーズに応じて自動判定）
  - **入力データの意味**: 現在のフェーズのスキップ操作を表す
- **期待される結果**:
  - `endPhase()`と同様の動作（次のフェーズへ遷移）
  - スキップとして記録される可能性がある
  - **期待結果の理由**: インターフェース定義から妥当に推測
- **テストの目的**: フェーズスキップ処理の正確性を確認
  - **確認ポイント**: 次のフェーズへの遷移
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-10: rest()でAP消費なしで日が進む 🟡

- **テスト名**: `rest()`メソッドがAP消費なしで日終了処理を実行する
  - **何をテストするか**: `rest()`メソッドが正しく動作するか
  - **期待される動作**: AP消費なしで日が進む、手札の入れ替え
- **入力値**: なし（メソッド呼び出しのみ）
  - **入力データの意味**: 休憩アクション（何もせずに日を進める）を表す
- **期待される結果**:
  - `endDay()`が呼び出される
  - 手札を2枚捨てて2枚ドローする（`DeckService`経由）
  - AP消費がない
  - **期待結果の理由**: タスク定義のテストケースT-0017-06から
- **テストの目的**: 休憩アクションの正確性を確認
  - **確認ポイント**: 日終了処理の呼び出し、手札の入れ替え、AP消費なし
- 🟡 このテストケースの信頼性レベル: タスク定義から妥当に推測

---

## 2. 異常系テストケース（エラーハンドリング）

### T-0017-E01: 無効なフェーズ遷移でエラーをスローする 🟡

- **テスト名**: `startPhase()`で無効なフェーズ遷移を試みた場合にエラーをスローする
  - **エラーケースの概要**: 順序を無視したフェーズ遷移（例: QUEST_ACCEPT → DELIVERY）
  - **エラー処理の重要性**: フェーズの順序制約を守り、ゲームフローの整合性を保つ
- **入力値**: `GamePhase.DELIVERY`（現在のフェーズがQUEST_ACCEPTの状態）
  - **不正な理由**: フェーズは順番に進行する必要があり、スキップは`skipPhase()`で行う
  - **実際の発生シナリオ**: UI層の不具合や不正な操作による誤ったフェーズ遷移
- **期待される結果**:
  - `ApplicationError`がスローされる
  - エラーコード: `ErrorCodes.INVALID_PHASE_TRANSITION`
  - エラーメッセージ: "無効なフェーズ遷移です"
  - **エラーメッセージの内容**: ユーザーではなく開発者向けのメッセージ
  - **システムの安全性**: フェーズが変更されず、元の状態を保つ
- **テストの目的**: フェーズ遷移の整合性を保つエラーハンドリングを確認
  - **品質保証の観点**: ゲームフローの整合性を保ち、予期しない動作を防ぐ
- 🟡 このテストケースの信頼性レベル: 要件定義書のエラーハンドリングから妥当に推測

### T-0017-E02: ゲーム未開始で日終了を呼び出すとエラーをスローする 🔴

- **テスト名**: ゲームが開始されていない状態で`endDay()`を呼び出すとエラーをスローする
  - **エラーケースの概要**: ゲーム初期化前の操作
  - **エラー処理の重要性**: 未初期化状態での操作を防ぎ、データ整合性を保つ
- **入力値**: `endDay()`メソッド呼び出し（`startNewGame()`や`continueGame()`呼び出し前）
  - **不正な理由**: ゲームが開始されていない状態では日終了処理は実行できない
  - **実際の発生シナリオ**: UI層の不具合や不正な操作順序
- **期待される結果**:
  - `ApplicationError`がスローされる
  - エラーコード: `ErrorCodes.GAME_NOT_STARTED`
  - エラーメッセージ: "ゲームが開始されていません"
  - **エラーメッセージの内容**: 開発者向けのメッセージ
  - **システムの安全性**: 処理が中断され、未初期化状態での操作を防ぐ
- **テストの目的**: ゲーム未開始時のエラーハンドリングを確認
  - **品質保証の観点**: 未初期化状態での操作を防ぎ、システムの安全性を保つ
- 🔴 このテストケースの信頼性レベル: 要件定義書にない推測（一般的なエラーハンドリングパターン）

### T-0017-E03: 不正なセーブデータでエラーをスローする 🟡

- **テスト名**: `continueGame()`で不正なセーブデータを渡すとエラーをスローする
  - **エラーケースの概要**: 破損したまたは互換性のないセーブデータ
  - **エラー処理の重要性**: データ整合性を保ち、ゲームの安定性を確保
- **入力値**:
  - 不正なセーブデータ: `{ version: '0.0.0' }` （必須フィールドが欠落）
  - **不正な理由**: セーブデータの形式が正しくない、または必須フィールドが欠落している
  - **実際の発生シナリオ**: セーブデータの破損、バージョン不一致、手動編集による破損
- **期待される結果**:
  - `ApplicationError`がスローされる
  - エラーコード: `ErrorCodes.INVALID_SAVE_DATA`
  - エラーメッセージ: "セーブデータが不正です"
  - **エラーメッセージの内容**: ユーザー向けのメッセージ（セーブデータが読み込めないことを通知）
  - **システムの安全性**: ゲームが開始されず、タイトル画面に戻る
- **テストの目的**: セーブデータの検証とエラーハンドリングを確認
  - **品質保証の観点**: データ整合性を保ち、不正なデータによるクラッシュを防ぐ
- 🟡 このテストケースの信頼性レベル: 要件定義書のエラーハンドリングから妥当に推測

### T-0017-E04: 2回目のstartNewGame()呼び出しでエラーをスローする 🔴

- **テスト名**: ゲーム開始済みの状態で`startNewGame()`を再度呼び出すとエラーをスローする
  - **エラーケースの概要**: ゲーム進行中の新規ゲーム開始操作
  - **エラー処理の重要性**: ゲーム状態の二重初期化を防ぎ、データ整合性を保つ
- **入力値**:
  - 第1回: `startNewGame()`（正常に実行）
  - 第2回: `startNewGame()`（エラーになるべき）
  - **不正な理由**: ゲームが既に開始されている状態で再度初期化すると、進行中のデータが失われる
  - **実際の発生シナリオ**: UI層の不具合や誤った操作
- **期待される結果**:
  - `ApplicationError`がスローされる
  - エラーコード: `ErrorCodes.GAME_ALREADY_STARTED`
  - エラーメッセージ: "ゲームは既に開始されています"
  - **エラーメッセージの内容**: 開発者向けのメッセージ
  - **システムの安全性**: 初期化処理が実行されず、現在のゲーム状態を保つ
- **テストの目的**: ゲーム二重初期化の防止を確認
  - **品質保証の観点**: ゲーム状態の整合性を保ち、データの意図しない上書きを防ぐ
- 🔴 このテストケースの信頼性レベル: 要件定義書にない推測（一般的なエラーハンドリングパターン）

---

## 3. 境界値テストケース（最小値、最大値、null等）

### T-0017-B01: 残り日数が0でSランク未到達の場合、ゲームオーバー判定 🔵

- **テスト名**: `checkGameOver()`が残り日数0でSランク未到達時に正しく判定する
  - **境界値の意味**: 残り日数0は時間切れの境界値
  - **境界値での動作保証**: 残り日数が0になった時点でゲームオーバー判定が確実に発動する
- **入力値**:
  - ゲーム状態: `remainingDays = 0`, `currentRank = GuildRank.A`
  - **境界値選択の根拠**: 残り日数0は時間切れの境界値として要件定義書に記載
  - **実際の使用場面**: 日数制限内にSランクに到達できなかった場合
- **期待される結果**:
  - `GameEndCondition`オブジェクトが返される
  - `type: 'game_over'`
  - `reason: 'time_expired'`
  - `finalRank: GuildRank.A`
  - `totalDays: [現在の日数]`
  - **境界での正確性**: 残り日数0の時点でゲームオーバー判定が確実に動作
  - **一貫した動作**: 残り日数1では判定されず、0で判定される
- **テストの目的**: 時間切れによるゲームオーバー判定の正確性を確認
  - **堅牢性の確認**: 境界値での判定が確実に動作することを保証
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-B02: 残り日数が-1の場合でもゲームオーバー判定 🟡

- **テスト名**: `checkGameOver()`が残り日数が負の値でもゲームオーバー判定する
  - **境界値の意味**: 残り日数が負の値になる異常ケース（通常は発生しないが安全性のため）
  - **境界値での動作保証**: 負の値でも確実にゲームオーバー判定が動作
- **入力値**:
  - ゲーム状態: `remainingDays = -1`, `currentRank = GuildRank.B`
  - **境界値選択の根拠**: 残り日数が0以下という条件をテスト（`<= 0`）
  - **実際の使用場面**: 通常は発生しないが、バグやデータ破損時の安全網
- **期待される結果**:
  - `GameEndCondition`オブジェクトが返される
  - `type: 'game_over'`
  - `reason: 'time_expired'`
  - **境界での正確性**: 負の値でもゲームオーバー判定が動作
  - **一貫した動作**: 0以下の値すべてで判定される
- **テストの目的**: 境界値外の異常値でもゲームオーバー判定が動作することを確認
  - **堅牢性の確認**: 異常な値に対しても安全に動作することを保証
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-B03: 残り日数が1でSランク未到達の場合、ゲームは継続 🟡

- **テスト名**: `checkGameOver()`が残り日数1でSランク未到達時にnullを返す
  - **境界値の意味**: 残り日数1はゲームオーバーの直前の境界値
  - **境界値での動作保証**: 残り日数1ではゲームオーバーにならず、ゲームが継続する
- **入力値**:
  - ゲーム状態: `remainingDays = 1`, `currentRank = GuildRank.C`
  - **境界値選択の根拠**: ゲームオーバー判定の境界値（0と1の違い）
  - **実際の使用場面**: 最後の1日を残してプレイしている場合
- **期待される結果**:
  - `null`が返される（ゲームオーバーではない）
  - ゲームが継続する
  - **境界での正確性**: 残り日数1ではゲームオーバーにならない
  - **一貫した動作**: 残り日数が1以上の場合、ゲームオーバー判定はfalse
- **テストの目的**: ゲームオーバー判定の境界値の正確性を確認
  - **堅牢性の確認**: 境界値の前後で動作が正しく分かれることを保証
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-B04: Sランク到達直後にゲームクリア判定 🔵

- **テスト名**: Sランク到達直後に`checkGameClear()`が正しく判定する
  - **境界値の意味**: Sランクはゲームクリアの境界値
  - **境界値での動作保証**: Sランク到達の瞬間にゲームクリア判定が動作
- **入力値**:
  - ゲーム状態: `currentRank = GuildRank.S`, `remainingDays = 50`（任意）
  - **境界値選択の根拠**: Sランクはゲームクリアの条件として要件定義書に記載
  - **実際の使用場面**: Sランクに到達した瞬間
- **期待される結果**:
  - `GameEndCondition`オブジェクトが返される
  - `type: 'game_clear'`
  - `reason: 's_rank_achieved'`
  - `finalRank: GuildRank.S`
  - **境界での正確性**: Sランク到達の瞬間にゲームクリア判定が動作
  - **一貫した動作**: Aランク以下では判定されず、Sランクのみで判定される
- **テストの目的**: Sランク到達時のゲームクリア判定の正確性を確認
  - **堅牢性の確認**: ランク到達の瞬間に確実に判定が動作することを保証
- 🔵 このテストケースの信頼性レベル: 要件定義書・設計文書に明確に記載されている

### T-0017-B05: Aランクではゲームクリア判定されない 🟡

- **テスト名**: `checkGameClear()`がAランクの場合にnullを返す
  - **境界値の意味**: Aランクはゲームクリアの直前の境界値
  - **境界値での動作保証**: Aランクではゲームクリアにならない
- **入力値**:
  - ゲーム状態: `currentRank = GuildRank.A`
  - **境界値選択の根拠**: ゲームクリア判定の境界値（SランクとAランクの違い）
  - **実際の使用場面**: Sランクに到達していない状態
- **期待される結果**:
  - `null`が返される（ゲームクリアではない）
  - ゲームが継続する
  - **境界での正確性**: Aランクではゲームクリアにならない
  - **一貫した動作**: Sランク未満ではゲームクリア判定はfalse
- **テストの目的**: ゲームクリア判定の境界値の正確性を確認
  - **堅牢性の確認**: Sランクのみでゲームクリアになることを保証
- 🟡 このテストケースの信頼性レベル: 要件定義書から妥当に推測

### T-0017-B06: continueGame()にnullを渡すとエラー 🔴

- **テスト名**: `continueGame()`にnullを渡すとエラーをスローする
  - **境界値の意味**: null値は無効なセーブデータの境界値
  - **境界値での動作保証**: null値に対して適切なエラーハンドリング
- **入力値**:
  - セーブデータ: `null`
  - **境界値選択の根拠**: null値は無効なデータの典型的な境界値
  - **実際の使用場面**: セーブデータの読み込み失敗時
- **期待される結果**:
  - `ApplicationError`がスローされる
  - エラーコード: `ErrorCodes.INVALID_SAVE_DATA`
  - エラーメッセージ: "セーブデータが不正です"
  - **境界での正確性**: null値に対して適切にエラーが発生
  - **一貫した動作**: 不正なデータに対して一貫したエラーハンドリング
- **テストの目的**: null値に対するエラーハンドリングを確認
  - **堅牢性の確認**: null値に対しても安全に動作することを保証
- 🔴 このテストケースの信頼性レベル: 要件定義書にない推測（一般的なエラーハンドリングパターン）

---

## 4. 開発言語・フレームワーク

### プログラミング言語 🔵

- **プログラミング言語**: TypeScript 5.x
  - **言語選択の理由**: プロジェクト全体でTypeScriptを採用しており、型安全性とIDE支援が充実
  - **テストに適した機能**: 型推論、インターフェース、ジェネリクスによる型安全なテストコード

### テストフレームワーク 🔵

- **テストフレームワーク**: Vitest 4.x
  - **フレームワーク選択の理由**:
    - Viteとの統合が優れている
    - Jestライクなシンタックスで学習コストが低い
    - 高速な実行速度
    - ESM/TypeScriptのネイティブサポート
  - **テスト実行環境**:
    - Node.js環境でユニットテストを実行
    - `pnpm test`コマンドで実行
    - カバレッジレポート生成機能あり

### モック・スタブ戦略 🟡

- **モックライブラリ**: Vitestの組み込みモック機能（`vi.fn()`, `vi.mock()`）
- **モック対象**:
  - `IStateManager`: ゲーム状態の管理をモック
  - `IDeckService`: デッキ管理をモック
  - `IQuestService`: 依頼管理をモック
  - `IEventBus`: イベント通信をモック
- **モック戦略**:
  - 各依存サービスをモックし、GameFlowManagerの動作のみをテスト
  - イベント発行は`vi.fn()`でスパイし、呼び出しを検証
  - StateManagerの状態はモックで返り値を制御

### テストファイル構成 🔵

- **テストファイルパス**: `atelier-guild-rank/tests/unit/application/services/game-flow-manager.test.ts`
- **テストコード構造**:
  ```typescript
  describe('GameFlowManager', () => {
    let gameFlowManager: IGameFlowManager;
    let mockStateManager: MockedObject<IStateManager>;
    let mockDeckService: MockedObject<IDeckService>;
    let mockQuestService: MockedObject<IQuestService>;
    let mockEventBus: MockedObject<IEventBus>;

    beforeEach(() => {
      // モックの初期化
      // GameFlowManagerのインスタンス化
    });

    describe('正常系テストケース', () => {
      it('T-0017-01: 新規ゲーム開始', () => { /* ... */ });
      it('T-0017-02: 日開始処理', () => { /* ... */ });
      // ...
    });

    describe('異常系テストケース', () => {
      it('T-0017-E01: 無効なフェーズ遷移', () => { /* ... */ });
      // ...
    });

    describe('境界値テストケース', () => {
      it('T-0017-B01: 残り日数0でゲームオーバー', () => { /* ... */ });
      // ...
    });
  });
  ```

- 🔵 この内容の信頼性レベル: タスクノート・設計文書に明確に記載されている

---

## 5. テストケース実装時の日本語コメント指針

### テストケース開始時のコメント 🟡

各テストケースの実装時には以下の日本語コメントを必ず含める:

```typescript
// 【テスト目的】: 新規ゲーム開始時の初期化処理が正しく実行されることを確認
// 【テスト内容】: startNewGame()メソッドを呼び出し、StateManagerとDeckServiceの初期化、日開始処理が順番に実行されることをテスト
// 【期待される動作】: StateManager.initialize()、DeckService.initialize()、startDay()が順番に呼び出される
// 🔵 テストケースの信頼性: 要件定義書・設計文書に明確に記載
```

### Given（準備フェーズ）のコメント 🟡

```typescript
// 【テストデータ準備】: モックのStateManager、DeckService、QuestService、EventBusを作成
// 【初期条件設定】: ゲーム未開始の状態を想定
// 【前提条件確認】: 各モックが正しく初期化されていることを確認
```

### When（実行フェーズ）のコメント 🟡

```typescript
// 【実際の処理実行】: gameFlowManager.startNewGame()を呼び出す
// 【処理内容】: 新規ゲーム開始処理（初期化→日開始）を実行
// 【実行タイミング】: テストの準備が完了した直後に実行
```

### Then（検証フェーズ）のコメント 🟡

```typescript
// 【結果検証】: StateManager.initialize()が1回呼び出されたことを確認
// 【期待値確認】: DeckService.initialize(INITIAL_DECK)が1回呼び出されたことを確認
// 【品質保証】: この検証により、新規ゲーム開始時の初期化順序が正しいことを保証
```

### 各expectステートメントのコメント 🟡

```typescript
// 【検証項目】: StateManager.initialize()の呼び出し回数
// 🔵 信頼性: 設計文書に明確に記載
expect(mockStateManager.initialize).toHaveBeenCalledTimes(1); // 【確認内容】: 初期化処理が1回のみ実行されることを確認

// 【検証項目】: DeckService.initialize()の呼び出し引数
// 🔵 信頼性: 設計文書に明確に記載
expect(mockDeckService.initialize).toHaveBeenCalledWith(INITIAL_DECK); // 【確認内容】: 初期デッキが正しく渡されることを確認
```

### セットアップ・クリーンアップのコメント 🟡

```typescript
beforeEach(() => {
  // 【テスト前準備】: 各テスト実行前にモックを初期化し、GameFlowManagerのインスタンスを作成
  // 【環境初期化】: 各テストが独立して実行できるようクリーンな状態を作成
});

afterEach(() => {
  // 【テスト後処理】: モックのリセット（必要な場合）
  // 【状態復元】: 次のテストに影響しないようモックをクリア
});
```

- 🟡 この内容の信頼性レベル: テストのベストプラクティスから妥当に推測

---

## 6. 要件定義との対応関係

### 参照した機能概要 🔵

- **セクション 1.1「機能の役割」**: GameFlowManagerの責務を明確化
- **セクション 1「機能の概要」**: ゲーム全体の進行統括、日の進行、フェーズ遷移、ゲーム終了判定

### 参照した入力・出力仕様 🔵

- **セクション 2.1「IGameFlowManagerインターフェース定義」**: 全メソッドのシグネチャ
- **セクション 2.2「メソッド仕様」**: 各メソッドの入力・出力・効果・例外
- **セクション 2.3「データフロー」**: 新規ゲーム開始フロー、日開始フロー、日終了フロー

### 参照した制約条件 🔵

- **セクション 3.1「フェーズ遷移の制約」**: フェーズは順番に進行、逆戻り不可
- **セクション 3.2「日進行の制約」**: APは3に回復、期限-1、残り日数0でゲームオーバー判定
- **セクション 3.3「ゲーム終了判定のタイミング」**: 日終了処理の最後に必ずチェック
- **セクション 3.5「エラーハンドリング」**: 各種エラーコードと発生条件

### 参照した使用例 🔵

- **セクション 4.1「基本的な使用パターン」**: 新規ゲーム開始、コンティニュー、1日のフロー
- **セクション 4.2「エッジケース」**: ゲームオーバー条件、ゲームクリア条件
- **セクション 4.3「エラーケース」**: 無効なフェーズ遷移、ゲーム未開始、不正なセーブデータ

---

## 7. テストカバレッジ目標

### カバレッジ目標 🟡

- **目標カバレッジ**: 80%以上
- **優先カバレッジ項目**:
  - ゲーム終了判定ロジック（`checkGameOver()`, `checkGameClear()`）: 100%
  - フェーズ遷移ロジック（`startPhase()`, `endPhase()`, `skipPhase()`）: 100%
  - 日の進行ロジック（`startDay()`, `endDay()`）: 100%
  - エラーハンドリング: 80%以上

### テスト実行コマンド 🔵

```bash
# ユニットテスト実行
pnpm test

# カバレッジレポート生成
pnpm test:coverage

# 特定ファイルのみテスト
pnpm test game-flow-manager.test.ts
```

---

## 8. 信頼性評価サマリー

| カテゴリ | 🔵青信号 | 🟡黄信号 | 🔴赤信号 | 備考 |
|---------|---------|---------|---------|------|
| **正常系テストケース** | 6件 | 4件 | 0件 | 基本動作は設計文書に明確、一部詳細は推測 |
| **異常系テストケース** | 0件 | 2件 | 2件 | エラーハンドリングの一部は推測 |
| **境界値テストケース** | 2件 | 3件 | 1件 | 主要な境界値は明確、一部は推測 |
| **開発言語・FW** | 2件 | 1件 | 0件 | 技術スタックは明確 |
| **コメント指針** | 0件 | 6件 | 0件 | ベストプラクティスから推測 |

**総合信頼性**: 🔵 **高い信頼性**（60%以上が青信号、重要なテストケースは要件定義書・設計文書に基づいている）

### 信頼性評価の詳細

- **高信頼性（🔵）**: 11件（主要な正常系、境界値の重要ケース）
- **中信頼性（🟡）**: 16件（詳細な動作、エラーハンドリング、コメント指針）
- **低信頼性（🔴）**: 3件（一般的なエラーハンドリングパターン）

---

## 9. 品質判定結果

### テストケース分類 ✅

- **正常系**: 10件（新規ゲーム開始、日開始、フェーズ進行、日終了、ゲーム終了判定など）
- **異常系**: 4件（無効なフェーズ遷移、ゲーム未開始、不正なセーブデータ、二重初期化）
- **境界値**: 6件（残り日数0/-1/1、Sランク/Aランク、null値）
- **評価**: ✅ 正常系・異常系・境界値が網羅されている

### 期待値定義 ✅

- 各テストケースで明確な期待値を定義
- メソッド呼び出し回数、引数、戻り値、イベント発行を具体的に記載
- **評価**: ✅ 各テストケースの期待値が明確

### 技術選択 ✅

- **プログラミング言語**: TypeScript 5.x（プロジェクト標準）
- **テストフレームワーク**: Vitest 4.x（プロジェクト標準）
- **モック戦略**: Vitestの組み込みモック機能
- **評価**: ✅ プログラミング言語・テストフレームワークが確定

### 実装可能性 ✅

- 現在の技術スタック（TypeScript + Vitest）で実装可能
- 既存のテストパターン（StateManagerテスト、QuestServiceテスト）を参考にできる
- モック対象のインターフェースが明確に定義されている
- **評価**: ✅ 現在の技術スタックで実現可能

### 信頼性レベル分布 ✅

- **🔵青信号**: 11件（36%）- 主要な機能は要件定義書・設計文書に基づく
- **🟡黄信号**: 16件（53%）- 詳細な動作やエラーハンドリングは妥当な推測
- **🔴赤信号**: 3件（10%）- 一般的なエラーハンドリングパターン
- **評価**: ✅ 重要な機能は青信号、全体として信頼性が高い

---

## 10. 総合評価

### 品質判定: ✅ 高品質

- ✅ テストケース分類: 正常系・異常系・境界値が網羅されている
- ✅ 期待値定義: 各テストケースの期待値が明確
- ✅ 技術選択: プログラミング言語・テストフレームワークが確定
- ✅ 実装可能性: 現在の技術スタックで実現可能
- ✅ 信頼性レベル: 🔵青信号が多く、重要な機能は要件定義書に基づく

### 推奨事項

1. **エラーハンドリングの詳細化**: 🔴赤信号のエラーケースについて、要件定義書への追記を検討
2. **統合テストの追加**: GameFlowManagerと他のサービスの統合テストを検討
3. **E2Eテストの追加**: 実際のゲームフローをE2Eテストで検証することを検討

---

## 11. 次のステップ

この要件定義書の作成が完了しました。次のお勧めステップ:

```bash
/tsumiki:tdd-red atelier-guild-rank TASK-0017
```

でRedフェーズ（失敗テスト作成）を開始します。

---

**最終更新**: 2026-01-17

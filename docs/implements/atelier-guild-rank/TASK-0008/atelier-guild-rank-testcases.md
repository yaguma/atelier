# TASK-0008: Phaser基本設定とBootScene - テストケース定義書

**作成日**: 2026-01-16
**タスクID**: TASK-0008
**要件名**: atelier-guild-rank
**機能名**: Phaser基本設定とBootScene

---

## 信頼性レベル凡例

- 🔵 **青信号**: 元の資料（要件定義、設計文書、既存実装）を参考にしてほぼ推測していない
- 🟡 **黄信号**: 元の資料から妥当な推測
- 🔴 **赤信号**: 元の資料にない推測

---

## 1. 正常系テストケース（基本的な動作）

### 1.1 Phaserゲーム起動テスト（T-0008-01）

- **テスト名**: Phaserゲームインスタンスが正常に生成される
  - **何をテストするか**: `main.ts`でPhaserゲームインスタンスが作成され、エラーなく起動すること
  - **期待される動作**: Phaser.Gameコンストラクタが呼ばれ、ゲームコンフィグが正しく渡される
- **入力値**:
  - `type: Phaser.AUTO` - WebGL優先、Canvas fallback
  - `width: 1280` - ゲーム幅
  - `height: 720` - ゲーム高さ
  - `parent: 'game-container'` - 親要素ID
  - `backgroundColor: '#F5F5DC'` - ベージュ背景
  - `scene: [BootScene, TitleScene, MainScene]` - シーン配列
  - **入力データの意味**: 設計文書（architecture-phaser.md）で定義された基準解像度とシーン構成を使用
- **期待される結果**:
  - Phaserゲームインスタンスが正常に生成される
  - コンソールエラーが発生しない
  - BootSceneが自動的に開始される
  - **期待結果の理由**: ゲームエンジンの初期化が正常に完了することで、以降のシーン処理が実行可能になる
- **テストの目的**: Phaserエンジンの基本設定が正しく動作することを確認
  - **確認ポイント**: GameConfigの各プロパティが設計書通りに設定されている
- 🔵 **信頼性レベル**: 設計文書（architecture-phaser.md）とタスク定義（TASK-0008.md）に明確に記載

### 1.2 rexUIプラグイン登録テスト（T-0008-03）

- **テスト名**: rexUIプラグインが正常に登録され利用可能になる
  - **何をテストするか**: rexUIプラグインがGameConfigに正しく登録され、シーン内で`this.rexUI`経由でアクセスできること
  - **期待される動作**: シーン内で`this.rexUI.add.label`などのUIコンポーネントが利用可能
- **入力値**:
  ```typescript
  plugins: {
    scene: [
      {
        key: 'rexUI',
        plugin: RexUIPlugin,
        mapping: 'rexUI',
      },
    ],
  }
  ```
  - **入力データの意味**: rexUIをシーンプラグインとして登録し、`this.rexUI`でアクセス可能にする
- **期待される結果**:
  - rexUIプラグインがシーンに注入される
  - `this.rexUI`が`undefined`でない
  - rexUIコンポーネント（label, roundRectangleなど）が利用可能
  - **期待結果の理由**: UI構築に必要なrexUIライブラリが正常に統合されることを保証
- **テストの目的**: rexUIプラグインの統合が正しく動作することを確認
  - **確認ポイント**: プラグインの`mapping`設定により`this.rexUI`プロパティでアクセスできる
- 🔵 **信頼性レベル**: 設計文書（architecture-phaser.md）とタスク定義（TASK-0008.md）に明確に記載

### 1.3 BootScene.preload()でのマスターデータ読み込みテスト

- **テスト名**: BootScene.preload()で全てのマスターデータJSONファイルが読み込まれる
  - **何をテストするか**: `this.load.json()`で6種類のマスターデータが正常に読み込まれること
  - **期待される動作**: cards, materials, recipes, quests, ranks, artifactsの各JSONファイルがキャッシュに格納される
- **入力値**:
  - `/data/cards.json` - カードマスター
  - `/data/materials.json` - 素材マスター
  - `/data/recipes.json` - レシピマスター
  - `/data/quests.json` - 依頼マスター
  - `/data/ranks.json` - ランクマスター
  - `/data/artifacts.json` - アーティファクトマスター
  - **入力データの意味**: ゲームで使用する全てのマスターデータを初期化時に一括読み込み
- **期待される結果**:
  - 全てのJSONファイルが正常に読み込まれる
  - `this.cache.json.get('cards')`などでデータにアクセスできる
  - ローダーの`complete`イベントが発火する
  - **期待結果の理由**: マスターデータが全て揃っていないとゲームロジックが動作しない
- **テストの目的**: マスターデータの初期読み込みが正常に完了することを確認
  - **確認ポイント**: 各JSONキーでキャッシュからデータを取得できる
- 🔵 **信頼性レベル**: 要件定義書（atelier-guild-rank-requirements.md）のpreload()処理内容に明記

### 1.4 BootScene.create()でのシーン遷移テスト（T-0008-02）

- **テスト名**: BootScene.create()完了後にTitleSceneへ自動遷移する
  - **何をテストするか**: `this.scene.start('TitleScene')`が呼ばれ、TitleSceneが開始されること
  - **期待される動作**: BootScene完了後、TitleSceneのcreate()が実行される
- **入力値**:
  - シーンキー: `'TitleScene'` (文字列)
  - **入力データの意味**: Phaserのシーン管理システムで定義されたシーン識別子
- **期待される結果**:
  - BootSceneが終了する（shutdown()が呼ばれる）
  - TitleSceneが開始される（init() → preload() → create()の順で実行）
  - TitleSceneの画面が表示される
  - **期待結果の理由**: BootSceneはアセット読み込み専用で、完了後は必ずTitleSceneへ遷移する設計
- **テストの目的**: シーン遷移フローが正常に動作することを確認
  - **確認ポイント**: `this.scene.start()`によるシーン切り替えが正しく機能する
- 🔵 **信頼性レベル**: 要件定義書（atelier-guild-rank-requirements.md）のcreate()処理内容とシーン遷移図に明記

### 1.5 プログレスバー更新テスト

- **テスト名**: アセット読み込み中にプログレスバーが0%から100%まで更新される
  - **何をテストするか**: `this.load.on('progress')`イベントでプログレスバーが更新されること
  - **期待される動作**: 読み込み進捗に応じてバーの長さが変化する
- **入力値**:
  - `value: number` (0.0 〜 1.0) - ローダーの進捗率
  - **入力データの意味**: Phaserローダーが自動的に計算する読み込み完了率
- **期待される結果**:
  - プログレスバーのGraphicsオブジェクトが更新される
  - 進捗率に応じてバーの幅が変化する（0% → 25% → 50% → 75% → 100%）
  - 100%完了時にプログレスバーが破棄される
  - **期待結果の理由**: ユーザーに読み込み状況を視覚的にフィードバックする必要がある
- **テストの目的**: ローディングUIが正常に動作することを確認
  - **確認ポイント**: `progress`イベントが発火するたびにバーが更新される
- 🔵 **信頼性レベル**: note.mdのBootSceneローディングプログレスバー実装例に記載

### 1.6 Scale Manager動作テスト

- **テスト名**: ゲームキャンバスが画面サイズに応じて適切にスケーリングされる
  - **何をテストするか**: Phaser.Scale.FITモードで画面にフィットすること
  - **期待される動作**: アスペクト比16:9を維持しながら、画面サイズに合わせて拡大縮小される
- **入力値**:
  ```typescript
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  }
  ```
  - **入力データの意味**: 画面中央にアスペクト比を保ったまま最大化
- **期待される結果**:
  - 1280x720の基準解像度がウィンドウサイズに合わせてスケールされる
  - アスペクト比16:9が維持される
  - 画面が中央に配置される
  - **期待結果の理由**: 様々な画面サイズ（PC、タブレット、スマホ）で適切に表示される必要がある
- **テストの目的**: レスポンシブ対応が正しく動作することを確認
  - **確認ポイント**: ウィンドウサイズを変更してもアスペクト比が崩れない
- 🔵 **信頼性レベル**: 要件定義書（atelier-guild-rank-requirements.md）のスケール設定に明記

---

## 2. 異常系テストケース（エラーハンドリング）

### 2.1 JSONファイル読み込み失敗テスト

- **テスト名**: マスターデータJSONファイルが存在しない場合、エラーハンドリングされる
  - **エラーケースの概要**: JSONファイルパスが間違っている、またはファイルが削除されている場合
  - **エラー処理の重要性**: マスターデータなしではゲームが動作できないため、致命的エラーとして処理する必要がある
- **入力値**:
  - 存在しないファイルパス: `/data/nonexistent.json`
  - 破損したJSONファイル: `{"invalid": json}`
  - **不正な理由**: ファイルが存在しない、またはJSON形式が不正
  - **実際の発生シナリオ**: ビルド時のアセットコピー失敗、ファイルパスの変更、JSONシンタックスエラー
- **期待される結果**:
  - Phaserローダーの`loaderror`イベントが発火する
  - コンソールにエラーログが出力される: `ErrorCodes.DATA_LOAD_FAILED`
  - エラーダイアログが表示される（将来実装）
  - ゲーム起動が中断される
  - **エラーメッセージの内容**: "マスターデータの読み込みに失敗しました。ページを再読み込みしてください。"
  - **システムの安全性**: エラー状態でゲーム続行しない（部分的なデータでの動作を許可しない）
- **テストの目的**: データ読み込み失敗時に適切にエラーハンドリングされることを確認
  - **品質保証の観点**: 不完全な状態でゲームが動作してバグが発生するのを防ぐ
- 🟡 **信頼性レベル**: note.mdのエラーハンドリングセクションとErrorCodesから妥当な推測

### 2.2 サービス初期化失敗テスト

- **テスト名**: BootScene.create()でのサービス初期化中にエラーが発生した場合、適切に処理される
  - **エラーケースの概要**: ServiceContainerの初期化中に予期しないエラーが発生
  - **エラー処理の重要性**: サービスが初期化されていないと、以降の全ての処理でエラーが連鎖する
- **入力値**:
  - サービス初期化メソッド: `initializeServices()`
  - エラーシナリオ: 依存サービスの生成失敗、メモリ不足など
  - **不正な理由**: プログラムバグ、環境問題、リソース不足
  - **実際の発生シナリオ**: ブラウザのメモリ制限、実装バグ、依存ライブラリのエラー
- **期待される結果**:
  - try-catchブロックでエラーをキャッチする
  - エラーログ出力: `ErrorCodes.SERVICE_INIT_FAILED`
  - エラーダイアログ表示
  - ゲーム起動を中断
  - **エラーメッセージの内容**: "ゲームの初期化に失敗しました。ブラウザを再起動してください。"
  - **システムの安全性**: 不完全な初期化状態でゲームを続行しない
- **テストの目的**: サービス初期化失敗時に安全に停止することを確認
  - **品質保証の観点**: 初期化エラーを早期に検出し、原因特定を容易にする
- 🔴 **信頼性レベル**: 要件定義書のエラーケース1から推測（ErrorCodesは新規定義が必要）

### 2.3 シーン遷移失敗テスト

- **テスト名**: 存在しないシーンキーで遷移しようとした場合、エラーが発生する
  - **エラーケースの概要**: `this.scene.start('NonExistentScene')`で存在しないシーンを指定
  - **エラー処理の重要性**: シーン遷移エラーはゲームフローが完全に停止するため、開発時に早期発見が必要
- **入力値**:
  - シーンキー: `'NonExistentScene'` (登録されていないシーン)
  - **不正な理由**: シーンがGameConfigのscene配列に登録されていない
  - **実際の発生シナリオ**: タイポ、実装漏れ、リファクタリング時の削除漏れ
- **期待される結果**:
  - Phaserがエラーをスロー: "Cannot start Scene. Scene not found: NonExistentScene"
  - コンソールにエラーログ出力
  - ゲームが停止する
  - **エラーメッセージの内容**: Phaserの標準エラーメッセージ
  - **システムの安全性**: 存在しないシーンへの遷移を試みない（開発時に検出）
- **テストの目的**: シーン遷移のバリデーションが機能することを確認
  - **品質保証の観点**: 開発時の実装ミスを早期に検出する
- 🟡 **信頼性レベル**: Phaserの標準動作から妥当な推測

### 2.4 rexUIプラグイン読み込み失敗テスト

- **テスト名**: rexUIプラグインの読み込みに失敗した場合、エラーが発生する
  - **エラーケースの概要**: rexUIライブラリがインストールされていない、またはバージョン不一致
  - **エラー処理の重要性**: rexUIがないとUI構築ができないため、起動時に検出する必要がある
- **入力値**:
  - プラグインインポート: `import RexUIPlugin from 'phaser3-rex-plugins/templates/ui/ui-plugin'`
  - エラーシナリオ: モジュールが見つからない、バージョン不一致
  - **不正な理由**: `pnpm install`が実行されていない、package.jsonの依存関係が不正
  - **実際の発生シナリオ**: 新規環境セットアップ時、依存ライブラリの削除、バージョン更新の失敗
- **期待される結果**:
  - ビルド時にエラーが発生: "Cannot find module 'phaser3-rex-plugins'"
  - または、実行時にエラー: "RexUIPlugin is not defined"
  - コンソールにエラーログ出力
  - ゲームが起動しない
  - **エラーメッセージの内容**: モジュールシステムの標準エラー
  - **システムの安全性**: 依存ライブラリの不足を早期に検出
- **テストの目的**: 必須ライブラリの依存関係が正しく設定されていることを確認
  - **品質保証の観点**: 環境構築時の問題を早期に発見する
- 🟡 **信頼性レベル**: 一般的な依存関係エラーから妥当な推測

---

## 3. 境界値テストケース（最小値、最大値、null等）

### 3.1 最小解像度でのスケーリングテスト

- **テスト名**: 最小解像度（960x540）で正常にスケーリングされる
  - **境界値の意味**: architecture-phaser.mdで定義された最小サポート解像度
  - **境界値での動作保証**: 小画面でもゲームが正常に表示される
- **入力値**:
  - ウィンドウサイズ: `960x540` (最小解像度)
  - **境界値選択の根拠**: 設計文書で定義された最小対応解像度
  - **実際の使用場面**: 小型タブレット、古いスマートフォン
- **期待される結果**:
  - ゲームキャンバスが960x540にフィットする
  - UIが全て表示される（テキストやボタンが画面外に出ない）
  - アスペクト比16:9が維持される
  - **境界での正確性**: 最小解像度でもゲームプレイに支障がない
  - **一貫した動作**: 基準解像度と同じレイアウト・動作を維持
- **テストの目的**: 最小サポート解像度での動作を保証
  - **堅牢性の確認**: 小画面でもクリティカルな情報が表示される
- 🔵 **信頼性レベル**: 要件定義書（atelier-guild-rank-requirements.md）の技術的制約に明記

### 3.2 4K解像度でのスケーリングテスト

- **テスト名**: 4K解像度（3840x2160）で正常にスケーリングされる
  - **境界値の意味**: 現代の高解像度ディスプレイでの表示
  - **境界値での動作保証**: 高解像度でも適切にスケールされる
- **入力値**:
  - ウィンドウサイズ: `3840x2160` (4K解像度)
  - **境界値選択の根拠**: 現代の高解像度ディスプレイの代表的なサイズ
  - **実際の使用場面**: ハイエンドPC、最新ゲーミングモニター
- **期待される結果**:
  - ゲームキャンバスが画面全体にフィットする
  - アスペクト比16:9が維持される（レターボックス表示）
  - UIがボケずに表示される
  - **境界での正確性**: 高解像度でも画質が劣化しない
  - **一貫した動作**: ゲームプレイの体験が同一
- **テストの目的**: 高解像度環境での表示品質を確認
  - **堅牢性の確認**: 極端に大きい画面でも正常に動作する
- 🟡 **信頼性レベル**: 要件定義書のエッジケース3から妥当な推測

### 3.3 アスペクト比が異なる画面でのテスト

- **テスト名**: アスペクト比21:9（ウルトラワイド）で正常にスケーリングされる
  - **境界値の意味**: 16:9以外のアスペクト比への対応
  - **境界値での動作保証**: レターボックス/ピラーボックスで正しく表示される
- **入力値**:
  - ウィンドウサイズ: `2560x1080` (21:9ウルトラワイド)
  - **境界値選択の根拠**: 16:9とは異なる一般的なアスペクト比
  - **実際の使用場面**: ウルトラワイドモニター、一部のノートPC
- **期待される結果**:
  - ゲームキャンバスが16:9のアスペクト比を維持
  - 両端にピラーボックス（黒帯）が表示される
  - UIが画面内に収まる
  - **境界での正確性**: アスペクト比が変わってもゲームプレイに影響しない
  - **一貫した動作**: 16:9基準でのレイアウトが保たれる
- **テストの目的**: 多様なアスペクト比への対応を確認
  - **堅牢性の確認**: 予期しない画面サイズでも破綻しない
- 🟡 **信頼性レベル**: 要件定義書のエッジケース3から妥当な推測

### 3.4 空のマスターデータでの動作テスト

- **テスト名**: マスターデータJSONが空配列の場合、エラーまたは警告を出す
  - **境界値の意味**: データ件数がゼロの極端なケース
  - **境界値での動作保証**: 空データでもクラッシュしない
- **入力値**:
  - `/data/cards.json`: `[]` (空配列)
  - `/data/materials.json`: `[]` (空配列)
  - **境界値選択の根拠**: データがゼロ件という極端なケース
  - **実際の使用場面**: 開発初期、テスト環境、データ削除ミス
- **期待される結果**:
  - JSONファイルは正常に読み込まれる（エラーにならない）
  - 警告ログが出力される: "マスターデータが空です"
  - ゲームは起動するが、カード選択などができない状態になる
  - **境界での正確性**: 空データでもアプリケーションがクラッシュしない
  - **一貫した動作**: エラーハンドリングが機能する
- **テストの目的**: 空データでの安全性を確認
  - **堅牢性の確認**: データがゼロでもアプリケーションが停止しない
- 🔴 **信頼性レベル**: 境界値テストのベストプラクティスから推測

### 3.5 極端に大きいマスターデータでの読み込みテスト

- **テスト名**: マスターデータが10000件以上の場合でも正常に読み込める
  - **境界値の意味**: 大量データでのパフォーマンス確認
  - **境界値での動作保証**: メモリオーバーフローやタイムアウトが発生しない
- **入力値**:
  - `/data/cards.json`: 10000件のカードデータ
  - **境界値選択の根拠**: 通常のゲームでは考えにくい極端に大きいデータセット
  - **実際の使用場面**: 将来の拡張、MOD対応、開発時のストレステスト
- **期待される結果**:
  - 全てのデータが読み込まれる
  - ローディング時間が要件（< 3秒）以内に収まる
  - メモリ使用量が許容範囲内（ブラウザがクラッシュしない）
  - **境界での正確性**: 大量データでもデータ欠損がない
  - **一貫した動作**: プログレスバーが正常に更新される
- **テストの目的**: 大量データでのパフォーマンスを確認
  - **堅牢性の確認**: データ量が増えても安定動作する
- 🔴 **信頼性レベル**: パフォーマンステストのベストプラクティスから推測

---

## 4. 開発言語・フレームワーク

### 4.1 プログラミング言語

- **プログラミング言語**: TypeScript 5.x
  - **言語選択の理由**: 型安全性の確保、コード品質向上、開発効率の向上
  - **テストに適した機能**: 型推論によるテストコードの品質向上、インターフェースによるモックの容易化
- 🔵 **信頼性レベル**: note.mdの技術スタックに明記

### 4.2 テストフレームワーク

#### ユニットテスト

- **テストフレームワーク**: Vitest 4.x
  - **フレームワーク選択の理由**: Viteとの統合、高速なテスト実行、Jest互換API
  - **テスト実行環境**: jsdom環境（ブラウザAPIのエミュレーション）
  - **モックライブラリ**: Vitest標準のvi.fn()、vi.mock()
  - **カバレッジツール**: v8（目標: 80%以上）
- 🔵 **信頼性レベル**: note.mdの技術スタックとvitest.config.tsに明記

#### E2Eテスト

- **テストフレームワーク**: Playwright（最新版）
  - **フレームワーク選択の理由**: クロスブラウザテスト、安定したセレクター、スクリーンショット機能
  - **テスト実行環境**: 実際のブラウザ（Chromium, Firefox, Webkit）
  - **Page Objectパターン**: GamePageクラスで画面操作を抽象化
- 🔵 **信頼性レベル**: note.mdの技術スタックと既存のe2e/specs/boot.spec.tsに明記

### 4.3 テスト環境設定

- **セットアップファイル**: `tests/setup.ts`
  - Phaserのモック化
  - localStorageのモック化
  - requestAnimationFrameのモック化
- **エイリアス設定**: vitest.config.tsで`@presentation`, `@application`などのパスエイリアス定義
- 🔵 **信頼性レベル**: vitest.config.tsとtests/setup.tsに明記

---

## 5. テストケース実装時の日本語コメント指針

### 5.1 テストケース開始時のコメント

```typescript
describe('BootScene', () => {
  describe('preload()', () => {
    it('T-0008-01: 全てのマスターデータJSONファイルが読み込まれる', () => {
      // 【テスト目的】: BootScene起動時に6種類のマスターデータが正常に読み込まれることを確認
      // 【テスト内容】: this.load.json()で各マスターデータファイルを読み込み、キャッシュに格納されることを検証
      // 【期待される動作】: cards, materials, recipes, quests, ranks, artifactsの全てが読み込まれる
      // 🔵 信頼性レベル: 要件定義書のpreload()処理内容に明記

      // テスト実装...
    });
  });
});
```

### 5.2 Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: BootSceneインスタンスを生成し、必要なモックを設定
// 【初期条件設定】: Phaserローダーのモックとキャッシュシステムを初期化
// 【前提条件確認】: マスターデータJSONファイルが/data/配下に存在すること
const bootScene = new BootScene();
const loadJsonSpy = vi.spyOn(bootScene.load, 'json');
```

### 5.3 When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: BootScene.preload()メソッドを呼び出し
// 【処理内容】: マスターデータのJSONファイルを非同期で読み込む
// 【実行タイミング】: Phaserシーンライフサイクルの初期化フェーズで実行
bootScene.preload();
```

### 5.4 Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: this.load.json()が6回呼ばれたことを確認
// 【期待値確認】: 各マスターデータのキーとファイルパスが正しいことを検証
// 【品質保証】: 全てのマスターデータが揃うことで、ゲームロジックが正常に動作することを保証
expect(loadJsonSpy).toHaveBeenCalledTimes(6);
```

### 5.5 各expectステートメントのコメント

```typescript
// 【検証項目】: cardsマスターデータが正しいパスで読み込まれる
// 🔵 信頼性レベル: note.mdのBootSceneで読み込むものに明記
expect(loadJsonSpy).toHaveBeenCalledWith('cards', '/data/cards.json');

// 【確認内容】: materialsマスターデータが正しいパスで読み込まれる
// 🔵 信頼性レベル: note.mdのBootSceneで読み込むものに明記
expect(loadJsonSpy).toHaveBeenCalledWith('materials', '/data/materials.json');
```

### 5.6 セットアップ・クリーンアップのコメント

```typescript
beforeEach(() => {
  // 【テスト前準備】: 各テストケース実行前にBootSceneインスタンスを初期化
  // 【環境初期化】: Phaserのモックをリセットし、クリーンな状態にする理由：前のテストの影響を排除
  bootScene = new BootScene();
  vi.clearAllMocks();
});

afterEach(() => {
  // 【テスト後処理】: BootSceneのリソースを解放し、イベントリスナーを削除
  // 【状態復元】: グローバルなモックをリセットし、次のテストに影響しないようにする
  bootScene.shutdown();
  vi.restoreAllMocks();
});
```

---

## 6. 要件定義との対応関係

### 6.1 参照した機能概要

- **参照セクション**: `atelier-guild-rank-requirements.md` - 1. 機能の概要
  - Phaserゲームコンフィグの定義
  - rexUIプラグインの登録
  - BootSceneの実装
  - シーン遷移の実装

### 6.2 参照した入力・出力仕様

- **参照セクション**: `atelier-guild-rank-requirements.md` - 2. 入力・出力の仕様
  - 2.1 Phaserゲームコンフィグ（入力パラメータ、出力値）
  - 2.2 BootScene（ライフサイクルメソッド、preload/create処理内容）

### 6.3 参照した制約条件

- **参照セクション**: `atelier-guild-rank-requirements.md` - 3. 制約条件
  - 3.1 技術的制約（Phaserバージョン、rexUIバージョン、解像度）
  - 3.2 パフォーマンス要件（起動時間、アセット読み込み時間）
  - 3.5 アーキテクチャ制約（Clean Architecture、Presentation層の責務）

### 6.4 参照した使用例

- **参照セクション**: `atelier-guild-rank-requirements.md` - 4. 想定される使用例
  - 4.1 基本的な使用パターン（シナリオ1: 正常な起動フロー、シナリオ2: rexUIプラグイン利用確認）
  - 4.2 エッジケース（マスターデータ読み込み失敗、WebGL非対応、画面サイズの極端なケース）
  - 4.3 エラーケース（サービス初期化失敗、シーン遷移失敗）

---

## 7. テストケース実装ファイル構成

### 7.1 ユニットテスト

| テストファイルパス | テスト対象 | テストケース |
|------------------|----------|------------|
| `tests/unit/presentation/scenes/BootScene.test.ts` | BootScene | T-0008-01（データ読み込み）、プログレスバー更新 |
| `tests/unit/presentation/scenes/BaseScene.test.ts` | BaseScene | EventBus購読管理、shutdown時の全購読解除 |
| `tests/unit/main.test.ts` | main.ts | T-0008-01（Phaser起動）、T-0008-03（rexUI登録） |

### 7.2 E2Eテスト

| テストファイルパス | テスト対象 | テストケース |
|------------------|----------|------------|
| `e2e/specs/boot.spec.ts` | ゲーム起動 | T-0008-01（起動確認）、T-0008-02（シーン遷移）、コンソールエラー確認 |
| `e2e/specs/scale.spec.ts` | スケーリング | 最小解像度、4K解像度、アスペクト比21:9 |

### 7.3 テスト実装の優先順位

#### 必須実装（信頼性: 🔵）

1. **T-0008-01**: Phaserゲーム起動テスト
2. **T-0008-02**: シーン遷移テスト（Boot → Title）
3. **T-0008-03**: rexUIプラグイン登録テスト
4. マスターデータ読み込みテスト
5. プログレスバー更新テスト

#### 推奨実装（信頼性: 🟡）

6. JSONファイル読み込み失敗テスト
7. サービス初期化失敗テスト
8. 最小解像度でのスケーリングテスト
9. 4K解像度でのスケーリングテスト

#### オプション実装（信頼性: 🔴）

10. 空のマスターデータでの動作テスト
11. 極端に大きいマスターデータでの読み込みテスト
12. アスペクト比が異なる画面でのテスト

---

## 8. テスト実装時の注意事項

### 8.1 Phaserのモック化

- `tests/setup.ts`でPhaserをモック化済み
- BootSceneのテストでは、Phaser.Sceneの継承を考慮
- `this.load.json()`などのPhaserメソッドをvi.spyOn()でスパイ化

### 8.2 非同期処理のテスト

- Phaserのローダーは非同期で動作する
- `load.on('complete')`イベントを待機する必要がある
- Vitestの`waitFor()`を使用してイベント発火を待機

### 8.3 E2Eテストの安定化

- `waitForGameLoad()`で確実にゲーム起動を待機
- タイムアウトを適切に設定（デフォルト5秒）
- スクリーンショット取得でビジュアルリグレッションを検出

### 8.4 カバレッジ目標

- ユニットテスト: 80%以上（vitest.config.tsで設定済み）
- E2Eテスト: 主要フローを網羅

---

## 9. テスト実装例（サンプルコード）

### 9.1 ユニットテスト例

```typescript
/**
 * BootScene テストケース
 * TASK-0008 Phaser基本設定とBootScene
 */

import { BootScene } from '@presentation/scenes/BootScene';
import { beforeEach, describe, expect, it, vi } from 'vitest';

describe('BootScene', () => {
  let bootScene: BootScene;

  beforeEach(() => {
    // 【テスト前準備】: BootSceneインスタンスを初期化
    // 【環境初期化】: Phaserモックをリセット
    bootScene = new BootScene();
    vi.clearAllMocks();
  });

  afterEach(() => {
    // 【テスト後処理】: リソース解放
    // 【状態復元】: モックをリストア
    bootScene.shutdown();
    vi.restoreAllMocks();
  });

  describe('preload()', () => {
    it('T-0008-01: 全てのマスターデータJSONファイルが読み込まれる', () => {
      // 【テスト目的】: マスターデータの初期読み込みが正常に完了することを確認
      // 【テスト内容】: this.load.json()で6種類のマスターデータが読み込まれることを検証
      // 【期待される動作】: cards, materials, recipes, quests, ranks, artifactsの全てが読み込まれる
      // 🔵 信頼性レベル: 要件定義書のpreload()処理内容に明記

      // 【テストデータ準備】: Phaserローダーのスパイを設定
      const loadJsonSpy = vi.spyOn(bootScene.load, 'json');

      // 【実際の処理実行】: preload()メソッドを呼び出し
      bootScene.preload();

      // 【結果検証】: this.load.json()が6回呼ばれたことを確認
      // 【検証項目】: 各マスターデータが正しいパスで読み込まれる
      // 🔵 信頼性レベル: note.mdのBootSceneで読み込むものに明記
      expect(loadJsonSpy).toHaveBeenCalledTimes(6);
      expect(loadJsonSpy).toHaveBeenCalledWith('cards', '/data/cards.json');
      expect(loadJsonSpy).toHaveBeenCalledWith('materials', '/data/materials.json');
      expect(loadJsonSpy).toHaveBeenCalledWith('recipes', '/data/recipes.json');
      expect(loadJsonSpy).toHaveBeenCalledWith('quests', '/data/quests.json');
      expect(loadJsonSpy).toHaveBeenCalledWith('ranks', '/data/ranks.json');
      expect(loadJsonSpy).toHaveBeenCalledWith('artifacts', '/data/artifacts.json');
    });

    it('プログレスバーが読み込み進捗に応じて更新される', () => {
      // 【テスト目的】: ローディングUIが正常に動作することを確認
      // 【テスト内容】: progressイベントが発火するたびにバーが更新されることを検証
      // 【期待される動作】: 進捗率0%から100%まで段階的に更新される
      // 🔵 信頼性レベル: note.mdのプログレスバー実装例に記載

      // 【テストデータ準備】: プログレスイベントのハンドラーをスパイ
      const progressHandler = vi.fn();
      bootScene.load.on('progress', progressHandler);

      bootScene.preload();

      // 【実際の処理実行】: プログレスイベントをシミュレート
      bootScene.load.emit('progress', 0.5);

      // 【結果検証】: プログレスハンドラーが呼ばれたことを確認
      // 【検証項目】: 進捗率0.5（50%）でハンドラーが実行される
      expect(progressHandler).toHaveBeenCalledWith(0.5);
    });
  });

  describe('create()', () => {
    it('T-0008-02: TitleSceneへ自動遷移する', () => {
      // 【テスト目的】: シーン遷移フローが正常に動作することを確認
      // 【テスト内容】: this.scene.start('TitleScene')が呼ばれることを検証
      // 【期待される動作】: BootScene完了後、TitleSceneが開始される
      // 🔵 信頼性レベル: 要件定義書のcreate()処理内容に明記

      // 【テストデータ準備】: シーン遷移メソッドのスパイ
      const startSpy = vi.spyOn(bootScene.scene, 'start');

      // 【実際の処理実行】: create()メソッドを呼び出し
      bootScene.create();

      // 【結果検証】: TitleSceneへの遷移が実行されたことを確認
      // 【検証項目】: 正しいシーンキー'TitleScene'が渡される
      expect(startSpy).toHaveBeenCalledWith('TitleScene');
    });
  });
});
```

### 9.2 E2Eテスト例（既存boot.spec.tsの拡張）

```typescript
import { expect, test } from '../fixtures/game.fixture';
import { GamePage } from '../pages/game.page';

test.describe('Game Boot', () => {
  test('T-0008-01: ゲームが正常に起動する', async ({ gamePage }) => {
    // 【テスト目的】: Phaserエンジンの基本設定が正しく動作することを確認
    // 【テスト内容】: ゲームキャンバスが表示され、エラーが発生しないことを検証
    // 【期待される動作】: エラーなく起動し、BootSceneが実行される
    // 🔵 信頼性レベル: タスク定義（TASK-0008.md）の受け入れ基準に明記

    const game = new GamePage(gamePage);
    await game.waitForGameLoad();

    // 【検証項目】: キャンバスが可視状態であることを確認
    await expect(game.canvas).toBeVisible();
  });

  test('T-0008-02: BootSceneからTitleSceneへ遷移する', async ({ gamePage }) => {
    // 【テスト目的】: シーン遷移が正常に動作することを確認
    // 【テスト内容】: BootScene完了後、TitleSceneの画面が表示されることを検証
    // 【期待される動作】: TitleSceneのタイトルテキストが表示される
    // 🔵 信頼性レベル: タスク定義（TASK-0008.md）の受け入れ基準に明記

    const game = new GamePage(gamePage);
    await game.waitForGameLoad();

    // 【検証項目】: TitleSceneの要素が表示されることを確認
    // 注: TitleSceneの実装に合わせてセレクターを調整
    await expect(gamePage.locator('text=Atelier Guild Rank')).toBeVisible({ timeout: 5000 });
  });

  test('T-0008-03: rexUIプラグインが利用可能', async ({ gamePage }) => {
    // 【テスト目的】: rexUIプラグインの統合が正しく動作することを確認
    // 【テスト内容】: rexUIで作成されたUI要素が表示されることを検証
    // 【期待される動作】: rexUIコンポーネントがエラーなく動作する
    // 🔵 信頼性レベル: タスク定義（TASK-0008.md）の受け入れ基準に明記

    const game = new GamePage(gamePage);
    await game.waitForGameLoad();

    // 【検証項目】: コンソールにrexUI関連のエラーがないことを確認
    const errors: string[] = [];
    gamePage.on('console', (msg) => {
      if (msg.type() === 'error' && msg.text().includes('rexUI')) {
        errors.push(msg.text());
      }
    });

    await gamePage.waitForTimeout(2000); // BootScene完了待機

    expect(errors).toHaveLength(0);
  });
});
```

---

## 10. 変更履歴

| 日付 | バージョン | 変更内容 |
|------|----------|---------|
| 2026-01-16 | 1.0.0 | 初版作成（TDDテストケース定義書） |

---

## 備考

- 本テストケース定義書は、TDD開発のRedフェーズ（失敗テスト作成）の基礎資料として使用します
- 各テストケースは、実装前にまず失敗することを確認してから実装を開始します
- テストケースの信頼性レベル（🔵🟡🔴）は、実装時に見直し・更新する可能性があります
- 実装中に新たなエッジケースが発見された場合は、本文書を更新してテストケースを追加します
